<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Backgammon â€“ Solo or 2P</title>
  <style>
    :root {
      --bg: #120d0a;
      --panel: #1a1411;
      --panel-border: #2d2019;
      --text: #f6efe6;
      --muted: #c3b29e;
      --accent: #f2b25d;
      --btn: #2f241d;
      --btn-2: #3a2c23;
      --tri-a: #7a4f2b;
      --tri-b: #f1d9b0;
      --point-outline: rgba(61, 43, 31, 0.45);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at 20% 20%, #1c120c, #0d0907 55%);
      color: var(--text);
      min-height: 100vh;
    }
    #app { display: flex; flex-direction: column; min-height: 100vh; }
    header {
      display: flex; justify-content: space-between; align-items: center;
      padding: 12px 16px; gap: 12px;
      background: rgba(46, 32, 25, 0.8);
      border-bottom: 1px solid var(--panel-border);
      backdrop-filter: blur(6px);
    }
    header h1 { margin: 0; font-size: 20px; letter-spacing: 0.5px; }
    header .subtitle { margin: 2px 0 0; color: var(--muted); font-size: 13px; }
    .row { display: flex; align-items: center; gap: 8px; }
    main { flex: 1; display: grid; grid-template-columns: 3fr 1fr; gap: 12px; padding: 12px; }
    #board-wrapper {
      background: #1a120d;
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      position: relative;
      overflow: hidden;
      min-height: 520px;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }
    canvas { width: 100%; height: 100%; display: block; }
    #ui-panel {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      padding: 12px;
      display: flex; flex-direction: column; gap: 12px;
      min-width: 260px;
    }
    .section h3 { margin: 0 0 6px 0; font-size: 14px; letter-spacing: 0.5px; }
    .pill {
      display: inline-block;
      background: #1c130e;
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 13px;
      color: var(--text);
      margin: 4px 4px 0 0;
    }
    .status-box {
      background: #150e0a;
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      padding: 10px;
      min-height: 40px;
      font-size: 14px;
    }
    button {
      cursor: pointer;
      border: none;
      border-radius: 8px;
      padding: 10px 14px;
      font-weight: 700;
      background: var(--btn);
      color: var(--text);
    }
    button.secondary { background: var(--btn-2); }
    button:active { transform: translateY(1px); }
    .muted { color: var(--muted); }
    .small { font-size: 13px; }
    .overlay {
      position: fixed; inset: 0; display: none;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,0.6);
      z-index: 20;
    }
    .overlay.show { display: flex; }
    .dialog {
      background: #150e0a;
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      padding: 16px 18px;
      width: min(520px, 92vw);
      color: var(--text);
      box-shadow: 0 18px 40px rgba(0,0,0,0.35);
    }
    .dialog h2 { margin: 0 0 8px 0; }
    .grid.two { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .btn-pill {
      padding: 10px 12px;
      border-radius: 10px;
      background: #1c130e;
      border: 1px solid var(--panel-border);
      text-align: center;
      font-weight: 700;
      cursor: pointer;
    }
    .btn-pill.active { outline: 2px solid var(--accent); }
    .btn-start {
      width: 100%;
      margin-top: 12px;
      padding: 12px;
      border-radius: 10px;
      background: linear-gradient(135deg, #f6d892, #d09a4f);
      color: #1a0f08;
      border: none;
      font-weight: 800;
      cursor: pointer;
    }
    @media (max-width: 960px) { main { grid-template-columns: 1fr; } #ui-panel { min-width: 0; } }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div>
        <h1>Backgammon</h1>
        <p class="subtitle">Race, hit, and bear off</p>
      </div>
      <div class="row">
        <button class="secondary" id="open-start">Start</button>
        <button class="secondary" id="open-rules">Rules</button>
        <button class="secondary" id="open-reset">Restart</button>
      </div>
    </header>
    <main>
      <div id="board-wrapper">
        <canvas id="game"></canvas>
      </div>
      <div id="ui-panel">
        <div class="section">
          <h3>Status</h3>
          <div class="pill" id="turnText">Turn: LIGHT</div>
          <div class="pill" id="diceText">Dice: --</div>
          <div class="pill" id="modeText">Mode: 2P</div>
          <div class="pill" id="aiText">AI: --</div>
          <div id="msgText" class="status-box">Ready</div>
        </div>
        <div class="section">
          <h3>Actions</h3>
          <div class="row" style="gap:8px; flex-wrap:wrap;">
            <button id="btnRoll">Roll</button>
            <button id="btnReset" class="secondary">New Game</button>
            <button id="rulesBtn" class="secondary">Rules</button>
          </div>
        </div>
        <div class="section">
          <h3>Controls</h3>
          <p class="muted small">Tap or click points to select a checker, then tap a highlighted target. Roll to start each turn. Bear off when all your checkers are in your home board.</p>
        </div>
      </div>
    </main>
  </div>

  <div id="startOverlay" class="overlay show">
    <div class="dialog">
      <h2>Backgammon</h2>
      <p>Select how you want to play. Dice and moves run locally.</p>
      <div class="grid two" style="margin-top: 8px;">
        <div class="btn-pill active" id="modeLight">Play as LIGHT vs AI</div>
        <div class="btn-pill" id="modeDark">Play as DARK vs AI</div>
        <div class="btn-pill" id="modeTwo">Two Players (local)</div>
      </div>
      <p style="margin-top:12px; font-weight:700;">AI Difficulty</p>
      <div class="grid two">
        <div class="btn-pill" id="diffEasy">Easy</div>
        <div class="btn-pill active" id="diffMed">Medium</div>
        <div class="btn-pill" id="diffHard">Hard</div>
      </div>
      <button class="btn-start" id="startBtn">Start Game</button>
      <p style="margin-top:10px; font-size:13px; color:#f2b25d;">Tap to select, tap to move. Roll at the start of your turn.</p>
    </div>
  </div>

  <div id="rulesOverlay" class="overlay">
    <div class="dialog">
      <h2>Rules</h2>
      <p>Standard backgammon: light moves from point 23 to 0; dark from 0 to 23. Enter from the bar before any other move. A point with 2+ opponent checkers is blocked; a lone checker can be hit to the bar. When all of your checkers are in your home board (0..5 for light, 18..23 for dark), you may bear off exactly with a die or from the highest occupied point if overshooting.</p>
      <p>Dice doubles give four moves. If both dice cannot be used, you must use the higher die; if only one die can be played, that is the move. The game enforces max-usage automatically.</p>
      <p>Win by bearing off all 15 checkers. UI shows legal targets after you select a source.</p>
      <div class="row" style="justify-content:flex-end; margin-top:10px;">
        <button class="secondary" id="closeRules">Close</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const boardWrapper = document.getElementById('board-wrapper');

    const turnText = document.getElementById('turnText');
    const diceText = document.getElementById('diceText');
    const modeText = document.getElementById('modeText');
    const aiText = document.getElementById('aiText');
    const msgText = document.getElementById('msgText');
    const btnRoll = document.getElementById('btnRoll');
    const btnReset = document.getElementById('btnReset');
    const btnRules = document.getElementById('rulesBtn');
    const startOverlay = document.getElementById('startOverlay');
    const rulesOverlay = document.getElementById('rulesOverlay');
    const closeRules = document.getElementById('closeRules');
    const startBtn = document.getElementById('startBtn');

    const modeLight = document.getElementById('modeLight');
    const modeDark = document.getElementById('modeDark');
    const modeTwo = document.getElementById('modeTwo');
    const diffEasy = document.getElementById('diffEasy');
    const diffMed = document.getElementById('diffMed');
    const diffHard = document.getElementById('diffHard');

    let points = [];
    let bar = {1:0, 2:0};
    let borneOff = {1:0, 2:0};
    let currentPlayer = 1; // 1=light, 2=dark
    let dice = [];
    let selectedPoint = null;
    let legalTargets = [];
    let gameOver = false;
    let aiThinking = false;
    let humanControl = {1:true, 2:true};
    let gameMode = 'two'; // 'light','dark','two'
    let aiLevel = 'medium';
    let lastAIDice = [];
    let showLastAIDice = false;

    const dpr = window.devicePixelRatio || 1;

    function isStackedLayout() {
      const wrapperWidth = boardWrapper?.getBoundingClientRect().width || window.innerWidth;
      const basis = Math.min(window.innerWidth, wrapperWidth);
      return basis <= 900; // treat phones/tablets as stacked
    }

    function resizeCanvas() {
      const rect = boardWrapper.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw();
    }

    function setActive(activeEl, others) {
      activeEl.classList.add('active');
      others.forEach(el => el.classList.remove('active'));
    }

    function initPoints() {
      points = new Array(24).fill(0).map(() => ({ color: 0, count: 0 }));
      points[23] = { color: 1, count: 2 };
      points[12] = { color: 1, count: 5 };
      points[7]  = { color: 1, count: 3 };
      points[5]  = { color: 1, count: 5 };
      points[0]  = { color: 2, count: 2 };
      points[11] = { color: 2, count: 5 };
      points[16] = { color: 2, count: 3 };
      points[18] = { color: 2, count: 5 };
      bar = { 1:0, 2:0 };
      borneOff = { 1:0, 2:0 };
      currentPlayer = 1;
      dice = [];
      aiThinking = false; // ensure clean turn state on resets
      lastAIDice = [];
      showLastAIDice = false;
      selectedPoint = null;
      legalTargets = [];
      gameOver = false;
      msgText.textContent = 'Roll to start';
      updateUI();
      computeAllLegalMoves();
      draw();
    }

    function directionFor(p) { return p === 1 ? -1 : 1; }
    function isInHome(player, idx) { return player === 1 ? (idx >= 0 && idx <= 5) : (idx >= 18 && idx <= 23); }
    function allInHome(player) {
      for (let i = 0; i < 24; i++) {
        if (points[i].color === player && points[i].count > 0 && !isInHome(player, i)) return false;
      }
      return bar[player] === 0;
    }

    function rollDice() {
      if (gameOver || aiThinking) return;
      if (!isHumanTurn()) return;
      lastAIDice = [];
      showLastAIDice = false;
      const d1 = 1 + Math.floor(Math.random() * 6);
      const d2 = 1 + Math.floor(Math.random() * 6);
      dice = (d1 === d2) ? [d1, d1, d1, d1] : [d1, d2];
      selectedPoint = null;
      computeAllLegalMoves();
      if (legalTargets.length === 0) {
        msgText.textContent = 'No legal moves. Turn passes.';
        setTimeout(() => { dice = []; endTurn(); }, 700);
      } else {
        msgText.textContent = 'Your move';
      }
      updateUI();
      draw();
    }

    function endTurn() {
      aiThinking = false; // always clear AI lock when a turn ends
      selectedPoint = null;
      legalTargets = [];
      dice = [];
      currentPlayer = currentPlayer === 1 ? 2 : 1;
      updateUI();
      computeAllLegalMoves();
      if (!isHumanTurn()) maybeAITurn();
      draw();
    }

    function isHumanTurn() { return humanControl[currentPlayer]; }

    function computeAllLegalMoves() {
      legalTargets = [];
      if (dice.length === 0) return;
      if (bar[currentPlayer] > 0) {
        for (let d of [...new Set(dice)]) {
          const t = targetFromBar(currentPlayer, d);
          if (isOpen(t, currentPlayer)) legalTargets.push({ from: 'bar', to: t, die: d });
        }
        return;
      }
      for (let i = 0; i < 24; i++) {
        if (points[i].color !== currentPlayer || points[i].count === 0) continue;
        for (let d of [...new Set(dice)]) {
          const t = i + directionFor(currentPlayer) * d;
          if (t >= 0 && t <= 23) {
            if (isOpen(t, currentPlayer)) legalTargets.push({ from: i, to: t, die: d });
          } else if (allInHome(currentPlayer)) {
            const canBear = canBearOffFrom(i, d, currentPlayer);
            if (canBear) legalTargets.push({ from: i, to: 'bear', die: d });
          }
        }
      }
    }

    function targetFromBar(player, die) {
      return player === 1 ? 24 - die : die - 1;
    }

    function isOpen(idx, player) {
      if (idx < 0 || idx > 23) return false;
      const p = points[idx];
      return !(p.color !== 0 && p.color !== player && p.count >= 2);
    }

    function canBearOffFrom(idx, die, player) {
      if (!allInHome(player)) return false;
      const dir = directionFor(player);
      const target = idx + dir * die;
      if (player === 1) {
        if (target < 0) return true;
        if (target === -1) return true;
        if (target >= 0 && target <= 5) return true;
        return false;
      } else {
        if (target > 23) return true;
        if (target === 24) return true;
        if (target >= 18 && target <= 23) return true;
        return false;
      }
    }

    function useDie(d) {
      const idx = dice.indexOf(d);
      if (idx !== -1) { dice.splice(idx, 1); return true; }
      return false;
    }

    function handleClick(evt) {
      if (gameOver || aiThinking) return;
      if (dice.length === 0) { msgText.textContent = 'Roll first, then pick a checker'; return; }
      const rect = canvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
      const y = (evt.clientY - rect.top) * (canvas.height / rect.height);
      const hit = hitTestPoint(x, y);
      if (!hit) return;
      if (hit.type === 'point') {
        if (selectedPoint === hit.index) { selectedPoint = null; draw(); return; }
        if (points[hit.index].color === currentPlayer && points[hit.index].count > 0) {
          selectedPoint = hit.index; draw();
        } else if (selectedPoint !== null) {
          tryMove(selectedPoint, hit.index);
        }
      } else if (hit.type === 'bar' && bar[currentPlayer] > 0) {
        selectedPoint = 'bar'; draw();
      }
    }

    function tryMove(from, to) {
      const moves = legalTargets.filter(m => m.from === from && (m.to === to || (m.to === 'bear' && to === 'bear')));
      if (moves.length === 0) return;
      const move = moves[0];
      if (!useDie(move.die)) return;
      applyMove(move);
      computeAllLegalMoves();
      draw();
      if (dice.length === 0 || legalTargets.length === 0) {
        if (legalTargets.length === 0) msgText.textContent = 'No more moves. Turn passes.';
        setTimeout(endTurn, 200);
      }
    }

    function applyMove(move) {
      const player = currentPlayer;
      if (move.from === 'bar') {
        bar[player]--;
      } else {
        points[move.from].count--;
        if (points[move.from].count === 0) points[move.from].color = 0;
      }
      if (move.to === 'bear') {
        borneOff[player]++;
        if (borneOff[player] >= 15) { gameOver = true; msgText.textContent = player === 1 ? 'Light wins!' : 'Dark wins!'; }
        selectedPoint = null;
        updateUI();
        return;
      }
      const target = points[move.to];
      if (target.color !== 0 && target.color !== player && target.count === 1) {
        const opp = player === 1 ? 2 : 1;
        bar[opp]++;
        target.color = player;
        target.count = 1;
      } else {
        target.color = player;
        target.count += 1;
      }
      selectedPoint = null;
      updateUI();
    }

    function hitTestPoint(x, y) {
      const margin = Math.max(18, Math.min(canvas.width, canvas.height) * 0.06);
      const usableWidth = canvas.width - margin * 2;
      const usableHeight = canvas.height - margin * 2;
      const ox = margin;
      const oy = margin;
      const localX = x - ox;
      const localY = y - oy;
      if (localX < 0 || localX > usableWidth || localY < 0 || localY > usableHeight) return null;

      if (!isStackedLayout()) {
        const barW = usableWidth * 0.06;
        const ptW = (usableWidth - barW) / 12;
        const ptH = usableHeight / 2;
        const leftHalfW = ptW * 6;

        if (localX >= leftHalfW && localX <= leftHalfW + barW) return { type:'bar' };

        const isTop = localY < ptH;
        if (localX < leftHalfW) {
          const col = Math.floor(localX / ptW);
          const idx = isTop ? 12 + col : col;
          return { type:'point', index: idx };
        }

        const rightX = localX - leftHalfW - barW;
        const colR = Math.floor(rightX / ptW);
        if (colR < 0 || colR > 5) return null;
        const idx = isTop ? 18 + colR : 6 + colR;
        return { type:'point', index: idx };
      }

      // Stacked layout: left half on top, right half on bottom
      const barH = usableHeight * 0.06;
      const segmentH = (usableHeight - barH) / 2;
      const ptW = usableWidth / 6;
      const ptH = segmentH / 2;

      // Bar region between segments
      if (localY >= segmentH && localY <= segmentH + barH) return { type:'bar' };

      const inTopSegment = localY < segmentH;
      const segY = inTopSegment ? localY : localY - segmentH - barH;
      const isTopRow = segY < ptH;
      const col = Math.floor(localX / ptW);
      if (col < 0 || col > 5) return null;

      let idx;
      if (inTopSegment) {
        idx = isTopRow ? 12 + col : col; // left half indices
      } else {
        idx = isTopRow ? 18 + col : 6 + col; // right half indices
      }
      return { type:'point', index: idx };
    }

    function draw() {
      if (!canvas.width || !canvas.height) return;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const margin = Math.max(18, Math.min(canvas.width, canvas.height) * 0.06);
      const usableWidth = canvas.width - margin * 2;
      const usableHeight = canvas.height - margin * 2;
      const ox = margin;
      const oy = margin;
      const stacked = isStackedLayout();

      ctx.fillStyle = '#e8dcc4';
      ctx.fillRect(ox, oy, usableWidth, usableHeight);
      ctx.strokeStyle = 'rgba(61,43,31,0.35)';
      ctx.lineWidth = 2;
      ctx.strokeRect(ox, oy, usableWidth, usableHeight);

      const stackGap = 4;

      if (!stacked) {
        const barW = usableWidth * 0.06;
        const ptW = (usableWidth - barW) / 12;
        const ptH = usableHeight / 2;
        const leftHalfW = ptW * 6;

        ctx.fillStyle = '#c19a6b';
        const barX = ox + (usableWidth - barW)/2;
        ctx.fillRect(barX, oy, barW, usableHeight);

        function drawPointTriangle(col, isLeft, isTop) {
          const x0 = isLeft ? ox + col * ptW : ox + 6 * ptW + barW + col * ptW;
          const y0 = isTop ? oy : oy + usableHeight;
          const dir = isTop ? 1 : -1;
          const color = (col % 2 === 0) ? 'var(--tri-a)' : 'var(--tri-b)';
          ctx.beginPath();
          ctx.moveTo(x0, y0);
          ctx.lineTo(x0 + ptW, y0);
          ctx.lineTo(x0 + ptW/2, y0 + dir * ptH * 0.92);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
          ctx.strokeStyle = 'var(--point-outline)';
          ctx.stroke();
        }

        for (let row = 0; row < 2; row++) {
          const isTop = row === 0;
          for (let col = 0; col < 6; col++) {
            drawPointTriangle(col, true, isTop);  // left half
          }
          for (let col = 0; col < 6; col++) {
            drawPointTriangle(col, false, isTop); // right half
          }
        }

        const radius = Math.min(ptW, ptH) * 0.28;
        function pointX(idx) {
          const topRow = idx >= 12;
          const pos = topRow ? idx - 12 : idx; // 0..11 in each row
          if (pos < 6) return ox + pos * ptW + ptW/2;
          const colR = pos - 6;
          return ox + leftHalfW + barW + colR * ptW + ptW/2;
        }
        function drawStack(idx) {
          const p = points[idx];
          if (!p.count) return;
          const topRow = idx >= 12;
          const xCenter = pointX(idx);
          for (let n = 0; n < p.count; n++) {
            const yBase = topRow ? oy + radius + n * (radius*2 + stackGap) : oy + usableHeight - radius - n * (radius*2 + stackGap);
            ctx.beginPath();
            ctx.arc(xCenter, yBase, radius, 0, Math.PI * 2);
            ctx.fillStyle = p.color === 1 ? '#f5f7fb' : '#111';
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.35)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
          }
        }
        for (let i = 0; i < 24; i++) drawStack(i);

        function drawBarStack(player, count, topRow) {
          if (count === 0) return;
          for (let n = 0; n < count; n++) {
            const xCenter = ox + (usableWidth - barW)/2 + barW/2;
            const yBase = topRow ? oy + radius + n * (radius*2 + stackGap) : oy + usableHeight - radius - n * (radius*2 + stackGap);
            ctx.beginPath();
            ctx.arc(xCenter, yBase, radius, 0, Math.PI * 2);
            ctx.fillStyle = player === 1 ? '#f5f7fb' : '#111';
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.35)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
          }
        }
        drawBarStack(1, bar[1], true);
        drawBarStack(2, bar[2], false);

      } else {
        const barH = usableHeight * 0.06;
        const segmentH = (usableHeight - barH) / 2;
        const ptW = usableWidth / 6;
        const ptH = segmentH / 2;

        // Draw horizontal bar between halves
        ctx.fillStyle = '#c19a6b';
        const barY = oy + segmentH;
        ctx.fillRect(ox, barY, usableWidth, barH);

        function drawPointTriangleStacked(col, upperSegment, isTopRow) {
          const segY = upperSegment ? oy : oy + segmentH + barH;
          const x0 = ox + col * ptW;
          const y0 = isTopRow ? segY : segY + segmentH;
          const dir = isTopRow ? 1 : -1;
          const color = (col % 2 === 0) ? 'var(--tri-a)' : 'var(--tri-b)';
          ctx.beginPath();
          ctx.moveTo(x0, y0);
          ctx.lineTo(x0 + ptW, y0);
          ctx.lineTo(x0 + ptW/2, y0 + dir * ptH * 0.92);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
          ctx.strokeStyle = 'var(--point-outline)';
          ctx.stroke();
        }

        for (let col = 0; col < 6; col++) {
          drawPointTriangleStacked(col, true, true);  // top row, upper segment (indices 12-17)
          drawPointTriangleStacked(col, true, false); // bottom row, upper segment (0-5)
          drawPointTriangleStacked(col, false, true); // top row, lower segment (18-23)
          drawPointTriangleStacked(col, false, false);// bottom row, lower segment (6-11)
        }

        const radius = Math.min(ptW, ptH) * 0.28;
        function pointCenter(idx) {
          let col, upperSegment, isTopRow;
          if (idx <= 5) { col = idx; upperSegment = true; isTopRow = false; }
          else if (idx <= 11) { col = idx - 6; upperSegment = false; isTopRow = false; }
          else if (idx <= 17) { col = idx - 12; upperSegment = true; isTopRow = true; }
          else { col = idx - 18; upperSegment = false; isTopRow = true; }

          const segY = upperSegment ? oy : oy + segmentH + barH;
          const xCenter = ox + col * ptW + ptW/2;
          const yBase = isTopRow ? (segY + radius) : (segY + segmentH - radius);
          return { xCenter, yBase, isTopRow, segY };
        }

        function drawStack(idx) {
          const p = points[idx];
          if (!p.count) return;
          const info = pointCenter(idx);
          for (let n = 0; n < p.count; n++) {
            const yBase = info.isTopRow ? (info.segY + radius + n * (radius*2 + stackGap)) : (info.segY + segmentH - radius - n * (radius*2 + stackGap));
            ctx.beginPath();
            ctx.arc(info.xCenter, yBase, radius, 0, Math.PI * 2);
            ctx.fillStyle = p.color === 1 ? '#f5f7fb' : '#111';
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.35)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
          }
        }
        for (let i = 0; i < 24; i++) drawStack(i);

        function drawBarStackHorizontal(player, count, topSide) {
          if (count === 0) return;
          const centerY = oy + segmentH + barH/2;
          for (let n = 0; n < count; n++) {
            const yCenter = centerY + (topSide ? -1 : 1) * (radius + n * (radius*2 + stackGap));
            const xCenter = ox + usableWidth/2;
            ctx.beginPath();
            ctx.arc(xCenter, yCenter, radius, 0, Math.PI * 2);
            ctx.fillStyle = player === 1 ? '#f5f7fb' : '#111';
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.35)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
          }
        }
        drawBarStackHorizontal(1, bar[1], true);
        drawBarStackHorizontal(2, bar[2], false);
      }

      drawTargets();
      drawDice();
    }

    function drawTargets() {
      if (selectedPoint === null) return;
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = '#f2b25d';
      const margin = Math.max(18, Math.min(canvas.width, canvas.height) * 0.06);
      const usableWidth = canvas.width - margin * 2;
      const usableHeight = canvas.height - margin * 2;
      const ox = margin;
      const oy = margin;
      const targets = legalTargets.filter(m => m.from === selectedPoint);
      const stacked = isStackedLayout();

      if (!stacked) {
        const barW = usableWidth * 0.06;
        const ptW = (usableWidth - barW) / 12;
        const ptH = usableHeight / 2;
        const leftHalfW = ptW * 6;
        targets.forEach(m => {
          if (m.to === 'bear') return;
          const idx = m.to;
          const topRow = idx >= 12;
          const pos = topRow ? idx - 12 : idx;
          const inLeft = pos < 6;
          const x0 = inLeft ? ox + pos * ptW : ox + leftHalfW + barW + (pos - 6) * ptW;
          const y0 = topRow ? oy : oy + ptH;
          ctx.fillRect(x0, y0, ptW, ptH);
        });
      } else {
        const barH = usableHeight * 0.06;
        const segmentH = (usableHeight - barH) / 2;
        const ptW = usableWidth / 6;
        const ptH = segmentH / 2;
        targets.forEach(m => {
          if (m.to === 'bear') return;
          const idx = m.to;
          let col, upperSegment, isTopRow;
          if (idx <= 5) { col = idx; upperSegment = true; isTopRow = false; }
          else if (idx <= 11) { col = idx - 6; upperSegment = false; isTopRow = false; }
          else if (idx <= 17) { col = idx - 12; upperSegment = true; isTopRow = true; }
          else { col = idx - 18; upperSegment = false; isTopRow = true; }
          const segY = upperSegment ? oy : oy + segmentH + barH;
          const x0 = ox + col * ptW;
          const y0 = isTopRow ? segY : segY + ptH;
          ctx.fillRect(x0, y0, ptW, ptH);
        });
      }
      ctx.restore();
    }

    function drawDice() {
      const size = 42;
      const padding = 10;
      const x0 = canvas.width / dpr - size * 2 - padding * 3;
      const y0 = padding + 6;
      const displayDice = dice.length ? dice : (showLastAIDice ? lastAIDice : []);
      displayDice.slice(0,2).forEach((d, idx) => {
        const x = x0 + idx * (size + padding);
        ctx.fillStyle = '#2f241d';
        ctx.strokeStyle = 'rgba(61,43,31,0.35)';
        ctx.lineWidth = 2;
        roundRect(ctx, x, y0, size, size, 8);
        ctx.fill();
        ctx.stroke();
        drawPips(x, y0, size, d);
      });
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    function drawPips(x, y, size, value) {
      ctx.fillStyle = '#f5f7fb';
      const c = size / 2;
      const o = size / 4;
      const positions = {
        1: [[c, c]],
        2: [[c - o, c - o], [c + o, c + o]],
        3: [[c - o, c - o], [c, c], [c + o, c + o]],
        4: [[c - o, c - o], [c + o, c - o], [c - o, c + o], [c + o, c + o]],
        5: [[c - o, c - o], [c + o, c - o], [c, c], [c - o, c + o], [c + o, c + o]],
        6: [[c - o, c - o], [c + o, c - o], [c - o, c], [c + o, c], [c - o, c + o], [c + o, c + o]]
      };
      positions[value].forEach(p => {
        ctx.beginPath();
        ctx.arc(x + p[0], y + p[1], 4.2, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function updateUI() {
      turnText.textContent = 'Turn: ' + (currentPlayer === 1 ? 'LIGHT' : 'DARK');
      const diceLabel = dice.length ? dice.join(',') : (showLastAIDice && lastAIDice.length ? 'AI last: ' + lastAIDice.join(',') : '--');
      diceText.textContent = 'Dice: ' + diceLabel;
      modeText.textContent = 'Mode: ' + (gameMode === 'two' ? '2P' : 'vs AI');
      aiText.textContent = 'AI: ' + (gameMode === 'two' ? '--' : aiLevel);
    }

    function resetGame() { initPoints(); draw(); }

    function setMode(mode) {
      gameMode = mode;
      if (mode === 'light') humanControl = {1:true, 2:false};
      else if (mode === 'dark') humanControl = {1:false, 2:true};
      else humanControl = {1:true, 2:true};
      updateUI();
    }
    function setDifficulty(level) { aiLevel = level; aiText.textContent = 'AI: ' + level; }

    function startGame() {
      startOverlay.classList.remove('show');
      resetGame();
      if (!isHumanTurn()) maybeAITurn();
    }

    function maybeAITurn() {
      if (gameOver || gameMode === 'two' || humanControl[currentPlayer] || aiThinking) return;
      aiThinking = true;
      setTimeout(() => rollDiceAI(true), 350);
    }

    function rollDiceAI(isRootCall = false) {
      // Bail out if the turn has switched to a human (e.g. after reset or a stray timer)
      if (gameOver || gameMode === 'two' || humanControl[currentPlayer]) { aiThinking = false; return; }
      const d1 = 1 + Math.random() * 6 | 0;
      const d2 = 1 + Math.random() * 6 | 0;
      dice = (d1 === d2) ? [d1,d1,d1,d1] : [d1,d2];
      lastAIDice = dice.slice();
      showLastAIDice = true;
      msgText.textContent = 'AI rolled ' + dice.join(',');
      updateUI();
      draw();
      computeAllLegalMoves();
      if (legalTargets.length === 0) {
        dice = [];
        aiThinking = false;
        endTurn();
        return;
      }
      setTimeout(aiPlayStep, 260);
    }

    function aiPlayStep() {
      // Stop if control flipped
      if (gameOver || gameMode === 'two' || humanControl[currentPlayer]) { aiThinking = false; return; }
      computeAllLegalMoves();
      if (legalTargets.length === 0 || dice.length === 0) {
        aiThinking = false;
        endTurn();
        return;
      }
      const move = legalTargets[0];
      useDie(move.die);
      applyMove(move);
      computeAllLegalMoves();
      draw();
      if (dice.length === 0 || legalTargets.length === 0) {
        aiThinking = false;
        endTurn();
      } else {
        setTimeout(aiPlayStep, 220);
      }
    }

    canvas.addEventListener('click', handleClick);
    btnRoll.addEventListener('click', rollDice);
    btnReset.addEventListener('click', resetGame);
    btnRules.addEventListener('click', () => rulesOverlay.classList.add('show'));
    document.getElementById('open-rules').addEventListener('click', () => rulesOverlay.classList.add('show'));
    document.getElementById('open-start').addEventListener('click', () => startOverlay.classList.add('show'));
    document.getElementById('open-reset').addEventListener('click', resetGame);
    closeRules.addEventListener('click', () => rulesOverlay.classList.remove('show'));
    startBtn.addEventListener('click', startGame);

    modeLight.addEventListener('click', () => { setMode('light'); setActive(modeLight, [modeDark, modeTwo]); });
    modeDark.addEventListener('click', () => { setMode('dark'); setActive(modeDark, [modeLight, modeTwo]); });
    modeTwo.addEventListener('click', () => { setMode('two'); setActive(modeTwo, [modeLight, modeDark]); });
    diffEasy.addEventListener('click', () => { setDifficulty('easy'); setActive(diffEasy, [diffMed, diffHard]); });
    diffMed.addEventListener('click', () => { setDifficulty('medium'); setActive(diffMed, [diffEasy, diffHard]); });
    diffHard.addEventListener('click', () => { setDifficulty('hard'); setActive(diffHard, [diffEasy, diffMed]); });

    window.addEventListener('resize', resizeCanvas);

    // Align initial state with the default-selected pills in the start overlay
    setMode('light');
    setActive(modeLight, [modeDark, modeTwo]);
    setDifficulty('medium');
    setActive(diffMed, [diffEasy, diffHard]);

    resizeCanvas();
    initPoints();
    draw();
  </script>
</body>
</html>
