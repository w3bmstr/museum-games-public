<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
	<title>Backgammon â€“ Solo or 2P</title>
	<style>
		:root {
			--bg: #0c0f16;
			--panel: #141a26;
			--panel-2: #0f1623;
			--accent: #58d28c;
			--accent-2: #ffd166;
			--text: #f5f7fb;
			--muted: #9aa7bd;
			--tri-a: #1a2539;
			--tri-b: #2a3650;
			--point-outline: rgba(255,255,255,0.08);
		}
		* { box-sizing: border-box; }
		html, body { margin: 0; padding: 0; width: 100%; min-height: 100vh; }
		body {
			background: radial-gradient(circle at 20% 20%, #121828, var(--bg) 42%);
			font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
			color: var(--text);
			padding: env(safe-area-inset-top, 0px) env(safe-area-inset-right, 0px) env(safe-area-inset-bottom, 0px) env(safe-area-inset-left, 0px);
			overflow-x: hidden;
			overflow-y: auto;
		}
		#app {
			width: 100%;
			max-width: 1500px;
			margin: 0 auto;
			min-height: 100vh;
			background: var(--panel);
			border: 1px solid rgba(255,255,255,0.06);
			border-radius: 16px;
			overflow: hidden;
			box-shadow: 0 20px 60px rgba(0,0,0,0.35);
			display: flex;
			flex-direction: column;
			position: relative;
			z-index: 1;
		}
		header {
			padding: 18px 22px 12px;
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			background: linear-gradient(90deg, rgba(88,210,140,0.15), transparent);
			border-bottom: 1px solid rgba(255,255,255,0.06);
			z-index: 2;
		}
		header h1 { margin: 0; font-size: 20px; letter-spacing: 0.4px; color: var(--accent-2); }
		header .subtitle { margin: 0; color: var(--muted); font-size: 13px; }
		.row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
		button {
			border: none;
			border-radius: 8px;
			padding: 10px 12px;
			font-size: 14px;
			cursor: pointer;
			background: var(--accent);
			color: #0c0f16;
			transition: transform 0.1s ease, box-shadow 0.2s ease;
		}
		button.secondary { background: rgba(255,255,255,0.12); color: var(--text); }
		button:disabled { opacity: 0.5; cursor: not-allowed; }
		button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 10px 22px rgba(0,0,0,0.25); }

		main {
			display: grid;
			grid-template-columns: minmax(0,1fr) 320px;
			gap: 0;
			flex: 1;
			min-height: 0;
			overflow: hidden;
		}
		#board-wrapper {
			padding: 18px;
			background: #0d121d;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			min-height: 0;
			overflow: hidden;
		}
		canvas {
			display: block;
			margin: auto;
			background: #0e1523;
			border-radius: 12px;
			box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05), 0 14px 30px rgba(0,0,0,0.35);
			width: 100%;
			height: auto;
			max-width: 1200px;
			max-height: 100%;
			aspect-ratio: 16 / 10;
			cursor: pointer;
		}
		#ui-panel {
			padding: 18px 18px 24px;
			border-left: 1px solid rgba(255,255,255,0.06);
			background: rgba(10,14,24,0.78);
			height: 100%;
			overflow-y: auto;
			min-height: 0;
		}
		.section { margin-bottom: 16px; padding: 12px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06); border-radius: 10px; }
		.section h3 { margin: 0 0 8px; font-size: 14px; letter-spacing: 0.6px; color: var(--muted); text-transform: uppercase; }
		.pill { padding: 9px 12px; border-radius: 999px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); font-size: 13px; display: inline-flex; align-items: center; gap: 6px; margin: 4px 4px 0 0; }
		.status-box { padding: 10px 12px; border-radius: 10px; background: rgba(88,210,140,0.1); border: 1px solid rgba(88,210,140,0.2); font-size: 14px; }
		.muted { color: var(--muted); }
		.small { font-size: 13px; line-height: 1.5; margin: 0; }

		.overlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(8,10,16,0.82); backdrop-filter: blur(4px); z-index: 20; padding: 12px; }
		.overlay.show { display: flex; }
		.dialog { background: var(--panel-2); border: 1px solid rgba(255,255,255,0.08); padding: 20px; border-radius: 12px; width: min(540px, 92%); box-shadow: 0 16px 50px rgba(0,0,0,0.35); }
		.dialog h2, .dialog h1 { margin: 0 0 8px; }
		.dialog p { margin: 4px 0; color: var(--muted); line-height: 1.6; font-size: 14px; }
		.grid { display: grid; gap: 10px; }
		.grid.two { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
		.btn-pill {
			border: 1px solid rgba(255,255,255,0.08);
			background: linear-gradient(135deg, #1c1c1c, #0f0f0f);
			border-radius: 12px;
			padding: 12px;
			color: #eee;
			cursor: pointer;
			text-align: center;
			font-weight: 700;
			transition: 120ms ease;
		}
		.btn-pill.active { border-color: var(--accent); box-shadow: 0 0 0 1px var(--accent) inset; }
		.btn-start {
			width: 100%;
			padding: 12px;
			border: none;
			border-radius: 12px;
			background: linear-gradient(135deg, #58d28c, #7de6a6);
			color: #0d1f12;
			font-weight: 800;
			cursor: pointer;
			margin-top: 10px;
			font-size: 15px;
		}
		#modeText, #aiText { color: #9ad7ff; font-weight: 700; }

		@media (max-width: 980px) {
			main { grid-template-columns: 1fr; }
			#ui-panel { border-left: none; border-top: 1px solid rgba(255,255,255,0.06); }
		}
		@media (max-width: 640px) {
			#board-wrapper { padding: 10px; }
			header { flex-direction: column; align-items: flex-start; padding: 18px 14px 10px; }
			body { padding: env(safe-area-inset-top, 0px) env(safe-area-inset-right, 0px) env(safe-area-inset-bottom, 0px) env(safe-area-inset-left, 0px); }
		}
	</style>
</head>
<body>
	<div id="app">
		<header>
			<div>
				<h1>Backgammon</h1>
				<p class="subtitle">Race, hit, and bear off</p>
			</div>
			<div class="row">
				<button class="secondary" id="open-start">Start</button>
				<button class="secondary" id="open-rules">Rules</button>
				<button class="secondary" id="open-reset">Restart</button>
			</div>
		</header>
		<main>
			<div id="board-wrapper">
				<canvas id="game" width="1200" height="750"></canvas>
			</div>
			<div id="ui-panel">
				<div class="section">
					<h3>Status</h3>
					<div class="pill" id="turnText">Turn: LIGHT</div>
					<div class="pill" id="diceText">Dice: --</div>
					<div class="pill" id="modeText">Mode: 2P</div>
					<div class="pill" id="aiText">AI: --</div>
					<div id="msgText" class="status-box">Ready</div>
				</div>
				<div class="section">
					<h3>Actions</h3>
					<div class="row" style="gap:8px; flex-wrap:wrap;">
						<button id="btnRoll">Roll</button>
						<button id="btnReset" class="secondary">New Game</button>
						<button id="rulesBtn" class="secondary">Rules</button>
					</div>
				</div>
				<div class="section">
					<h3>Controls</h3>
					<p class="muted small">Tap or click points to select a checker, then tap a highlighted target. Roll to start each turn. Bear off when all your checkers are in your home board.</p>
				</div>
			</div>
		</main>
	</div>

	<div id="startOverlay" class="overlay show">
		<div class="dialog">
			<h2>Backgammon</h2>
			<p>Select how you want to play. Dice and moves run locally.</p>
			<div class="grid two" style="margin-top: 8px;">
				<div class="btn-pill active" id="modeLight">Play as LIGHT vs AI</div>
				<div class="btn-pill" id="modeDark">Play as DARK vs AI</div>
				<div class="btn-pill" id="modeTwo">Two Players (local)</div>
			</div>
			<p style="margin-top:12px; font-weight:700;">AI Difficulty</p>
			<div class="grid two">
				<div class="btn-pill" id="diffEasy">Easy</div>
				<div class="btn-pill active" id="diffMed">Medium</div>
				<div class="btn-pill" id="diffHard">Hard</div>
			</div>
			<button class="btn-start" id="startBtn">Start Game</button>
			<p style="margin-top:10px; font-size:13px; color:#9ad7ff;">Tap to select, tap to move. Roll at the start of your turn.</p>
		</div>
	</div>

	<div id="rulesOverlay" class="overlay">
		<div class="dialog">
			<h2>Rules</h2>
			<p>Standard backgammon: light moves from point 23 to 0; dark from 0 to 23. Enter from the bar before any other move. A point with 2+ opponent checkers is blocked; a lone checker can be hit to the bar. When all of your checkers are in your home board (0..5 for light, 18..23 for dark), you may bear off exactly with a die or from the highest occupied point if overshooting.</p>
			<p>Dice doubles give four moves. If both dice cannot be used, you must use the higher die; if only one die can be played, that is the move. The game enforces max-usage automatically.</p>
			<p>Win by bearing off all 15 checkers. UI shows legal targets after you select a source.</p>
			<div class="row" style="justify-content:flex-end; margin-top:10px;">
				<button class="secondary" id="closeRules">Close</button>
			</div>
		</div>
	</div>

	<script>
	const canvas = document.getElementById('game');
	const ctx = canvas.getContext('2d');
	const turnText = document.getElementById('turnText');
	const diceText = document.getElementById('diceText');
	const msgText  = document.getElementById('msgText');
	const btnRoll  = document.getElementById('btnRoll');
	const btnReset = document.getElementById('btnReset');
	const btnRules = document.getElementById('rulesBtn');
	const modeText = document.getElementById('modeText');
	const aiText   = document.getElementById('aiText');
	const startOverlay = document.getElementById('startOverlay');
	const rulesOverlay = document.getElementById('rulesOverlay');
	const startBtn = document.getElementById('startBtn');
	const closeRules = document.getElementById('closeRules');
	const modeLight = document.getElementById('modeLight');
	const modeDark  = document.getElementById('modeDark');
	const modeTwo   = document.getElementById('modeTwo');
	const diffEasy  = document.getElementById('diffEasy');
	const diffMed   = document.getElementById('diffMed');
	const diffHard  = document.getElementById('diffHard');

	let gameMode = 'light';
	let aiLevel = 'medium';
	let humanControl = { 1: true, 2: false };
	let aiThinking = false;

	let points = [];
	let bar = { 1:0, 2:0 };
	let borneOff = { 1:0, 2:0 };
	let currentPlayer = 1;
	let dice = [];
	let selectedPoint = null;
	let legalTargets = [];
	let gameOver = false;

	let boardWidth, boardHeight, offsetX, offsetY;
	let pointWidth, pointHeight, barWidth;

	function initPoints() {
		points = new Array(24).fill(0).map(() => ({ color: 0, count: 0 }));
		points[23] = { color: 1, count: 2 };
		points[12] = { color: 1, count: 5 };
		points[7]  = { color: 1, count: 3 };
		points[5]  = { color: 1, count: 5 };
		points[0]  = { color: 2, count: 2 };
		points[11] = { color: 2, count: 5 };
		points[16] = { color: 2, count: 3 };
		points[18] = { color: 2, count: 5 };
		bar = { 1:0, 2:0 };
		borneOff = { 1:0, 2:0 };
		currentPlayer = 1;
		dice = [];
		selectedPoint = null;
		legalTargets = [];
		gameOver = false;
		msgText.textContent = 'Roll to start';
		updateUI();
		computeAllLegalMoves();
		draw();
	}

	function directionFor(p) { return p === 1 ? -1 : 1; }
	function isInHome(player, idx) { return player === 1 ? (idx >= 0 && idx <= 5) : (idx >= 18 && idx <= 23); }
	function allInHome(player) {
		for (let i = 0; i < 24; i++) {
			if (points[i].color === player && points[i].count > 0 && !isInHome(player, i)) return false;
		}
		return bar[player] === 0;
	}

	function rollDice() {
		if (gameOver || aiThinking) return;
		if (!isHumanTurn()) return;
		const d1 = 1 + Math.floor(Math.random() * 6);
		const d2 = 1 + Math.floor(Math.random() * 6);
		dice = (d1 === d2) ? [d1, d1, d1, d1] : [d1, d2];
		selectedPoint = null;
		computeAllLegalMoves();
		if (legalTargets.length === 0) {
			msgText.textContent = 'No legal moves. Turn passes.';
			setTimeout(() => { dice = []; endTurn(); }, 700);
		} else {
			msgText.textContent = 'Your move';
		}
		updateUI();
		draw();
	}

	function endTurn() {
		selectedPoint = null;
		legalTargets = [];
		dice = [];
		currentPlayer = currentPlayer === 1 ? 2 : 1;
		updateUI();
		computeAllLegalMoves();
		if (!isHumanTurn()) maybeAITurn();
		draw();
	}

	function isHumanTurn() { return humanControl[currentPlayer]; }

	function computeAllLegalMoves() {
		legalTargets = [];
		if (dice.length === 0) return;
		if (bar[currentPlayer] > 0) {
			for (let d of [...new Set(dice)]) {
				const t = targetFromBar(currentPlayer, d);
				if (isOpen(t, currentPlayer)) legalTargets.push({ from: 'bar', to: t, die: d });
			}
			return;
		}
		for (let i = 0; i < 24; i++) {
			if (points[i].color !== currentPlayer || points[i].count === 0) continue;
			for (let d of [...new Set(dice)]) {
				const t = i + directionFor(currentPlayer) * d;
				if (t >= 0 && t <= 23) {
					if (isOpen(t, currentPlayer)) legalTargets.push({ from: i, to: t, die: d });
				} else if (allInHome(currentPlayer)) {
					const canBear = canBearOffFrom(i, d, currentPlayer);
					if (canBear) legalTargets.push({ from: i, to: 'bear', die: d });
				}
			}
		}
	}

	function targetFromBar(player, die) {
		return player === 1 ? 24 - die : die - 1;
	}

	function isOpen(idx, player) {
		if (idx < 0 || idx > 23) return false;
		const p = points[idx];
		return !(p.color !== 0 && p.color !== player && p.count >= 2);
	}

	function canBearOffFrom(idx, die, player) {
		if (!allInHome(player)) return false;
		const dir = directionFor(player);
		const target = idx + dir * die;
		if (player === 1) {
			if (target < 0) return true;
			if (target === -1) return true;
			if (target >= 0 && target <= 5) return true;
			return false;
		} else {
			if (target > 23) return true;
			if (target === 24) return true;
			if (target >= 18 && target <= 23) return true;
			return false;
		}
	}

	function useDie(d) {
		const idx = dice.indexOf(d);
		if (idx !== -1) { dice.splice(idx, 1); return true; }
		return false;
	}

	function handleClick(evt) {
		if (gameOver || aiThinking) return;
		const rect = canvas.getBoundingClientRect();
		const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
		const y = (evt.clientY - rect.top) * (canvas.height / rect.height);
		const hit = hitTestPoint(x, y);
		if (!hit) return;
		if (hit.type === 'point') {
			if (selectedPoint === hit.index) { selectedPoint = null; draw(); return; }
			if (points[hit.index].color === currentPlayer && points[hit.index].count > 0) {
				selectedPoint = hit.index; drawTargets();
			} else if (selectedPoint !== null) {
				tryMove(selectedPoint, hit.index);
			}
		} else if (hit.type === 'bar' && bar[currentPlayer] > 0) {
			selectedPoint = 'bar'; drawTargets();
		}
	}

	function tryMove(from, to) {
		const moves = legalTargets.filter(m => m.from === from && (m.to === to || (m.to === 'bear' && to === 'bear')));
		if (moves.length === 0) return;
		const move = moves[0];
		if (!useDie(move.die)) return;
		applyMove(move);
		computeAllLegalMoves();
		draw();
		if (dice.length === 0 || legalTargets.length === 0) {
			if (legalTargets.length === 0) msgText.textContent = 'No more moves. Turn passes.';
			setTimeout(endTurn, 200);
		}
	}

	function applyMove(move) {
		const player = currentPlayer;
		if (move.from === 'bar') {
			bar[player]--;
		} else {
			points[move.from].count--;
			if (points[move.from].count === 0) points[move.from].color = 0;
		}
		if (move.to === 'bear') {
			borneOff[player]++;
			if (borneOff[player] >= 15) { gameOver = true; msgText.textContent = player === 1 ? 'Light wins!' : 'Dark wins!'; }
			selectedPoint = null;
			updateUI();
			return;
		}
		const target = points[move.to];
		if (target.color !== 0 && target.color !== player && target.count === 1) {
			// hit
			const opp = player === 1 ? 2 : 1;
			bar[opp]++;
			target.color = player;
			target.count = 1;
		} else {
			target.color = player;
			target.count += 1;
		}
		selectedPoint = null;
		updateUI();
	}

	function hitTestPoint(x, y) {
		const margin = Math.max(18, Math.min(canvas.width, canvas.height) * 0.06);
		const usableWidth = canvas.width - margin * 2;
		const usableHeight = canvas.height - margin * 2;
		const barW = usableWidth * 0.06;
		const ptW = (usableWidth - barW) / 12;
		const ptH = usableHeight / 2;
		const ox = margin;
		const oy = margin;
		// bar area
		if (x > ox + (usableWidth - barW)/2 && x < ox + (usableWidth + barW)/2) {
			return { type:'bar' };
		}
		// top row points 12-23
		if (y < oy + ptH) {
			const localX = x - ox;
			if (localX < 0 || localX > usableWidth) return null;
			const idx = Math.floor(localX / ptW);
			if (idx === 6) return null; // bar gap
			const pointIdx = 23 - (idx < 6 ? idx : idx -1);
			return { type:'point', index: pointIdx };
		}
		// bottom row points 0-11
		if (y > oy + ptH) {
			const localX = x - ox;
			if (localX < 0 || localX > usableWidth) return null;
			const idx = Math.floor(localX / ptW);
			if (idx === 6) return null;
			const pointIdx = idx < 6 ? idx : idx -1 + 6;
			return { type:'point', index: pointIdx };
		}
		return null;
	}

	function draw() {
		ctx.clearRect(0,0,canvas.width,canvas.height);
		const margin = Math.max(18, Math.min(canvas.width, canvas.height) * 0.06);
		const usableWidth = canvas.width - margin * 2;
		const usableHeight = canvas.height - margin * 2;
		const barW = usableWidth * 0.06;
		const ptW = (usableWidth - barW) / 12;
		const ptH = usableHeight / 2;
		const ox = margin;
		const oy = margin;

		// board background
		ctx.fillStyle = '#0b111c';
		ctx.fillRect(ox, oy, usableWidth, usableHeight);
		ctx.strokeStyle = 'rgba(255,255,255,0.08)';
		ctx.strokeRect(ox, oy, usableWidth, usableHeight);

		// bar
		ctx.fillStyle = '#111826';
		const barX = ox + (usableWidth - barW)/2;
		ctx.fillRect(barX, oy, barW, usableHeight);

		// triangles
		for (let row = 0; row < 2; row++) {
			for (let i = 0; i < 12; i++) {
				if (i === 6) continue;
				const isTop = row === 0;
				const x0 = ox + i * ptW + (i > 6 ? barW : 0);
				const y0 = isTop ? oy : oy + ptH;
				const dir = isTop ? 1 : -1;
				const color = (i % 2 === 0) ? 'var(--tri-a)' : 'var(--tri-b)';
				ctx.beginPath();
				ctx.moveTo(x0, y0);
				ctx.lineTo(x0 + ptW, y0);
				ctx.lineTo(x0 + ptW/2, y0 + dir * ptH * 0.92);
				ctx.closePath();
				ctx.fillStyle = color;
				ctx.fill();
				ctx.strokeStyle = 'var(--point-outline)';
				ctx.stroke();
			}
		}

		// checkers
		const stackGap = 4;
		const radius = Math.min(ptW, ptH) * 0.28;
		function drawStack(idx) {
			const p = points[idx];
			if (!p.count) return;
			const topRow = idx >= 12;
			const pos = topRow ? idx - 12 : idx;
			const col = pos < 6 ? pos : pos + 1; // skip bar gap
			const xCenter = ox + col * ptW + ptW/2;
			for (let n = 0; n < p.count; n++) {
				const yBase = topRow ? oy + radius + n * (radius*2 + stackGap) : oy + usableHeight - radius - n * (radius*2 + stackGap);
				ctx.beginPath();
				ctx.arc(xCenter, yBase, radius, 0, Math.PI * 2);
				ctx.fillStyle = p.color === 1 ? '#f5f7fb' : '#111';
				ctx.fill();
				ctx.strokeStyle = 'rgba(0,0,0,0.35)';
				ctx.lineWidth = 1.5;
				ctx.stroke();
			}
		}
		for (let i = 0; i < 24; i++) drawStack(i);

		// bar stacks
		function drawBarStack(player, count, topRow) {
			if (count === 0) return;
			for (let n = 0; n < count; n++) {
				const xCenter = barX + barW/2;
				const yBase = topRow ? oy + radius + n * (radius*2 + stackGap) : oy + usableHeight - radius - n * (radius*2 + stackGap);
				ctx.beginPath();
				ctx.arc(xCenter, yBase, radius, 0, Math.PI * 2);
				ctx.fillStyle = player === 1 ? '#f5f7fb' : '#111';
				ctx.fill();
				ctx.strokeStyle = 'rgba(0,0,0,0.35)';
				ctx.lineWidth = 1.5;
				ctx.stroke();
			}
		}
		drawBarStack(1, bar[1], true);
		drawBarStack(2, bar[2], false);

		// highlights
		drawTargets();

		// dice display
		drawDice();
	}

	function drawTargets() {
		if (selectedPoint === null) return;
		ctx.save();
		ctx.globalAlpha = 0.18;
		ctx.fillStyle = '#9ad7ff';
		const margin = Math.max(18, Math.min(canvas.width, canvas.height) * 0.06);
		const usableWidth = canvas.width - margin * 2;
		const usableHeight = canvas.height - margin * 2;
		const barW = usableWidth * 0.06;
		const ptW = (usableWidth - barW) / 12;
		const ptH = usableHeight / 2;
		const ox = margin;
		const oy = margin;
		const targets = legalTargets.filter(m => m.from === selectedPoint);
		targets.forEach(m => {
			if (m.to === 'bear') return;
			const idx = m.to;
			const topRow = idx >= 12;
			const pos = topRow ? idx - 12 : idx;
			const col = pos < 6 ? pos : pos + 1;
			const x0 = ox + col * ptW;
			const y0 = topRow ? oy : oy + ptH;
			ctx.fillRect(x0, y0, ptW, ptH);
		});
		ctx.restore();
	}

	function drawDice() {
		const size = 42;
		const padding = 10;
		const x0 = canvas.width - size * 2 - padding * 3;
		const y0 = padding + 6;
		dice.slice(0,2).forEach((d, idx) => {
			const x = x0 + idx * (size + padding);
			ctx.fillStyle = '#111824';
			ctx.strokeStyle = 'rgba(255,255,255,0.1)';
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.roundRect(x, y0, size, size, 8);
			ctx.fill();
			ctx.stroke();
			drawPips(x, y0, size, d);
		});
	}

	function drawPips(x, y, size, value) {
		ctx.fillStyle = '#f5f7fb';
		const c = size / 2;
		const o = size / 4;
		const positions = {
			1: [[c, c]],
			2: [[c - o, c - o], [c + o, c + o]],
			3: [[c - o, c - o], [c, c], [c + o, c + o]],
			4: [[c - o, c - o], [c + o, c - o], [c - o, c + o], [c + o, c + o]],
			5: [[c - o, c - o], [c + o, c - o], [c, c], [c - o, c + o], [c + o, c + o]],
			6: [[c - o, c - o], [c + o, c - o], [c - o, c], [c + o, c], [c - o, c + o], [c + o, c + o]]
		};
		positions[value].forEach(p => {
			ctx.beginPath();
			ctx.arc(x + p[0], y + p[1], 4.2, 0, Math.PI * 2);
			ctx.fill();
		});
	}

	function updateUI() {
		turnText.textContent = 'Turn: ' + (currentPlayer === 1 ? 'LIGHT' : 'DARK');
		diceText.textContent = 'Dice: ' + (dice.length ? dice.join(',') : '--');
		modeText.textContent = 'Mode: ' + (gameMode === 'two' ? '2P' : 'vs AI');
		aiText.textContent = 'AI: ' + (gameMode === 'two' ? '--' : aiLevel);
	}

	function resetGame() { initPoints(); draw(); }

	function setMode(mode) {
		gameMode = mode;
		if (mode === 'light') humanControl = {1:true, 2:false};
		else if (mode === 'dark') humanControl = {1:false, 2:true};
		else humanControl = {1:true, 2:true};
		updateUI();
	}
	function setDifficulty(level) { aiLevel = level; aiText.textContent = 'AI: ' + level; }

	function startGame() {
		startOverlay.classList.remove('show');
		resetGame();
		if (!isHumanTurn()) maybeAITurn();
	}

	function maybeAITurn() {
		if (gameOver || gameMode === 'two' || humanControl[currentPlayer]) return;
		aiThinking = true;
		setTimeout(() => {
			rollDiceAI();
			aiThinking = false;
		}, 350);
	}

	function rollDiceAI() {
		const d1 = 1 + Math.random() * 6 | 0;
		const d2 = 1 + Math.random() * 6 | 0;
		dice = (d1 === d2) ? [d1,d1,d1,d1] : [d1,d2];
		computeAllLegalMoves();
		if (legalTargets.length === 0) { dice = []; endTurn(); return; }
		// simple AI: pick random legal move sequence greedily
		const move = legalTargets[0];
		useDie(move.die);
		applyMove(move);
		computeAllLegalMoves();
		draw();
		if (dice.length === 0 || legalTargets.length === 0) { endTurn(); }
		else { setTimeout(rollDiceAI, 250); }
	}

	canvas.addEventListener('click', handleClick);
	btnRoll.addEventListener('click', rollDice);
	btnReset.addEventListener('click', resetGame);
	btnRules.addEventListener('click', () => rulesOverlay.classList.add('show'));
	document.getElementById('open-rules').addEventListener('click', () => rulesOverlay.classList.add('show'));
	document.getElementById('open-start').addEventListener('click', () => startOverlay.classList.add('show'));
	document.getElementById('open-reset').addEventListener('click', resetGame);
	closeRules.addEventListener('click', () => rulesOverlay.classList.remove('show'));
	startBtn.addEventListener('click', startGame);

	modeLight.addEventListener('click', () => { setMode('light'); setActive(modeLight, [modeDark, modeTwo]); });
	modeDark.addEventListener('click', () => { setMode('dark'); setActive(modeDark, [modeLight, modeTwo]); });
	modeTwo.addEventListener('click', () => { setMode('two'); setActive(modeTwo, [modeLight, modeDark]); });
	diffEasy.addEventListener('click', () => { setDifficulty('easy'); setActive(diffEasy, [diffMed, diffHard]); });
	diffMed.addEventListener('click', () => { setDifficulty('medium'); setActive(diffMed, [diffEasy, diffHard]); });
	diffHard.addEventListener('click', () => { setDifficulty('hard'); setActive(diffHard, [diffEasy, diffMed]); });

	function setActive(activeEl, others) {
		activeEl.classList.add('active');
		others.forEach(el => el.classList.remove('active'));
	}

	// initial
	initPoints();
	draw();
	</script>
</body>
</html>
