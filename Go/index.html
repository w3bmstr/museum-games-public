<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Go</title>
<style>
  :root {
    --bg: #0c0f16;
    --panel: #141a26;
    --panel-2: #0f1623;
    --accent: #5aa9e6;
    --accent-2: #c4a04a;
    --text: #f5f7fb;
    --muted: #9aa7bd;
    --board-dark: #0b101a;
    --wood-1: #c89f64;
    --wood-2: #e2bf86;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    background: radial-gradient(circle at 20% 20%, #121828, #0c0f16 42%);
    font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
    color: var(--text);
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    overflow: hidden;
  }
  #app {
    width: 100%;
    height: 100vh;
    max-width: 1500px;
    background: var(--panel);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 20px 60px rgba(0,0,0,0.35);
    display: flex;
    flex-direction: column;
  }
  header {
    padding: 18px 22px 12px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    background: linear-gradient(90deg, rgba(90,169,230,0.15), transparent);
    border-bottom: 1px solid rgba(255,255,255,0.06);
  }
  header h1 { margin: 0; font-size: 20px; letter-spacing: 0.4px; }
  header .subtitle { margin: 0; color: var(--muted); font-size: 13px; }
  .row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
  button {
    border: none;
    border-radius: 8px;
    padding: 10px 12px;
    font-size: 14px;
    cursor: pointer;
    background: var(--accent);
    color: #0c0f16;
    transition: transform 0.1s ease, box-shadow 0.2s ease;
  }
  button.secondary { background: rgba(255,255,255,0.12); color: var(--text); }
  button.alt { background: var(--accent-2); color: #0c0f16; }
  button:disabled { opacity: 0.5; cursor: not-allowed; }
  button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 10px 22px rgba(0,0,0,0.25); }
  main {
    display: grid;
    grid-template-columns: minmax(0,1fr) 320px;
    gap: 0;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }
  #board-wrapper {
    position: relative;
    padding: 18px;
    background: #0d121d;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 0;
    overflow: hidden;
  }
  #canvas-stack { position: relative; width: 100%; height: 100%; }
  canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    display: block;
    border-radius: 10px;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05);
  }
  .layer-board { z-index: 0; pointer-events: none; }
  .layer-pieces { z-index: 1; pointer-events: none; }
  .layer-ui { z-index: 2; }
  #ui-panel {
    padding: 18px 18px 24px;
    border-left: 1px solid rgba(255,255,255,0.06);
    background: rgba(10,14,24,0.78);
    height: 100%;
    overflow-y: auto;
    min-height: 0;
  }
  .section { margin-bottom: 16px; padding: 12px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06); border-radius: 10px; }
  .section h3 { margin: 0 0 8px; font-size: 14px; letter-spacing: 0.6px; color: var(--muted); text-transform: uppercase; }
  .pill { padding: 9px 12px; border-radius: 999px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); font-size: 13px; display: inline-flex; align-items: center; gap: 6px; }
  .status-box { padding: 10px 12px; border-radius: 10px; background: rgba(90,169,230,0.1); border: 1px solid rgba(90,169,230,0.2); font-size: 14px; }
  select { width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.06); color: var(--text); }
  label { font-size: 13px; color: var(--muted); display: block; margin-top: 6px; }
  .stat-line { margin: 4px 0; color: var(--muted); font-size: 13px; }
  .move-line { display: flex; gap: 8px; padding: 4px 6px; border-radius: 6px; }
  .move-line:nth-child(odd) { background: rgba(255,255,255,0.06); }
  @media (max-width: 1080px) { main { grid-template-columns: 1fr; } #ui-panel { border-left: none; border-top: 1px solid rgba(255,255,255,0.06); } }
  @media (max-width: 720px) { #board-wrapper { padding: 10px; } header { flex-direction: column; align-items: flex-start; } }
  .overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(8,10,16,0.82); backdrop-filter: blur(4px); z-index: 20; }
  .dialog { background: var(--panel-2); border: 1px solid rgba(255,255,255,0.08); padding: 20px; border-radius: 12px; width: min(540px, 92%); box-shadow: 0 16px 50px rgba(0,0,0,0.35); }
  .dialog h2 { margin: 0 0 8px; }
  .dialog p { margin: 4px 0; color: var(--muted); line-height: 1.6; font-size: 14px; }
  .options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 12px 0; }
  .option-active { outline: 2px solid var(--accent); outline-offset: 1px; }
  #history-overlay .dialog { width: min(600px, 92%); }
  #start-overlay { display: flex; }
</style>
</head>
<body>
  <div id="app">
    <header>
      <div>
        <h1>Go</h1>
        <p class="subtitle">19×19 territory and capture</p>
      </div>
      <div class="row">
        <button class="secondary" id="open-start">Start</button>
        <button class="secondary" id="open-rules">Rules</button>
        <button class="secondary" id="open-reset">Reset</button>
      </div>
    </header>
    <main>
      <div id="board-wrapper">
        <div id="canvas-stack">
          <canvas id="board-layer" class="layer-board"></canvas>
          <canvas id="pieces-layer" class="layer-pieces"></canvas>
          <canvas id="ui-layer" class="layer-ui"></canvas>
        </div>
      </div>
      <div id="ui-panel">
        <div class="section">
          <h3>Turn</h3>
          <div id="turn-pill" class="pill">--</div>
        </div>
        <div class="section">
          <h3>Mode</h3>
          <div class="row" style="gap:12px;">
            <button id="mode-human" class="secondary">2 Players</button>
            <button id="mode-ai">Vs AI</button>
          </div>
          <label for="difficulty">AI Difficulty</label>
          <select id="difficulty">
            <option value="easy">Easy</option>
            <option value="medium" selected>Medium</option>
            <option value="hard">Hard</option>
          </select>
        </div>
        <div class="section">
          <h3>Actions</h3>
          <div class="row" style="gap:8px; flex-wrap:wrap;">
            <button id="action-start" class="secondary">New Game</button>
            <button id="action-reset" class="secondary">Reset</button>
            <button id="action-undo" class="secondary">Undo</button>
            <button id="action-pass" class="secondary">Pass</button>
            <button id="action-history" class="secondary">History</button>
          </div>
        </div>
        <div class="section">
          <h3>Status</h3>
          <div id="status-text" class="status-box">Ready</div>
          <p id="ai-text" class="stat-line">AI: --</p>
          <p id="cap-text" class="stat-line">Captures B:0 W:0</p>
          <p id="pass-text" class="stat-line">Passes: 0</p>
          <p id="lastmove-text" class="stat-line">Last: --</p>
        </div>
      </div>
    </main>
  </div>

  <div id="start-overlay" class="overlay">
    <div class="dialog">
      <h2>Start Game</h2>
      <p>Choose how to play, set difficulty, then start.</p>
      <div class="options">
        <button id="btn-1p">Player vs AI</button>
        <button id="btn-2p" class="secondary">2 Players</button>
      </div>
      <label for="start-difficulty">AI Difficulty</label>
      <div class="options" style="grid-template-columns: repeat(3, 1fr);">
        <button id="btn-easy" class="secondary">Easy</button>
        <button id="btn-med">Medium</button>
        <button id="btn-hard" class="secondary">Hard</button>
      </div>
      <div class="row" style="margin-top:12px; justify-content:flex-end;">
        <button id="btn-start-overlay" style="min-width:160px;" class="alt">Start</button>
      </div>
    </div>
  </div>

  <div id="rules-overlay" class="overlay" style="display:none;">
    <div class="dialog">
      <h2>Rules: Go</h2>
      <p><strong>Board:</strong> 19×19 grid. Black plays first.</p>
      <p><strong>Play:</strong> Place a stone on an empty intersection.</p>
      <p><strong>Capture:</strong> Groups with no liberties are removed.</p>
      <p><strong>Suicide:</strong> Not allowed.</p>
      <p><strong>Ko:</strong> Cannot repeat the previous board position.</p>
      <p><strong>End:</strong> Two consecutive passes end the game; score = stones + territory + captures (no komi here).</p>
      <p><strong>Controls:</strong> Click to place; U undo, R reset, P pass; arrows + Enter to place; V toggle AI; controller A place, B pass, X reset, Y undo, D-pad/LS move cursor.</p>
      <div class="row" style="justify-content:flex-end; margin-top:10px;">
        <button class="secondary" id="close-rules">Close</button>
      </div>
    </div>
  </div>

  <div id="history-overlay" class="overlay" style="display:none;">
    <div class="dialog">
      <h2>Move History</h2>
      <div id="history-list" style="max-height:320px; overflow-y:auto; margin:10px 0;"></div>
      <div class="row" style="justify-content:flex-end;">
        <button class="secondary" id="close-history">Close</button>
      </div>
    </div>
  </div>

<script>
(function() {
  const SIZE = 19;
  const BLACK = 1;
  const WHITE = 2;
  const STAR_POINTS = [3, 9, 15];
  const COL_LABELS = "ABCDEFGHJKLMNOPQRST";
  const dpr = window.devicePixelRatio || 1;

  const boardWrapper = document.getElementById("board-wrapper");
  const boardLayer = document.getElementById("board-layer");
  const piecesLayer = document.getElementById("pieces-layer");
  const uiLayer = document.getElementById("ui-layer");

  const turnPill = document.getElementById("turn-pill");
  const aiText = document.getElementById("ai-text");
  const statusText = document.getElementById("status-text");
  const capText = document.getElementById("cap-text");
  const passText = document.getElementById("pass-text");
  const lastMoveText = document.getElementById("lastmove-text");
  const historyList = document.getElementById("history-list");

  const startOverlay = document.getElementById("start-overlay");
  const rulesOverlay = document.getElementById("rules-overlay");
  const historyOverlay = document.getElementById("history-overlay");

  const btn1p = document.getElementById("btn-1p");
  const btn2p = document.getElementById("btn-2p");
  const btnEasy = document.getElementById("btn-easy");
  const btnMed = document.getElementById("btn-med");
  const btnHard = document.getElementById("btn-hard");
  const btnStartOverlay = document.getElementById("btn-start-overlay");

  const btnOpenStart = document.getElementById("open-start");
  const btnOpenRules = document.getElementById("open-rules");
  const btnOpenReset = document.getElementById("open-reset");

  const btnModeHuman = document.getElementById("mode-human");
  const btnModeAI = document.getElementById("mode-ai");
  const selectDifficulty = document.getElementById("difficulty");

  const btnActionStart = document.getElementById("action-start");
  const btnActionReset = document.getElementById("action-reset");
  const btnActionUndo = document.getElementById("action-undo");
  const btnActionPass = document.getElementById("action-pass");
  const btnActionHistory = document.getElementById("action-history");

  const btnCloseRules = document.getElementById("close-rules");
  const btnCloseHistory = document.getElementById("close-history");

  const layout = { width: 0, height: 0, boardSize: 0, cellSize: 0, offsetX: 0, offsetY: 0 };

  const state = {
    board: Array.from({ length: SIZE }, () => Array(SIZE).fill(0)),
    turn: BLACK,
    moveHistory: [],
    lastMove: null,
    lastBoardHash: "",
    captures: { [BLACK]: 0, [WHITE]: 0 },
    passes: 0,
    gameOver: false,
    winner: null,
    score: { black: 0, white: 0 },
    message: "",
    cursor: { x: Math.floor(SIZE / 2), y: Math.floor(SIZE / 2) },
    aiEnabled: true,
    aiColor: WHITE,
    thinking: false,
    aiLevel: "medium",
    menuActive: true
  };

  let lastPadMove = 0;
  const padRepeatMs = 180;
  let prevButtons = [];
  let selectedMode = "ai";
  let selectedDiff = "medium";

  function hashBoard(board) { return board.map(row => row.join("")).join("|"); }

  function neighbors(x, y) {
    return [ [x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1] ].filter(([nx, ny]) => nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE);
  }

  function resetBoard() {
    for (let y = 0; y < SIZE; y++) for (let x = 0; x < SIZE; x++) state.board[y][x] = 0;
    state.turn = BLACK;
    state.moveHistory = [];
    state.lastMove = null;
    state.lastBoardHash = hashBoard(state.board);
    state.captures = { [BLACK]: 0, [WHITE]: 0 };
    state.passes = 0;
    state.gameOver = false;
    state.winner = null;
    state.score = { black: 0, white: 0 };
    state.message = "";
    updateHud();
  }

  function resize() {
    const rect = boardWrapper.getBoundingClientRect();
    layout.width = rect.width;
    layout.height = rect.height;
    [boardLayer, piecesLayer, uiLayer].forEach(canvas => {
      canvas.width = layout.width * dpr;
      canvas.height = layout.height * dpr;
      canvas.style.width = `${layout.width}px`;
      canvas.style.height = `${layout.height}px`;
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    });
    const maxBoardSize = Math.min(layout.width, layout.height) * 0.94;
    layout.boardSize = Math.max(360, maxBoardSize);
    layout.cellSize = layout.boardSize / (SIZE - 1);
    layout.offsetX = (layout.width - layout.boardSize) / 2;
    layout.offsetY = (layout.height - layout.boardSize) / 2;
  }

  function drawBoard(ctx) {
    ctx.clearRect(0, 0, layout.width, layout.height);
    ctx.fillStyle = "#0d121d";
    ctx.fillRect(0, 0, layout.width, layout.height);
    const grad = ctx.createLinearGradient(layout.offsetX, layout.offsetY, layout.offsetX + layout.boardSize, layout.offsetY + layout.boardSize);
    grad.addColorStop(0, "#b28a5a");
    grad.addColorStop(1, "#d9b37c");
    ctx.fillStyle = grad;
    ctx.fillRect(layout.offsetX, layout.offsetY, layout.boardSize, layout.boardSize);
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 1.5;
    for (let i = 0; i < SIZE; i++) {
      const x = layout.offsetX + i * layout.cellSize;
      ctx.beginPath();
      ctx.moveTo(x, layout.offsetY);
      ctx.lineTo(x, layout.offsetY + layout.boardSize);
      ctx.stroke();
      const y = layout.offsetY + i * layout.cellSize;
      ctx.beginPath();
      ctx.moveTo(layout.offsetX, y);
      ctx.lineTo(layout.offsetX + layout.boardSize, y);
      ctx.stroke();
    }
    ctx.fillStyle = "#000";
    for (const ry of STAR_POINTS) for (const rx of STAR_POINTS) {
      const sx = layout.offsetX + rx * layout.cellSize;
      const sy = layout.offsetY + ry * layout.cellSize;
      ctx.beginPath();
      ctx.arc(sx, sy, layout.cellSize * 0.12, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawPieces(ctx) {
    ctx.clearRect(0, 0, layout.width, layout.height);
    for (let y = 0; y < SIZE; y++) {
      for (let x = 0; x < SIZE; x++) {
        const v = state.board[y][x];
        if (!v) continue;
        const cx = layout.offsetX + x * layout.cellSize;
        const cy = layout.offsetY + y * layout.cellSize;
        const r = layout.cellSize * 0.45;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        const grad = ctx.createRadialGradient(cx - r * 0.3, cy - r * 0.3, r * 0.1, cx, cy, r);
        if (v === BLACK) { grad.addColorStop(0, "#555"); grad.addColorStop(1, "#000"); }
        else { grad.addColorStop(0, "#fff"); grad.addColorStop(1, "#ccc"); }
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.4)";
        ctx.lineWidth = 1;
        ctx.stroke();
        if (state.lastMove && state.lastMove.x === x && state.lastMove.y === y) {
          ctx.fillStyle = v === BLACK ? "#fff" : "#000";
          ctx.beginPath();
          ctx.arc(cx, cy, r * 0.25, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }

  function drawUI(ctx) {
    ctx.clearRect(0, 0, layout.width, layout.height);
    if (state.gameOver) {
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(14, 14, 340, 64);
      ctx.fillStyle = "#fff";
      ctx.font = "16px system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
      ctx.fillText(`Winner: ${state.winner}`, 24, 44);
      ctx.fillText(state.message, 24, 68);
    }
    const { x, y } = state.cursor;
    const cx = layout.offsetX + x * layout.cellSize;
    const cy = layout.offsetY + y * layout.cellSize;
    const r = layout.cellSize * 0.5;
    ctx.strokeStyle = "#5aa9e6";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.stroke();
  }

  function render() {
    drawBoard(boardLayer.getContext("2d"));
    drawPieces(piecesLayer.getContext("2d"));
    drawUI(uiLayer.getContext("2d"));
  }

  function coord(x, y) { return `${COL_LABELS[x]}${SIZE - y}`; }

  function updateHud() {
    turnPill.textContent = `Turn: ${state.turn === BLACK ? "Black" : "White"}`;
    aiText.textContent = state.aiEnabled ? `AI: ${state.aiLevel.toUpperCase()} (${state.aiColor === BLACK ? "Black" : "White"})` : "AI: Off";
    statusText.textContent = state.message || "Ready";
    capText.textContent = `Captures B:${state.captures[BLACK]} W:${state.captures[WHITE]}`;
    passText.textContent = `Passes: ${state.passes}`;
    if (state.lastMove) lastMoveText.textContent = `Last: ${coord(state.lastMove.x, state.lastMove.y)} (${state.lastMove.player === BLACK ? "B" : "W"})`;
    else lastMoveText.textContent = "Last: --";
    renderHistory();
  }

  function renderHistory() {
    historyList.innerHTML = state.moveHistory.map((mv, i) => {
      if (mv.pass) return `<div class="move-line">${i + 1}. ${mv.player === BLACK ? "B" : "W"} pass</div>`;
      const cap = mv.captured ? ` x${mv.captured}` : "";
      return `<div class="move-line">${i + 1}. ${mv.player === BLACK ? "B" : "W"} ${coord(mv.x, mv.y)}${cap}</div>`;
    }).join("");
  }

  function toggleRules(force) { const show = force !== undefined ? force : rulesOverlay.style.display === "none"; rulesOverlay.style.display = show ? "flex" : "none"; }
  function toggleHistory(force) { const show = force !== undefined ? force : historyOverlay.style.display === "none"; historyOverlay.style.display = show ? "flex" : "none"; }
  function showStartOverlay() { startOverlay.style.display = "flex"; state.menuActive = true; }
  function hideStartOverlay() { startOverlay.style.display = "none"; state.menuActive = false; }

  function collectGroup(x, y, board) {
    const color = board[y][x];
    const seen = new Set();
    const liberties = new Set();
    const stones = [];
    const stack = [[x, y]];
    seen.add(`${x},${y}`);
    while (stack.length) {
      const [cx, cy] = stack.pop();
      stones.push([cx, cy]);
      for (const [nx, ny] of neighbors(cx, cy)) {
        const v = board[ny][nx];
        if (v === 0) liberties.add(`${nx},${ny}`);
        else if (v === color) {
          const key = `${nx},${ny}`;
          if (!seen.has(key)) { seen.add(key); stack.push([nx, ny]); }
        }
      }
    }
    return { stones, liberties };
  }

  function placeStoneWithRules(x, y) {
    const player = state.turn;
    state.board[y][x] = player;
    let totalCaptured = 0;
    for (const [nx, ny] of neighbors(x, y)) {
      if (state.board[ny][nx] === 0 || state.board[ny][nx] === player) continue;
      const { stones, liberties } = collectGroup(nx, ny, state.board);
      if (liberties.size === 0) { for (const [sx, sy] of stones) state.board[sy][sx] = 0; totalCaptured += stones.length; }
    }
    const { liberties: myLiberties } = collectGroup(x, y, state.board);
    if (myLiberties.size === 0) { state.board[y][x] = 0; state.message = "Illegal: suicide"; updateHud(); return false; }
    const newHash = hashBoard(state.board);
    if (newHash === state.lastBoardHash) { state.board[y][x] = 0; state.message = "Illegal: ko"; updateHud(); return false; }
    state.captures[player] += totalCaptured;
    state.lastBoardHash = newHash;
    state.lastMove = { x, y, player };
    state.moveHistory.push({ x, y, player, captured: totalCaptured });
    state.passes = 0;
    state.message = totalCaptured ? `Captured ${totalCaptured}` : "";
    state.turn = player === BLACK ? WHITE : BLACK;
    updateHud();
    return true;
  }

  function replayHistory(moves) {
    for (const mv of moves) {
      if (mv.pass) { state.turn = mv.player === BLACK ? WHITE : BLACK; state.passes += 1; continue; }
      state.turn = mv.player;
      state.board[mv.y][mv.x] = mv.player;
      let totalCaptured = 0;
      for (const [nx, ny] of neighbors(mv.x, mv.y)) {
        if (state.board[ny][nx] === 0 || state.board[ny][nx] === mv.player) continue;
        const { stones, liberties } = collectGroup(nx, ny, state.board);
        if (liberties.size === 0) { for (const [sx, sy] of stones) state.board[sy][sx] = 0; totalCaptured += stones.length; }
      }
      state.captures[mv.player] += totalCaptured;
      state.lastMove = { x: mv.x, y: mv.y, player: mv.player };
      state.lastBoardHash = hashBoard(state.board);
    }
    state.turn = state.turn === BLACK ? WHITE : BLACK;
    state.message = "Undid";
  }

  function undoSafe() {
    if (state.moveHistory.length === 0) return;
    const moves = state.moveHistory.slice(0, -1);
    resetBoard();
    replayHistory(moves);
    state.moveHistory = moves;
    state.gameOver = false;
    state.winner = null;
    state.score = { black: 0, white: 0 };
    let trailingPasses = 0;
    for (let i = moves.length - 1; i >= 0; i--) { if (moves[i].pass) trailingPasses++; else break; }
    state.passes = trailingPasses;
    updateHud();
    maybeRunAI();
  }

  function moveCursor(dx, dy) {
    if (state.menuActive) return;
    state.cursor.x = Math.max(0, Math.min(SIZE - 1, state.cursor.x + dx));
    state.cursor.y = Math.max(0, Math.min(SIZE - 1, state.cursor.y + dy));
    state.message = "";
  }

  function placeCursor() {
    const { x, y } = state.cursor;
    if (state.gameOver) return;
    if (state.board[y][x] !== 0) return;
    const ok = placeStoneWithRules(x, y);
    render();
    if (ok) maybeRunAI();
  }

  function pass(fromAI = false) {
    if (state.gameOver || state.menuActive) return;
    state.moveHistory.push({ pass: true, player: state.turn });
    state.lastMove = null;
    state.turn = state.turn === BLACK ? WHITE : BLACK;
    state.passes += 1;
    state.message = "Pass";
    if (state.passes >= 2) { scoreGame(); }
    else { updateHud(); if (!fromAI) maybeRunAI(); }
  }

  function setDifficulty(level) { state.aiLevel = level; selectedDiff = level; applyDifficultyUI(); updateHud(); }

  function applyDifficultyUI() {
    [btnEasy, btnMed, btnHard].forEach(btn => btn.classList.remove("option-active"));
    [btnEasy, btnMed, btnHard].forEach(btn => btn.classList.remove("secondary"));
    if (state.aiLevel === "easy") btnEasy.classList.add("option-active");
    else if (state.aiLevel === "hard") btnHard.classList.add("option-active");
    else btnMed.classList.add("option-active");
    selectDifficulty.value = state.aiLevel;
  }

  function scoreGame() {
    const counts = { black: 0, white: 0 };
    for (let y = 0; y < SIZE; y++) for (let x = 0; x < SIZE; x++) {
      if (state.board[y][x] === BLACK) counts.black += 1; else if (state.board[y][x] === WHITE) counts.white += 1;
    }
    const visited = Array.from({ length: SIZE }, () => Array(SIZE).fill(false));
    for (let y = 0; y < SIZE; y++) {
      for (let x = 0; x < SIZE; x++) {
        if (visited[y][x] || state.board[y][x] !== 0) continue;
        const region = [];
        const queue = [[x, y]];
        visited[y][x] = true;
        const bordering = new Set();
        while (queue.length) {
          const [cx, cy] = queue.pop();
          region.push([cx, cy]);
          for (const [nx, ny] of neighbors(cx, cy)) {
            const v = state.board[ny][nx];
            if (v === 0 && !visited[ny][nx]) { visited[ny][nx] = true; queue.push([nx, ny]); }
            else if (v === BLACK) bordering.add(BLACK);
            else if (v === WHITE) bordering.add(WHITE);
          }
        }
        if (bordering.size === 1) { const owner = bordering.has(BLACK) ? "black" : "white"; counts[owner] += region.length; }
      }
    }
    state.score = counts;
    const blackScore = counts.black + state.captures[BLACK];
    const whiteScore = counts.white + state.captures[WHITE];
    state.winner = blackScore === whiteScore ? "Draw" : (blackScore > whiteScore ? "Black" : "White");
    state.message = `Final B:${blackScore} W:${whiteScore}`;
    state.gameOver = true;
    updateHud();
  }

  function cloneBoard(board) { return board.map(row => row.slice()); }

  function simulateMove(x, y, player, prevHash) {
    if (state.board[y][x] !== 0) return { legal: false };
    const temp = cloneBoard(state.board);
    temp[y][x] = player;
    let captured = 0;
    for (const [nx, ny] of neighbors(x, y)) {
      if (temp[ny][nx] === 0 || temp[ny][nx] === player) continue;
      const { stones, liberties } = collectGroup(nx, ny, temp);
      if (liberties.size === 0) { for (const [sx, sy] of stones) temp[sy][sx] = 0; captured += stones.length; }
    }
    const { liberties: myLibs } = collectGroup(x, y, temp);
    if (myLibs.size === 0) return { legal: false };
    const hash = hashBoard(temp);
    if (hash === prevHash) return { legal: false };
    return { legal: true, captured, hash };
  }

  function listLegalMoves(player) {
    const moves = [];
    const prevHash = state.lastBoardHash;
    for (let y = 0; y < SIZE; y++) for (let x = 0; x < SIZE; x++) {
      if (state.board[y][x] !== 0) continue;
      const sim = simulateMove(x, y, player, prevHash);
      if (sim.legal) moves.push({ x, y, captured: sim.captured });
    }
    return moves;
  }

  function aiChooseMove() {
    const moves = listLegalMoves(state.aiColor);
    if (!moves.length) return null;
    if (state.aiLevel === "easy") return moves[Math.floor(Math.random() * moves.length)];
    const center = (SIZE - 1) / 2;
    let bestScore = -Infinity;
    const scored = [];
    for (const m of moves) {
      let score = m.captured;
      if (state.aiLevel === "hard") { const dist = Math.abs(m.x - center) + Math.abs(m.y - center); score = m.captured * 10 - dist * 0.25; }
      scored.push({ m, score });
      if (score > bestScore) bestScore = score;
    }
    const best = scored.filter(s => s.score >= bestScore - 0.001).map(s => s.m);
    return best[Math.floor(Math.random() * best.length)];
  }

  function maybeRunAI() {
    if (!state.aiEnabled || state.gameOver || state.menuActive || state.turn !== state.aiColor || state.thinking) return;
    state.thinking = true;
    setTimeout(() => {
      const move = aiChooseMove();
      const prevFlag = state.aiEnabled;
      state.aiEnabled = false;
      if (move) placeStoneWithRules(move.x, move.y); else pass(true);
      state.aiEnabled = prevFlag;
      state.thinking = false;
      render();
      updateHud();
    }, 120);
  }

  function handlePointer(event) {
    if (state.menuActive) return;
    if (event.button !== 0) return;
    const rect = boardLayer.getBoundingClientRect();
    const mx = event.clientX - rect.left;
    const my = event.clientY - rect.top;
    const xLocal = mx - layout.offsetX;
    const yLocal = my - layout.offsetY;
    if (xLocal < -layout.cellSize / 2 || xLocal > layout.boardSize + layout.cellSize / 2 || yLocal < -layout.cellSize / 2 || yLocal > layout.boardSize + layout.cellSize / 2) return;
    const gx = Math.round(xLocal / layout.cellSize);
    const gy = Math.round(yLocal / layout.cellSize);
    if (gx < 0 || gx >= SIZE || gy < 0 || gy >= SIZE) return;
    if (state.gameOver) return;
    if (state.board[gy][gx] !== 0) return;
    const ok = placeStoneWithRules(gx, gy);
    render();
    if (ok) maybeRunAI();
  }

  function handleKey(event) {
    const key = event.key.toLowerCase();
    if (rulesOverlay.style.display === "flex") { if (["h","escape","enter"," "].includes(key)) toggleRules(false); return; }
    if (state.menuActive) {
      if (key === "1") { selectedMode = "ai"; applyModeUI(); }
      else if (key === "2") { selectedMode = "human"; applyModeUI(); }
      else if (key === "arrowup" || key === "w") { cycleDiff(-1); }
      else if (key === "arrowdown" || key === "s") { cycleDiff(1); }
      else if (key === "enter" || key === " ") { startSelected(); }
      return;
    }
    if (key === "r") { resetBoard(); render(); updateHud(); }
    else if (key === "u") { undoSafe(); render(); updateHud(); }
    else if (key === "p") { pass(); render(); updateHud(); }
    else if (key === "arrowup") { moveCursor(0, -1); render(); updateHud(); }
    else if (key === "arrowdown") { moveCursor(0, 1); render(); updateHud(); }
    else if (key === "arrowleft") { moveCursor(-1, 0); render(); updateHud(); }
    else if (key === "arrowright") { moveCursor(1, 0); render(); updateHud(); }
    else if (key === "enter" || key === " ") { placeCursor(); render(); }
    else if (key === "v") { state.aiEnabled = !state.aiEnabled; state.message = state.aiEnabled ? "AI enabled (White)" : "AI disabled"; updateHud(); render(); }
    else if (key === "h") { toggleRules(); }
  }

  function startAI() { state.aiEnabled = true; state.aiColor = WHITE; state.menuActive = false; hideStartOverlay(); resetBoard(); applyDifficultyUI(); render(); updateHud(); }
  function startHuman() { state.aiEnabled = false; state.menuActive = false; hideStartOverlay(); resetBoard(); applyDifficultyUI(); render(); updateHud(); }
  function startSelected() { state.aiLevel = selectedDiff; if (selectedMode === "ai") startAI(); else startHuman(); }

  function applyModeUI() {
    [btnModeHuman, btnModeAI, btn1p, btn2p].forEach(b => b.classList.remove("option-active"));
    if (selectedMode === "ai") { btnModeAI.classList.add("option-active"); btn1p.classList.add("option-active"); }
    else { btnModeHuman.classList.add("option-active"); btn2p.classList.add("option-active"); }
  }

  function cycleDiff(delta) {
    const diffs = ["easy", "medium", "hard"];
    const idx = diffs.indexOf(selectedDiff);
    selectedDiff = diffs[(idx + delta + diffs.length) % diffs.length];
    state.aiLevel = selectedDiff;
    applyDifficultyUI();
  }

  // Init
  resetBoard();
  resize();
  state.lastBoardHash = hashBoard(state.board);
  applyDifficultyUI();
  applyModeUI();
  render();
  updateHud();

  // Start menu
  btn1p.addEventListener("click", () => { selectedMode = "ai"; applyModeUI(); });
  btn2p.addEventListener("click", () => { selectedMode = "human"; applyModeUI(); });
  btnEasy.addEventListener("click", () => setDifficulty("easy"));
  btnMed.addEventListener("click", () => setDifficulty("medium"));
  btnHard.addEventListener("click", () => setDifficulty("hard"));
  btnStartOverlay.addEventListener("click", startSelected);

  // Header / panel buttons
  btnOpenStart.addEventListener("click", showStartOverlay);
  btnActionStart.addEventListener("click", showStartOverlay);
  btnOpenRules.addEventListener("click", () => toggleRules(true));
  btnOpenReset.addEventListener("click", () => { resetBoard(); render(); updateHud(); });
  btnActionReset.addEventListener("click", () => { resetBoard(); render(); updateHud(); });
  btnActionUndo.addEventListener("click", () => { undoSafe(); render(); updateHud(); });
  btnActionPass.addEventListener("click", () => { pass(); render(); updateHud(); });
  btnActionHistory.addEventListener("click", () => toggleHistory());
  btnCloseRules.addEventListener("click", () => toggleRules(false));
  btnCloseHistory.addEventListener("click", () => toggleHistory(false));
  btnModeHuman.addEventListener("click", () => { selectedMode = "human"; applyModeUI(); });
  btnModeAI.addEventListener("click", () => { selectedMode = "ai"; applyModeUI(); });
  selectDifficulty.addEventListener("change", e => setDifficulty(e.target.value));

  // Input
  uiLayer.addEventListener("mousedown", handlePointer);
  window.addEventListener("keydown", e => { handleKey(e); });
  window.addEventListener("resize", () => { resize(); render(); });

  // Gamepad support
  function pollGamepad() {
    const pads = navigator.getGamepads ? navigator.getGamepads() : [];
    const pad = pads && pads[0];
    if (pad) {
      const now = performance.now();
      const axes = pad.axes || [];
      const buttons = pad.buttons || [];
      const dx = Math.abs(axes[0] || 0) > 0.35 ? (axes[0] > 0 ? 1 : -1) : 0;
      const dy = Math.abs(axes[1] || 0) > 0.35 ? (axes[1] > 0 ? 1 : -1) : 0;
      const dpadX = (buttons[15]?.pressed ? 1 : 0) - (buttons[14]?.pressed ? 1 : 0);
      const dpadY = (buttons[13]?.pressed ? 1 : 0) - (buttons[12]?.pressed ? 1 : 0);
      const moveX = dpadX || dx;
      const moveY = dpadY || dy;
      if ((moveX || moveY) && now - lastPadMove > padRepeatMs) {
        moveCursor(moveX, moveY);
        render();
        updateHud();
        lastPadMove = now;
      }
      const pressed = idx => buttons[idx]?.pressed;
      const wasPressed = idx => prevButtons[idx];
      const edge = idx => pressed(idx) && !wasPressed(idx);
      if (edge(0)) { placeCursor(); render(); }
      if (edge(1)) { pass(); render(); updateHud(); }
      if (edge(2)) { resetBoard(); render(); updateHud(); }
      if (edge(3)) { undoSafe(); render(); updateHud(); }
      prevButtons = buttons.map(b => b?.pressed);
    }
    requestAnimationFrame(pollGamepad);
  }
  requestAnimationFrame(pollGamepad);
})();
</script>
</body>
</html>
