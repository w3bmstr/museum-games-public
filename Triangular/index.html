<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Triangular Chess</title>
	<style>
		html, body { margin:0; padding:0; width:100%; height:100%; background:#0a0c12; color:#e9edf6; font-family:"Segoe UI", system-ui, sans-serif; overflow:hidden; }
		#game-container { position:relative; width:100vw; height:100vh; overflow:hidden; background:radial-gradient(circle at 18% 24%, rgba(59,130,246,0.12), transparent 48%), radial-gradient(circle at 78% 72%, rgba(251,191,36,0.12), transparent 46%), #0a0c12; }
		canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }
		.layer-board { z-index:0; pointer-events:none; }
		.layer-pieces { z-index:1; pointer-events:none; }
		#hud { position:absolute; top:10px; left:10px; z-index:5; display:flex; flex-direction:column; gap:8px; }
		.panel { background:rgba(0,0,0,0.6); border:1px solid #1f2430; border-radius:10px; padding:10px 12px; min-width:260px; box-shadow:0 10px 28px rgba(0,0,0,0.35); }
		.panel h4 { margin:0 0 6px 0; font-size:13px; letter-spacing:0.5px; color:#ffc857; }
		.panel p { margin:4px 0; font-size:13px; }
		#controls { display:flex; gap:8px; flex-wrap:wrap; }
		#controls button { padding:8px 10px; border:none; border-radius:8px; background:#252a38; color:#e8e8ec; cursor:pointer; font-size:13px; }
		#controls button.primary { background:linear-gradient(135deg, #38bdf8, #6366f1); color:#0a0c12; }
		#controls button:disabled { opacity:0.55; cursor:not-allowed; }
		.history-panel { position:relative; max-height:260px; overflow-y:auto; font-family:monospace; font-size:12px; }
		.history-panel .move-line { margin:2px 0; }
		.history-close { position:absolute; top:6px; right:6px; padding:4px 8px; border:none; border-radius:6px; background:#252a38; color:#e8e8ec; cursor:pointer; font-size:11px; }
		#btn-history { display:none; }
		@media (max-width:820px) {
			#hud { position:fixed; top:auto; bottom:0; left:0; right:0; flex-direction:row; gap:6px; padding:6px; background:linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.45) 40%); backdrop-filter:blur(8px); }
			#hud .panel { min-width:0; flex:1; }
			#history { display:none; position:fixed; right:8px; bottom:78px; width:82vw; max-width:380px; max-height:55vh; z-index:12; background:rgba(0,0,0,0.85); border-radius:10px; }
			#history.show { display:block; }
			#btn-history { display:inline-block; }
		}
		#start-overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.72); z-index:10; }
		#start-card { background:#161820; border:1px solid #262c3a; border-radius:12px; padding:18px 22px; color:#f5f5f5; min-width:320px; box-shadow:0 12px 30px rgba(0,0,0,0.35); }
		#start-card h2 { margin:0 0 10px 0; font-size:20px; }
		#start-card p { margin:0 0 12px 0; font-size:14px; color:#cfd3dd; }
		#start-card .btn-row { display:flex; gap:10px; margin-top:10px; }
		#start-card button { flex:1; padding:10px 12px; border:none; border-radius:8px; background:linear-gradient(135deg, #38bdf8, #6366f1); color:#0a0c12; font-weight:700; cursor:pointer; }
		#start-card button.secondary { background:#3a3f4f; color:#f5f5f5; }
		#start-card button.active { outline:2px solid #fff; }
		#rules-overlay { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.7); z-index:11; }
		#rules-overlay.show { display:flex; }
		#rules-card { background:#161820; border:1px solid #262c3a; border-radius:12px; padding:18px 22px; color:#f5f5f5; max-width:880px; width:90%; box-shadow:0 12px 30px rgba(0,0,0,0.35); line-height:1.45; }
		#rules-card h3 { margin:0 0 8px 0; font-size:18px; }
		#rules-card ul { margin:8px 0 0 18px; padding:0; }
		#rules-card li { margin:4px 0; }
		#close-rules { margin-top:12px; padding:8px 12px; border:none; border-radius:8px; background:#3a3f4f; color:#fff; cursor:pointer; }
	</style>
</head>
<body>
<div id="game-container">
	<div id="hud">
		<div class="panel">
			<h4>Status</h4>
			<p id="turn-text">Turn: --</p>
			<p id="ai-text">AI: --</p>
			<p id="msg-text">Ready</p>
			<p id="lastmove-text">Last: --</p>
		</div>
		<div id="controls" class="panel">
			<button id="btn-start" class="primary">New Game</button>
			<button id="btn-reset">Reset</button>
			<button id="btn-undo">Undo</button>
			<button id="btn-history">History</button>
			<button id="btn-rules">Rules</button>
		</div>
		<div id="history" class="panel history-panel">
			<h4>Moves</h4>
			<button id="btn-history-close" class="history-close">Close</button>
			<div id="move-list"></div>
		</div>
	</div>

	<div id="start-overlay">
		<div id="start-card">
			<h2>Triangular Chess</h2>
			<p>96 triangular cells in a hex-like 8-rank layout (rows 9,11,13,15,15,13,11,9). Standard pieces plus unicorn and 3 extra pawns.</p>
			<div class="btn-row">
				<button id="btn-1p">1 Player (vs AI)</button>
				<button id="btn-2p" class="secondary">2 Players</button>
			</div>
			<p style="margin-top:12px; margin-bottom:6px;">AI Difficulty</p>
			<div class="btn-row">
				<button id="btn-easy" class="active">Easy</button>
				<button id="btn-med" class="secondary">Medium</button>
			</div>
			<p style="margin-top:12px; margin-bottom:6px;">Start</p>
			<div class="btn-row" style="margin-top:8px;">
				<button id="btn-start-overlay" class="primary">Start Game</button>
			</div>
		</div>
	</div>

	<div id="rules-overlay">
		<div id="rules-card">
			<h3>Rules (triangular)</h3>
			<ul>
				<li>Board: 8 ranks of lengths 9,11,13,15,15,13,11,9 (96 triangles). Triangles alternate orientation each cell.</li>
				<li>Pieces per side: K, Q, U (unicorn), 2R, 2B, 2N, 11P. Setup: back rank (row 8 White / row 1 Black) centered with B N U K Q B N R; pawns on the next rank (11 pawns).</li>
				<li>Movement: rook slides through edges (3 directions); bishop slides through vertices (3 directions); queen = rook or bishop; king one step as queen; knight = two bishop-steps then one rook-step (leaper); unicorn = two rook-steps then one rook-step orthogonal (leaper).</li>
				<li>Pawns: one step forward (toward enemy side); optional two-step from start if path clear; capture to the two forward-adjoining cells in the same rank band; if no straight-forward exists (at edge taper) the pawn advances using a capture direction. Promotion on far edge.</li>
				<li>No castling or en passant in this build (simplified). Stalemate counts as loss for the side with no legal moves.</li>
				<li>Controls: click to select/move; U undo; R reset; H rules.</li>
			</ul>
			<button id="close-rules">Close</button>
		</div>
	</div>
</div>

<script>
(() => {
	const ROW_LENGTHS = [9,11,13,15,15,13,11,9];
	const ROWS = ROW_LENGTHS.length;
	const MAX_LEN = Math.max(...ROW_LENGTHS);
	const WHITE = 1, BLACK = 2;
	const dpr = window.devicePixelRatio || 1;

	const GLYPH = {
		[WHITE]: { K:'♔', Q:'♕', R:'♖', B:'♗', N:'♘', P:'♙' },
		[BLACK]: { K:'♚', Q:'♛', R:'♜', B:'♝', N:'♞', P:'♟' }
	};

	const VAL = { K: 99999, Q: 900, R: 500, B: 330, N: 320, P: 100 };

	const container = document.getElementById('game-container');
	const startOverlay = document.getElementById('start-overlay');
	const btn1p = document.getElementById('btn-1p');
	const btn2p = document.getElementById('btn-2p');
	const btnEasy = document.getElementById('btn-easy');
	const btnMed = document.getElementById('btn-med');
	const btnStartOverlay = document.getElementById('btn-start-overlay');
	const btnRules = document.getElementById('btn-rules');
	const rulesOverlay = document.getElementById('rules-overlay');
	const closeRules = document.getElementById('close-rules');
	const hudBtnStart = document.getElementById('btn-start');
	const hudBtnReset = document.getElementById('btn-reset');
	const hudBtnUndo = document.getElementById('btn-undo');
	const hudBtnHistory = document.getElementById('btn-history');
	const btnHistoryClose = document.getElementById('btn-history-close');
	const historyPanel = document.getElementById('history');
	const turnText = document.getElementById('turn-text');
	const aiText = document.getElementById('ai-text');
	const msgText = document.getElementById('msg-text');
	const lastMoveText = document.getElementById('lastmove-text');
	const moveList = document.getElementById('move-list');

	const boardLayer = document.createElement('canvas');
	const piecesLayer = document.createElement('canvas');
	boardLayer.className = 'layer-board';
	piecesLayer.className = 'layer-pieces';
	container.appendChild(boardLayer);
	container.appendChild(piecesLayer);

	const layout = { width:0, height:0, scale:1, offsetX:0, offsetY:0, minX:0, minY:0, maxX:0, maxY:0, h:0 };

	const state = {
		cells: [],
		board: {},
		turn: WHITE,
		vsAI: true,
		aiColor: BLACK,
		aiDepth: 1,
		gameOver: false,
		history: [],
		lastMove: null,
		lastMoveHighlight: null,
		selected: null,
		moves: [],
		undoStack: []
	};

	const cellId = (r,c) => `${r}_${c}`;

	function buildGeometry(side=1) {
		const h = Math.sqrt(3)/2 * side;
		layout.h = h;
		const vertexMap = new Map();
		const vertexArr = [];
		const edgeMap = new Map();
		const cells = [];
		function vKey(x,y){ return `${x.toFixed(5)},${y.toFixed(5)}`; }
		const yCenterOffset = (ROWS-1)/2;
		const globalCenter = (MAX_LEN - 1)/2;
		for (let r=0;r<ROWS;r++) {
			const len = ROW_LENGTHS[r];
			const leftPad = (MAX_LEN - len)/2; // align rows on a shared global column grid
			for (let c=0;c<len;c++) {
				const gc = leftPad + c; // global column index inside the max-width row
				const isUp = ((r + gc) % 2 === 0); // odd-numbered rows (1-based) start up
				const cx = (gc - globalCenter) * (side/2);
				const cy = (r - yCenterOffset) * h;
				const verts = isUp
					? [[cx, cy - (2*h/3)], [cx - side/2, cy + h/3], [cx + side/2, cy + h/3]]
					: [[cx, cy + (2*h/3)], [cx - side/2, cy - h/3], [cx + side/2, cy - h/3]];
				const vIdx = verts.map(v => {
					const key = vKey(v[0], v[1]);
					if (!vertexMap.has(key)) { vertexMap.set(key, vertexArr.length); vertexArr.push(v); }
					return vertexMap.get(key);
				});
				const id = cellId(r,c);
				const cell = { id, r, c, len, isUp, cx, cy, vertsCoord: verts, verts: vIdx, edgeN: [], vertexN: [] };
				cells.push(cell);
				for (let i=0;i<3;i++) {
					const a=vIdx[i], b=vIdx[(i+1)%3];
					const ek = a<b ? `${a}|${b}` : `${b}|${a}`;
					if (!edgeMap.has(ek)) edgeMap.set(ek, []);
					edgeMap.get(ek).push(cell);
				}
			}
		}
		for (const list of edgeMap.values()) {
			if (list.length===2) {
				list[0].edgeN.push(list[1]);
				list[1].edgeN.push(list[0]);
			}
		}
		const vertexToCells = new Map();
		for (const cell of cells) {
			for (const v of cell.verts) {
				if (!vertexToCells.has(v)) vertexToCells.set(v, []);
				vertexToCells.get(v).push(cell);
			}
		}
		for (const cell of cells) {
			const set = new Set();
			for (const v of cell.verts) {
				for (const other of vertexToCells.get(v)) {
					if (other!==cell) set.add(other);
				}
			}
			cell.vertexN = Array.from(set);
		}
		state.cells = cells;
		const vx = vertexArr.map(v=>v[0]);
		const vy = vertexArr.map(v=>v[1]);
		layout.minX = Math.min(...vx); layout.maxX = Math.max(...vx);
		layout.minY = Math.min(...vy); layout.maxY = Math.max(...vy);
	}

	function dirKey(dx,dy){ const m=Math.hypot(dx,dy); if (m===0) return null; return `${(dx/m).toFixed(3)},${(dy/m).toFixed(3)}`; }

	function rookDirections(cell){
		const dirs = new Map();
		for (const n of cell.edgeN){ const k=dirKey(n.cx-cell.cx, n.cy-cell.cy); if (k) dirs.set(k, {dx:n.cx-cell.cx, dy:n.cy-cell.cy}); }
		return Array.from(dirs.values());
	}

	function bishopDirections(cell){
		const edgeKs = new Set(rookDirections(cell).map(d => dirKey(d.dx,d.dy)));
		const dirs = new Map();
		for (const n of cell.vertexN){
			const k=dirKey(n.cx-cell.cx, n.cy-cell.cy);
			if (k && !edgeKs.has(k)) dirs.set(k, {dx:n.cx-cell.cx, dy:n.cy-cell.cy});
		}
		return Array.from(dirs.values());
	}

	function slideFrom(cell, dirs, board, color){
		const moves=[];
		for (const d of dirs){
			let cur = cell; while (true){
				const nxt = stepDirection(cur, d, dirs===rookDirections(cell)?'edge':'vertex');
				if (!nxt) break;
				const occ = board[nxt.id];
				if (!occ){ moves.push(nxt); cur = nxt; continue; }
				if (occ.c !== color){ moves.push(nxt); }
				break;
			}
		}
		return moves;
	}

	function stepDirection(cell, dir, mode){
		const list = mode==='edge' ? cell.edgeN : cell.vertexN;
		const target = list.find(n => {
			const k1 = dirKey(n.cx-cell.cx, n.cy-cell.cy);
			const k2 = dirKey(dir.dx, dir.dy);
			return k1===k2;
		});
		return target || null;
	}

	function makePiece(c,t,p=false){ return { c, t, p }; }

	function setupBoard() {
		state.board = {};
		const len1 = ROW_LENGTHS[ROWS-1];
		const start1 = (MAX_LEN - len1)/2;
		const backW = ['_', 'B','N','U','K','Q','B','N','R'];
		for (let c=0;c<len1;c++) {
			const piece = backW[c] && backW[c] !== '_' ? makePiece(WHITE, backW[c]) : null;
			const cid = cellId(ROWS-1, c);
			if (piece) state.board[cid] = piece;
		}
		const len2 = ROW_LENGTHS[ROWS-2];
		for (let c=0;c<len2;c++) {
			state.board[cellId(ROWS-2,c)] = makePiece(WHITE,'P');
		}
		const lenTop = ROW_LENGTHS[0];
		const backB = ['_', 'b','n','u','k','q','b','n','r'];
		for (let c=0;c<lenTop;c++) {
			const cid = cellId(0,c);
			const piece = backB[c] && backB[c] !== '_' ? makePiece(BLACK, backB[c].toUpperCase()) : null;
			if (piece) state.board[cid] = piece;
		}
		const lenPTop = ROW_LENGTHS[1];
		for (let c=0;c<lenPTop;c++) {
			state.board[cellId(1,c)] = makePiece(BLACK,'P');
		}
		state.turn = WHITE;
		state.history = [];
		state.lastMove = null;
		state.lastMoveHighlight = null;
		state.selected = null;
		state.moves = [];
		state.undoStack = [];
		state.gameOver = false;
		msgText.textContent = 'Game on';
	}

	function resetGame(){ setupBoard(); updateHud(); resizeAndRedraw(); maybeAIMove(); }

	function cloneBoard(b=state.board){ const nb={}; for (const k in b){ nb[k]={...b[k]}; } return nb; }

	function applyMove(board, mv){
		const { from, to, promo } = mv;
		const piece = { ...board[from] };
		delete board[from];
		if (promo) piece.t = 'Q';
		board[to] = piece;
	}

	function kingPos(board, color){
		for (const k in board){ const p=board[k]; if (p.t==='K' && p.c===color) return k; }
		return null;
	}

	function isCheck(board, color){
		const kp = kingPos(board, color); if (!kp) return true;
		const enemy = color===WHITE?BLACK:WHITE;
		for (const cid in board){ const p=board[cid]; if (p.c!==enemy) continue; if (attacks(board, cid).some(m => m.to===kp)) return true; }
		return false;
	}

	function attacks(board, cid){
		const cell = state.cells.find(c => c.id===cid);
		const p = board[cid];
		if (!cell || !p) return [];
		const color = p.c;
		const moves=[];
		if (p.t==='R') {
			for (const n of slideFrom(cell, rookDirections(cell), board, color)) moves.push({from:cid,to:n.id});
		} else if (p.t==='B') {
			for (const n of slideFrom(cell, bishopDirections(cell), board, color)) moves.push({from:cid,to:n.id});
		} else if (p.t==='Q') {
			for (const n of slideFrom(cell, rookDirections(cell), board, color)) moves.push({from:cid,to:n.id});
			for (const n of slideFrom(cell, bishopDirections(cell), board, color)) moves.push({from:cid,to:n.id});
		} else if (p.t==='K') {
			const dirs = [...rookDirections(cell), ...bishopDirections(cell)];
			for (const d of dirs){ const n=stepDirection(cell,d, rookDirections(cell).some(r=>dirKey(r.dx,r.dy)===dirKey(d.dx,d.dy))?'edge':'vertex'); if (n){ const occ=board[n.id]; if (!occ || occ.c!==color) moves.push({from:cid,to:n.id}); } }
		} else if (p.t==='N') {
			moves.push(...leaperMoves(cell, board, color, 'knight'));
		} else if (p.t==='U') {
			moves.push(...leaperMoves(cell, board, color, 'unicorn'));
		} else if (p.t==='P') {
			moves.push(...pawnMoves(cell, board, color));
		}
		return moves;
	}

	function leaperMoves(cell, board, color, kind){
		const res=[];
		const rDirs = rookDirections(cell);
		const bDirs = bishopDirections(cell);
		const targetMap = new Map();
		function addTarget(cx,cy,id){ if(!id) return; const occ=board[id]; if (!occ || occ.c!==color) targetMap.set(id,true); }
		if (kind==='knight') {
			for (const bd of bDirs){
				const mid = stepDirection(cell, bd, 'vertex');
				if (!mid) continue;
				const mid2 = stepDirection(mid, bd, 'vertex');
				if (!mid2) continue;
				for (const rd of rDirs){
					if (dirKey(rd.dx,rd.dy)===dirKey(bd.dx,bd.dy)) continue;
					const end = stepDirection(mid2, rd, 'edge');
					if (end) addTarget(end.cx,end.cy,end.id);
				}
			}
		} else if (kind==='unicorn') {
			for (const rd1 of rDirs){
				const a = stepDirection(cell, rd1, 'edge'); if (!a) continue;
				const b = stepDirection(a, rd1, 'edge'); if (!b) continue;
				for (const rd2 of rDirs){
					if (dirKey(rd1.dx,rd1.dy)===dirKey(rd2.dx,rd2.dy)) continue;
					const end = stepDirection(b, rd2, 'edge'); if (end) addTarget(end.cx,end.cy,end.id);
				}
			}
		}
		for (const id of targetMap.keys()) res.push({from:cell.id,to:id});
		return res;
	}

	function pawnMoves(cell, board, color){
		const res=[];
		const dirSign = color===WHITE ? -1 : 1;
		const forwardCandidates = cell.edgeN.slice().sort((a,b)=> (a.cy-cell.cy)*dirSign - (b.cy-cell.cy)*dirSign);
		const forward = forwardCandidates.find(n => (n.cy - cell.cy)*dirSign < 0.01);
		const caps = cell.vertexN.filter(n => (n.cy - cell.cy)*dirSign < -0.01).slice(0,2);
		if (forward && !board[forward.id]) {
			res.push({from:cell.id,to:forward.id, promo:isPromotion(forward, color)});
			const startRow = color===WHITE ? ROWS-2 : 1;
			if (cell.r===startRow) {
				const step2 = forwardCandidates.find(n => n!==forward && dirKey(n.cx-cell.cx,n.cy-cell.cy)===dirKey(forward.cx-cell.cx, forward.cy-cell.cy));
				if (step2 && !board[step2.id]) res.push({from:cell.id,to:step2.id,promo:isPromotion(step2,color)});
			}
		}
		for (const n of caps){ const occ=board[n.id]; if (occ && occ.c!==color) res.push({from:cell.id,to:n.id,promo:isPromotion(n,color)}); }
		if (!forward && caps.length){ for (const n of caps){ if (!board[n.id]) res.push({from:cell.id,to:n.id,promo:isPromotion(n,color)}); } }
		return res;
	}

	function isPromotion(cell, color){
		return color===WHITE ? cell.r===0 : cell.r===ROWS-1;
	}

	function legalMoves(board, color){
		const res=[];
		for (const cid in board){ const p=board[cid]; if (p.c!==color) continue; for (const mv of attacks(board,cid)) {
			const nb=cloneBoard(board); applyMove(nb, mv); if (!isCheck(nb,color)) res.push(mv);
		}}
		return res;
	}

	function evaluate(board, pov){
		let s=0;
		for (const k in board){ const p=board[k]; s += (p.c===pov?1:-1)*VAL[p.t]; }
		return s + (Math.random()-0.5)*2;
	}

	function minimax(board, depth, alpha, beta, maximizing, pov){
		if (depth===0) return { score:evaluate(board,pov) };
		const color = maximizing ? pov : (pov===WHITE?BLACK:WHITE);
		const moves = legalMoves(board, color);
		if (!moves.length) {
			const inChk = isCheck(board, color);
			const score = inChk ? (maximizing ? -999999 : 999999) : (maximizing ? -800000 : 800000);
			return { score };
		}
		let bestMove=null;
		if (maximizing){
			let best=-Infinity;
			for (const mv of moves){ const nb=cloneBoard(board); applyMove(nb,mv); const res=minimax(nb, depth-1, alpha, beta, false, pov); if (res.score>best){ best=res.score; bestMove=mv; } alpha=Math.max(alpha,res.score); if (beta<=alpha) break; }
			return { score:best, move:bestMove };
		} else {
			let best=Infinity;
			for (const mv of moves){ const nb=cloneBoard(board); applyMove(nb,mv); const res=minimax(nb, depth-1, alpha, beta, true, pov); if (res.score<best){ best=res.score; bestMove=mv; } beta=Math.min(beta,res.score); if (beta<=alpha) break; }
			return { score:best, move:bestMove };
		}
	}

	function updateHud(){
		turnText.textContent = `Turn: ${state.turn===WHITE?'White':'Black'}`;
		aiText.textContent = state.vsAI ? `AI: ${state.aiColor===WHITE?'White':'Black'} (${state.aiDepth===1?'Easy':'Medium'})` : 'AI: Off';
		lastMoveText.textContent = state.lastMove ? `Last: ${state.lastMove}` : 'Last: --';
	}

	function pushHistory(statusText){
		moveList.innerHTML='';
		state.history.forEach((m,i)=>{
			const div=document.createElement('div'); div.className='move-line'; div.textContent=`${i+1}. ${m}`; moveList.appendChild(div);
		});
		msgText.textContent=statusText;
	}

	function handleClick(evt){
		if (state.gameOver || startOverlay.style.display !== 'none') return;
		const pos = pointerToCell(evt.clientX, evt.clientY);
		if (!pos) return;
		const cid = pos.id;
		const piece = state.board[cid];
		if (state.selected){
			const mv = state.moves.find(m => m.to===cid);
			if (mv) { makeMove(mv); return; }
			state.selected=null; state.moves=[]; redrawPieces(); return;
		}
		if (piece && piece.c===state.turn && (!state.vsAI || piece.c!==state.aiColor)) {
			state.selected = cid;
			state.moves = legalMoves(state.board, state.turn).filter(m => m.from===cid);
		} else {
			state.selected=null; state.moves=[];
		}
		redrawPieces();
	}

	function makeMove(mv){
		state.undoStack.push({ board:cloneBoard(state.board), turn:state.turn, history:[...state.history], lastMove:state.lastMove, lastMoveHighlight:state.lastMoveHighlight, gameOver:state.gameOver });
		applyMove(state.board, mv);
		state.lastMoveHighlight = mv;
		state.lastMove = `${mv.from}→${mv.to}${mv.promo?'+':''}`;
		state.history.push(state.lastMove);
		state.turn = state.turn===WHITE?BLACK:WHITE;
		state.selected=null; state.moves=[];
		const oppMoves = legalMoves(state.board, state.turn);
		if (!oppMoves.length){ const inChk=isCheck(state.board,state.turn); state.gameOver=true; msgText.textContent = inChk?'Checkmate':'No legal moves'; }
		else { msgText.textContent = isCheck(state.board,state.turn)?'Check':'Game on'; }
		updateHud(); redrawAll(); maybeAIMove();
	}

	function undo(){
		if (!state.undoStack.length) return;
		const snap=state.undoStack.pop();
		state.board=snap.board; state.turn=snap.turn; state.history=snap.history; state.lastMove=snap.lastMove; state.lastMoveHighlight=snap.lastMoveHighlight; state.gameOver=snap.gameOver; state.selected=null; state.moves=[]; msgText.textContent='Undo'; redrawAll(); updateHud();
	}

	function aiMove(){
		if (!state.vsAI || state.turn!==state.aiColor || state.gameOver) return;
		const res=minimax(state.board, state.aiDepth, -Infinity, Infinity, state.aiColor===WHITE, state.aiColor);
		if (res.move) makeMove(res.move);
	}

	function maybeAIMove(){ if (state.vsAI && state.turn===state.aiColor && !state.gameOver){ setTimeout(aiMove, 120); } }

	function pointerToCell(x,y){
		const rect = container.getBoundingClientRect();
		const bx = (x - rect.left - layout.offsetX) / layout.scale + layout.minX;
		const by = (y - rect.top - layout.offsetY) / layout.scale + layout.minY;
		for (const cell of state.cells){
			if (pointInTri(bx,by, cell.vertsCoord)) return cell;
		}
		return null;
	}

	function pointInTri(px,py, verts){
		const [a,b,c] = verts;
		const area = triArea(a,b,c);
		const a1 = triArea([px,py], b, c);
		const a2 = triArea(a, [px,py], c);
		const a3 = triArea(a, b, [px,py]);
		const sum = a1+a2+a3;
		return Math.abs(sum - area) < 1e-4;
	}

	function triArea([x1,y1],[x2,y2],[x3,y3]){ return Math.abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))/2); }

	function resize(){
		layout.width = container.clientWidth;
		layout.height = container.clientHeight;
		const bw = layout.maxX - layout.minX;
		const bh = layout.maxY - layout.minY;
		const margin = 0.05;
		const scaleX = layout.width * (1 - 2*margin) / bw;
		const scaleY = layout.height * (1 - 2*margin) / bh;
		layout.scale = Math.min(scaleX, scaleY);
		layout.offsetX = (layout.width - bw*layout.scale)/2;
		layout.offsetY = (layout.height - bh*layout.scale)/2;
		[boardLayer, piecesLayer].forEach(layer => {
			layer.width = layout.width*dpr; layer.height = layout.height*dpr; layer.style.width=layout.width+'px'; layer.style.height=layout.height+'px'; const ctx=layer.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0);
		});
	}

	function drawBoard(){
		const ctx = boardLayer.getContext('2d');
		ctx.clearRect(0,0,layout.width, layout.height);
		for (const cell of state.cells){
			const verts = cell.vertsCoord.map(([vx,vy]) => [ (vx - layout.minX)*layout.scale + layout.offsetX, (vy - layout.minY)*layout.scale + layout.offsetY ]);
			ctx.beginPath(); ctx.moveTo(verts[0][0], verts[0][1]); ctx.lineTo(verts[1][0], verts[1][1]); ctx.lineTo(verts[2][0], verts[2][1]); ctx.closePath();
			const light = (cell.r + cell.c)%2===0;
			ctx.fillStyle = light ? '#e7d3b2' : '#b58a65';
			ctx.fill();
			ctx.strokeStyle = 'rgba(0,0,0,0.3)';
			ctx.lineWidth = 1;
			ctx.stroke();
		}
		if (state.lastMoveHighlight){
			ctx.fillStyle='rgba(56,189,248,0.22)';
			for (const cid of [state.lastMoveHighlight.from, state.lastMoveHighlight.to]){
				const cell=state.cells.find(c=>c.id===cid); if(!cell) continue;
				const verts = cell.vertsCoord.map(([vx,vy]) => [ (vx - layout.minX)*layout.scale + layout.offsetX, (vy - layout.minY)*layout.scale + layout.offsetY ]);
				ctx.beginPath(); ctx.moveTo(verts[0][0], verts[0][1]); ctx.lineTo(verts[1][0], verts[1][1]); ctx.lineTo(verts[2][0], verts[2][1]); ctx.closePath(); ctx.fill();
			}
		}
	}

	function redrawPieces(){
		const ctx = piecesLayer.getContext('2d');
		ctx.clearRect(0,0,layout.width, layout.height);
		ctx.textAlign='center'; ctx.textBaseline='middle';
		ctx.font = `${layout.scale*0.6}px "Segoe UI Symbol"`;
		for (const cell of state.cells){
			const piece = state.board[cell.id]; if (!piece) continue;
			const cx = (cell.cx - layout.minX)*layout.scale + layout.offsetX;
			const cy = (cell.cy - layout.minY)*layout.scale + layout.offsetY;
			ctx.fillStyle = piece.c===WHITE ? '#ffffff' : '#0f131b';
			ctx.fillText(GLYPH[piece.c][piece.t], cx, cy + 1);
		}
		if (state.selected){
			const cell = state.cells.find(c=>c.id===state.selected);
			if (cell){
				const cx = (cell.cx - layout.minX)*layout.scale + layout.offsetX;
				const cy = (cell.cy - layout.minY)*layout.scale + layout.offsetY;
				const s=layout.scale, h=Math.sqrt(3)/2*s;
				const ctxS = ctx;
				ctxS.strokeStyle='rgba(99,102,241,0.9)'; ctxS.lineWidth=3;
				ctxS.beginPath();
				if (cell.isUp){ ctxS.moveTo(cx, cy - (2*h/3)); ctxS.lineTo(cx - s/2, cy + h/3); ctxS.lineTo(cx + s/2, cy + h/3); }
				else { ctxS.moveTo(cx, cy + (2*h/3)); ctxS.lineTo(cx - s/2, cy - h/3); ctxS.lineTo(cx + s/2, cy - h/3); }
				ctxS.closePath(); ctxS.stroke();
				ctxS.fillStyle='rgba(99,102,241,0.32)';
				for (const mv of state.moves){ const tcell=state.cells.find(c=>c.id===mv.to); if(!tcell) continue; ctxS.beginPath(); ctxS.arc((tcell.cx - layout.minX)*layout.scale + layout.offsetX, (tcell.cy - layout.minY)*layout.scale + layout.offsetY, layout.scale*0.18, 0, Math.PI*2); ctxS.fill(); }
			}
		}
	}

	function redrawAll(){ drawBoard(); redrawPieces(); pushHistory(msgText.textContent); }
	function resizeAndRedraw(){ resize(); redrawAll(); }

	function bindUI(){
		container.addEventListener('click', handleClick);
		window.addEventListener('resize', resizeAndRedraw);
		window.addEventListener('keyup', e=>{ if (e.key==='u' || e.key==='U') undo(); if (e.key==='r'||e.key==='R') resetGame(); if (e.key==='h'||e.key==='H') rulesOverlay.classList.add('show'); });
		btn1p.addEventListener('click', ()=>{ state.vsAI=true; state.aiColor=BLACK; toggleSelect(btn1p,btn2p); });
		btn2p.addEventListener('click', ()=>{ state.vsAI=false; toggleSelect(btn2p,btn1p); });
		btnEasy.addEventListener('click', ()=>{ state.aiDepth=1; setDiff(btnEasy); });
		btnMed.addEventListener('click', ()=>{ state.aiDepth=2; setDiff(btnMed); });
		btnStartOverlay.addEventListener('click', ()=>{ startOverlay.style.display='none'; resetGame(); });
		hudBtnStart.addEventListener('click', resetGame);
		hudBtnReset.addEventListener('click', resetGame);
		hudBtnUndo.addEventListener('click', undo);
		btnRules.addEventListener('click', ()=>rulesOverlay.classList.add('show'));
		closeRules.addEventListener('click', ()=>rulesOverlay.classList.remove('show'));
		hudBtnHistory.addEventListener('click', ()=>historyPanel.classList.toggle('show'));
		btnHistoryClose.addEventListener('click', ()=>historyPanel.classList.remove('show'));
	}

	function toggleSelect(on,off){ on.classList.remove('secondary'); off.classList.add('secondary'); }
	function setDiff(btn){ [btnEasy,btnMed].forEach(b=>b.classList.remove('active')); btn.classList.add('active'); }

	buildGeometry(1);
	resize();
	setupBoard();
	redrawAll();
	bindUI();
})();
</script>
</body>
</html>
