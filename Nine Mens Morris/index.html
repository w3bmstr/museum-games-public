<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Nine Men's Morris</title>
	<style>
		html, body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			background: #0c0d11;
			color: #e8e8ec;
			font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
			overflow: hidden;
		}
		#game-container { display: flex; flex-direction: column; width: 100vw; height: 100vh; background: radial-gradient(circle at 20% 20%, rgba(80,120,255,0.08), transparent 45%), radial-gradient(circle at 80% 70%, rgba(255,170,70,0.08), transparent 45%), #0c0d11; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }
		#stage { position: relative; flex: 1; min-height: 0; overflow: hidden; }
		canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
		.layer-board { z-index: 0; pointer-events: none; }
		.layer-pieces { z-index: 1; pointer-events: none; }
		.layer-ui { z-index: 2; }
		#title-bar {
			margin: 10px 10px 0 10px;
			z-index: 6;
			display: flex;
			flex-direction: column;
			gap: 2px;
			background: rgba(24,46,82,0.9);
			border: 1px solid #1d2f4f;
			border-radius: 12px;
			padding: 12px 14px;
			box-shadow: 0 10px 28px rgba(0,0,0,0.35);
			backdrop-filter: blur(6px);
			min-width: 240px;
			text-align: left;
		}
		#title-bar .title { margin: 0; font-size: 20px; letter-spacing: 0.5px; color: #e7f1ff; font-weight: 750; }
		#title-bar .subtitle { margin: 0; font-size: 13px; color: #bcd0ff; }
		#hud {
			position: absolute;
			top: 12px;
			left: 10px;
			z-index: 5;
			display: flex;
			flex-direction: column;
			gap: 8px;
		}
		.panel {
			background: rgba(0,0,0,0.55);
			border: 1px solid #1f2430;
			border-radius: 10px;
			padding: 10px 12px;
			min-width: 240px;
			box-shadow: 0 10px 28px rgba(0,0,0,0.35);
		}
		.panel h4 { margin: 0 0 6px 0; font-size: 13px; letter-spacing: 0.5px; color: #ffc857; }
		.panel p { margin: 4px 0; font-size: 13px; }
		#controls { display: flex; gap: 8px; flex-wrap: wrap; }
		#controls button { padding: 8px 10px; border: none; border-radius: 8px; background: #252a38; color: #e8e8ec; cursor: pointer; font-size: 13px; }
		#controls button.primary { background: linear-gradient(135deg, #58c6ff, #2f81ff); color: #fff; }
		#controls button:disabled { opacity: 0.5; cursor: not-allowed; }
		.history-panel { position: relative; max-height: 260px; overflow-y: auto; font-family: monospace; font-size: 12px; }
		.history-panel .move-line { margin: 2px 0; }
		.history-close { position: absolute; top: 6px; right: 6px; padding: 4px 8px; border: none; border-radius: 6px; background: #252a38; color: #e8e8ec; cursor: pointer; font-size: 11px; }
		#btn-history { display: none; }
		@media (max-width: 720px) {
			#stage { padding-bottom: calc(120px + env(safe-area-inset-bottom)); }
			canvas { bottom: calc(120px + env(safe-area-inset-bottom)); height: calc(100% - calc(120px + env(safe-area-inset-bottom))); }
			#hud { position: fixed; top: auto; bottom: 0; left: 0; right: 0; flex-direction: row; gap: 6px; padding: 6px; background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.45) 40%); backdrop-filter: blur(8px); padding-bottom: calc(6px + env(safe-area-inset-bottom)); }
			#hud .panel { min-width: 0; flex: 1; }
			#history { display: none; position: fixed; right: 8px; bottom: 78px; width: 82vw; max-width: 380px; max-height: 55vh; z-index: 12; background: rgba(0,0,0,0.85); border-radius: 10px; }
			#history.show { display: block; }
			#btn-history { display: inline-block; }
			#title-bar { top: 12px; width: calc(100% - 16px); left: 8px; right: 8px; transform: none; }
		}
		#start-overlay {
			position: absolute; inset: 0;
			display: flex; align-items: center; justify-content: center;
			background: rgba(0,0,0,0.72); z-index: 10;
		}
		#start-card {
			background: #161820;
			border: 1px solid #262c3a;
			border-radius: 12px;
			padding: 18px 22px;
			color: #f5f5f5;
			min-width: 280px;
			box-shadow: 0 12px 30px rgba(0,0,0,0.35);
		}
		#start-card h2 { margin: 0 0 10px 0; font-size: 20px; }
		#start-card p { margin: 0 0 12px 0; font-size: 14px; color: #cfd3dd; }
		#start-card .btn-row { display: flex; gap: 10px; margin-top: 10px; }
		#start-card button { flex: 1; padding: 10px 12px; border: none; border-radius: 8px; background: linear-gradient(135deg, #58c6ff, #2f81ff); color: #fff; font-weight: 700; cursor: pointer; }
		#start-card button.secondary { background: #3a3f4f; }
		#start-card button.active { outline: 2px solid #fff; }
		#rules-overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.7); z-index: 11; }
		#rules-overlay.show { display: flex; }
		#rules-card { background: #161820; border: 1px solid #262c3a; border-radius: 12px; padding: 18px 22px; color: #f5f5f5; max-width: 720px; width: 90%; box-shadow: 0 12px 30px rgba(0,0,0,0.35); line-height: 1.45; }
		#rules-card h3 { margin: 0 0 8px 0; font-size: 18px; }
		#rules-card ul { margin: 8px 0 0 18px; padding: 0; }
		#rules-card li { margin: 4px 0; }
		#close-rules { margin-top: 12px; padding: 8px 12px; border: none; border-radius: 8px; background: #3a3f4f; color: #fff; cursor: pointer; }
	</style>
</head>
<body>
<div id="game-container">
	<div id="title-bar">
		<p class="title">Nine Men's Morris</p>
		<p class="subtitle">Place nine stones, form mills, capture to win.</p>
	</div>
	<div id="stage">
		<div id="hud">
			<div class="panel">
				<h4>Status</h4>
				<p id="turn-text">Turn: --</p>
				<p id="ai-text">AI: --</p>
				<p id="msg-text">Ready</p>
				<p id="moves-text">Moves: --</p>
				<p id="reserve-text">To place W:9 B:9</p>
				<p id="piece-text">On board W:0 B:0</p>
				<p id="lastmove-text">Last: --</p>
			</div>
			<div id="controls" class="panel">
				<button id="btn-start" class="primary">New Game</button>
				<button id="btn-reset">Reset</button>
				<button id="btn-undo">Undo</button>
				<button id="btn-history">History</button>
				<button id="btn-rules">Rules</button>
			</div>
			<div id="history" class="panel history-panel">
				<h4>Moves</h4>
				<button id="btn-history-close" class="history-close">Close</button>
				<div id="move-list"></div>
			</div>
		</div>

		<div id="start-overlay">
			<div id="start-card">
				<h2>Nine Men's Morris</h2>
				<p>Place nine pieces, make mills to capture. Reduce the opponent to 2 pieces or block them.</p>
				<div class="btn-row">
					<button id="btn-1p">1 Player (vs AI)</button>
					<button id="btn-2p" class="secondary">2 Players</button>
				</div>
				<p style="margin-top:12px; margin-bottom:6px;">AI Difficulty</p>
				<div class="btn-row">
					<button id="btn-easy" class="secondary">Easy</button>
					<button id="btn-med" class="active">Medium</button>
					<button id="btn-hard" class="secondary">Hard</button>
				</div>
				<p style="margin-top:12px; margin-bottom:6px;">Start</p>
				<div class="btn-row" style="margin-top:8px;">
					<button id="btn-start-overlay" class="primary">Start Game</button>
				</div>
			</div>
		</div>

		<div id="rules-overlay">
			<div id="rules-card">
				<h3>Rules</h3>
				<ul>
					<li>Phase 1: players place pieces on empty points. Form a mill (three in a row) to remove an enemy piece (prefer one not in a mill).</li>
					<li>Phase 2: when all pieces are placed, move along connected lines. If you have 3 pieces, you may fly to any empty point.</li>
					<li>Win if the opponent has 2 or fewer pieces, or if they cannot move.</li>
					<li>Controls: click a point to place or select; click a highlighted destination to move; click an enemy piece when prompted to capture. Keyboard: arrows move cursor, Enter/Space select/move, U undo, R reset, H rules.</li>
				</ul>
				<button id="close-rules">Close</button>
			</div>
		</div>
	</div>
</div>

<script>
(function() {
	const LIGHT = 1;
	const DARK = 2;
	const dpr = window.devicePixelRatio || 1;

	// Board points on a 7x7 grid (0..6)
	const POINTS = [
		{ x: 0, y: 0 }, { x: 3, y: 0 }, { x: 6, y: 0 },
		{ x: 6, y: 3 }, { x: 6, y: 6 }, { x: 3, y: 6 },
		{ x: 0, y: 6 }, { x: 0, y: 3 },
		{ x: 1, y: 1 }, { x: 3, y: 1 }, { x: 5, y: 1 },
		{ x: 5, y: 3 }, { x: 5, y: 5 }, { x: 3, y: 5 },
		{ x: 1, y: 5 }, { x: 1, y: 3 },
		{ x: 2, y: 2 }, { x: 3, y: 2 }, { x: 4, y: 2 },
		{ x: 4, y: 3 }, { x: 4, y: 4 }, { x: 3, y: 4 },
		{ x: 2, y: 4 }, { x: 2, y: 3 }
	];

	const ADJ = {
		0:[1,7],1:[0,2,9],2:[1,3],3:[2,4,11],4:[3,5],5:[4,6,13],6:[5,7],7:[6,0,15],
		8:[9,15],9:[8,10,1,17],10:[9,11],11:[10,12,3,19],12:[11,13],13:[12,14,5,21],14:[13,15],15:[14,8,7,23],
		16:[17,23],17:[16,18,9],18:[17,19],19:[18,20,11],20:[19,21],21:[20,22,13],22:[21,23],23:[22,16,15]
	};

	const MILLS = [
		[0,1,2],[2,3,4],[4,5,6],[6,7,0],
		[8,9,10],[10,11,12],[12,13,14],[14,15,8],
		[16,17,18],[18,19,20],[20,21,22],[22,23,16],
		[0,8,16],[1,9,17],[2,10,18],[3,11,19],
		[4,12,20],[5,13,21],[6,14,22],[7,15,23]
	];

	const container = document.getElementById("game-container");
	const stage = document.getElementById("stage");
	const startOverlay = document.getElementById("start-overlay");
	const btn1p = document.getElementById("btn-1p");
	const btn2p = document.getElementById("btn-2p");
	const btnEasy = document.getElementById("btn-easy");
	const btnMed = document.getElementById("btn-med");
	const btnHard = document.getElementById("btn-hard");
	const btnStartOverlay = document.getElementById("btn-start-overlay");
	const btnRules = document.getElementById("btn-rules");
	const rulesOverlay = document.getElementById("rules-overlay");
	const closeRules = document.getElementById("close-rules");
	const hudBtnStart = document.getElementById("btn-start");
	const hudBtnReset = document.getElementById("btn-reset");
	const hudBtnUndo = document.getElementById("btn-undo");
	const hudBtnHistory = document.getElementById("btn-history");
	const btnHistoryClose = document.getElementById("btn-history-close");
	const historyPanel = document.getElementById("history");
	const turnText = document.getElementById("turn-text");
	const aiText = document.getElementById("ai-text");
	const msgText = document.getElementById("msg-text");
	const movesText = document.getElementById("moves-text");
	const reserveText = document.getElementById("reserve-text");
	const pieceText = document.getElementById("piece-text");
	const lastMoveText = document.getElementById("lastmove-text");
	const moveList = document.getElementById("move-list");

	const boardLayer = document.createElement("canvas");
	const piecesLayer = document.createElement("canvas");
	const uiLayer = document.createElement("canvas");
	boardLayer.className = "layer-board";
	piecesLayer.className = "layer-pieces";
	uiLayer.className = "layer-ui";
	stage.appendChild(boardLayer);
	stage.appendChild(piecesLayer);
	stage.appendChild(uiLayer);

	const layout = { width: 0, height: 0, size: 0, step: 0, offsetX: 0, offsetY: 0 };

	const state = {
		board: Array(24).fill(0),
		turn: LIGHT,
		toPlace: { [LIGHT]: 9, [DARK]: 9 },
		moveHistory: [],
		lastMove: null,
		pendingCapture: false,
		captureTarget: null,
		selected: null,
		legal: [],
		gameOver: false,
		winner: null,
		message: "",
		aiEnabled: true,
		aiColor: DARK,
		aiLevel: "medium",
		thinking: false,
		menuActive: true
	};

	let selectedMode = "1p";
	let selectedDiff = "medium";

	function resetGame() {
		state.board = Array(24).fill(0);
		state.turn = LIGHT;
		state.toPlace = { [LIGHT]: 9, [DARK]: 9 };
		state.moveHistory = [];
		state.lastMove = null;
		state.pendingCapture = false;
		state.captureTarget = null;
		state.selected = null;
		state.legal = [];
		state.gameOver = false;
		state.winner = null;
		state.message = "";
		state.thinking = false;
		updateHud();
	}

	function resize() {
		const rect = stage.getBoundingClientRect();
		layout.width = rect.width;
		layout.height = rect.height;
		[boardLayer, piecesLayer, uiLayer].forEach(c => {
			c.width = layout.width * dpr;
			c.height = layout.height * dpr;
			c.style.width = `${layout.width}px`;
			c.style.height = `${layout.height}px`;
			const ctx = c.getContext("2d");
			ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
		});
		layout.size = Math.min(layout.width, layout.height) * 0.9;
		layout.step = layout.size / 6;
		layout.offsetX = (layout.width - layout.size) / 2;
		layout.offsetY = (layout.height - layout.size) / 2;
		render();
	}

	function endGame(winnerColor, message) {
		state.gameOver = true;
		state.winner = colorName(winnerColor);
		state.message = message || `${state.winner} wins`;
		state.thinking = false;
		setBoardInput(false);
		updateHud();
		render();
	}

	function toScreen(pt) {
		return {
			x: layout.offsetX + pt.x * layout.step,
			y: layout.offsetY + pt.y * layout.step
		};
	}

	function drawBoard(ctx) {
		ctx.clearRect(0, 0, layout.width, layout.height);
		ctx.fillStyle = "#0c0d11";
		ctx.fillRect(0, 0, layout.width, layout.height);

		ctx.strokeStyle = "#2f3444";
		ctx.lineWidth = 6;
		ctx.lineCap = "round";

		const edges = [
			[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,0],
			[8,9],[9,10],[10,11],[11,12],[12,13],[13,14],[14,15],[15,8],
			[16,17],[17,18],[18,19],[19,20],[20,21],[21,22],[22,23],[23,16],
			[0,8],[8,16],[1,9],[9,17],[2,10],[10,18],[3,11],[11,19],
			[4,12],[12,20],[5,13],[13,21],[6,14],[14,22],[7,15],[15,23]
		];

		edges.forEach(([a,b]) => {
			const pa = toScreen(POINTS[a]);
			const pb = toScreen(POINTS[b]);
			ctx.beginPath();
			ctx.moveTo(pa.x, pa.y);
			ctx.lineTo(pb.x, pb.y);
			ctx.stroke();
		});

		ctx.fillStyle = "#1b1f2b";
		ctx.fillRect(layout.offsetX + layout.step * 0.4, layout.offsetY + layout.step * 0.4, layout.step * 5.2, layout.step * 5.2);
	}

	function drawPieces(ctx) {
		ctx.clearRect(0, 0, layout.width, layout.height);
		const r = layout.step * 0.16;
		for (let i = 0; i < POINTS.length; i++) {
			const pt = toScreen(POINTS[i]);
			const piece = state.board[i];

			// connection dots
			ctx.fillStyle = "#1c2230";
			ctx.beginPath();
			ctx.arc(pt.x, pt.y, r * 0.9, 0, Math.PI * 2);
			ctx.fill();
			ctx.strokeStyle = "#30374c";
			ctx.lineWidth = 2;
			ctx.stroke();

			if (!piece) continue;
			ctx.beginPath();
			ctx.arc(pt.x, pt.y, r * 1.4, 0, Math.PI * 2);
			ctx.fillStyle = piece === LIGHT ? "#f5f5f7" : "#0f121b";
			ctx.strokeStyle = piece === LIGHT ? "#1d1f2a" : "#6ab0ff";
			ctx.lineWidth = 3;
			ctx.fill();
			ctx.stroke();
		}

		const ui = uiLayer.getContext("2d");
		ui.clearRect(0, 0, layout.width, layout.height);
		const cursorR = r * 1.8;
		if (state.selected !== null) {
			const pt = toScreen(POINTS[state.selected]);
			ui.strokeStyle = "#58c6ff";
			ui.lineWidth = 3;
			ui.beginPath();
			ui.arc(pt.x, pt.y, cursorR, 0, Math.PI * 2);
			ui.stroke();
		}
		if (state.pendingCapture) {
			ui.strokeStyle = "#ffc857";
			ui.lineWidth = 3;
			legalCaptureTargets().forEach(id => {
				const pt = toScreen(POINTS[id]);
				ui.beginPath();
				ui.arc(pt.x, pt.y, cursorR * 0.8, 0, Math.PI * 2);
				ui.stroke();
			});
		} else {
			ui.strokeStyle = "#b8ff7a";
			ui.lineWidth = 2.5;
			state.legal.forEach(id => {
				const pt = toScreen(POINTS[id]);
				ui.beginPath();
				ui.arc(pt.x, pt.y, cursorR * 0.8, 0, Math.PI * 2);
				ui.stroke();
			});
		}

		if (state.lastMove) {
			const { from, to, type } = state.lastMove;
			ui.strokeStyle = "#7ed0ff";
			ui.lineWidth = 2;
			if (from !== null) {
				const a = toScreen(POINTS[from]);
				ui.beginPath();
				ui.arc(a.x, a.y, cursorR * 0.65, 0, Math.PI * 2);
				ui.stroke();
			}
			if (to !== null) {
				const b = toScreen(POINTS[to]);
				ui.beginPath();
				ui.arc(b.x, b.y, cursorR * 0.65, 0, Math.PI * 2);
				ui.stroke();
			}
			if (type === "move" && from !== null && to !== null) {
				const a = toScreen(POINTS[from]);
				const b = toScreen(POINTS[to]);
				ui.beginPath();
				ui.moveTo(a.x, a.y);
				ui.lineTo(b.x, b.y);
				ui.stroke();
			}
		}

		drawCursor(ui);
	}

	function drawCursor(ctx) {
		if (cursor === null) return;
		const pt = toScreen(POINTS[cursor]);
		ctx.strokeStyle = "#58c6ff";
		ctx.lineWidth = 1.5;
		ctx.setLineDash([6,4]);
		ctx.beginPath();
		ctx.arc(pt.x, pt.y, layout.step * 0.3, 0, Math.PI * 2);
		ctx.stroke();
		ctx.setLineDash([]);
	}

	let cursor = 0;

	function onBoard(pos) { return pos >= 0 && pos < POINTS.length; }

	function legalCaptureTargets() {
		const opp = oppColor();
		const targets = [];
		for (let i = 0; i < state.board.length; i++) {
			if (state.board[i] !== opp) continue;
			if (!isInMill(i, opp, state.board)) targets.push(i);
		}
		if (targets.length) return targets;
		for (let i = 0; i < state.board.length; i++) if (state.board[i] === opp) targets.push(i);
		return targets;
	}

	function isInMill(pos, color, board) {
		return MILLS.some(line => line.includes(pos) && line.every(p => board[p] === color));
	}

	function formedMill(pos, color, board) {
		return isInMill(pos, color, board);
	}

	function pieceCount(color) {
		return state.board.filter(p => p === color).length;
	}

	function oppColor() { return state.turn === LIGHT ? DARK : LIGHT; }

	function phaseFor(color) {
		if (state.toPlace[color] > 0) return "place";
		if (pieceCount(color) <= 3) return "fly";
		return "move";
	}

	function legalMovesForPiece(id, color) {
		const phase = phaseFor(color);
		if (phase === "place") return [];
		const res = [];
		if (phase === "fly") {
			for (let i = 0; i < state.board.length; i++) {
				if (state.board[i] === 0) res.push(i);
			}
		} else {
			(ADJ[id] || []).forEach(n => { if (state.board[n] === 0) res.push(n); });
		}
		return res;
	}

	function legalMoves(color) {
		const moves = [];
		if (state.toPlace[color] > 0) {
			for (let i = 0; i < state.board.length; i++) if (state.board[i] === 0) moves.push({ type: "place", to: i });
			return moves;
		}
		for (let i = 0; i < state.board.length; i++) {
			if (state.board[i] !== color) continue;
			const dests = legalMovesForPiece(i, color);
			dests.forEach(d => moves.push({ type: "move", from: i, to: d }));
		}
		return moves;
	}

	function applyMovePlace(to) {
		if (state.board[to] !== 0) return false;
		state.board[to] = state.turn;
		state.toPlace[state.turn] -= 1;
		state.lastMove = { type: "place", from: null, to };
		state.moveHistory.push(descMove(state.turn, state.lastMove));
		if (formedMill(to, state.turn, state.board)) {
			state.pendingCapture = true;
			state.captureTarget = oppColor();
			state.message = "Mill! Capture an enemy piece.";
		} else {
			endTurn();
		}
		return true;
	}

	function applyMoveSlide(from, to) {
		if (state.board[from] !== state.turn) return false;
		const legal = legalMovesForPiece(from, state.turn);
		if (!legal.includes(to)) return false;
		state.board[from] = 0;
		state.board[to] = state.turn;
		state.lastMove = { type: "move", from, to };
		state.moveHistory.push(descMove(state.turn, state.lastMove));
		if (formedMill(to, state.turn, state.board)) {
			state.pendingCapture = true;
			state.captureTarget = oppColor();
			state.message = "Mill! Capture an enemy piece.";
		} else {
			endTurn();
		}
		return true;
	}

	function capture(at) {
		const targets = legalCaptureTargets();
		if (!targets.includes(at)) return false;
		const capColor = state.board[at];
		state.board[at] = 0;
		state.moveHistory.push({ text: `${colorName(state.turn)} captures ${colorName(capColor)} at ${coordLabel(at)}` });
		state.lastMove = { type: "capture", from: null, to: at };
		state.pendingCapture = false;
		state.captureTarget = null;
		if (checkWin(capColor)) return true;
		endTurn();
		return true;
	}

	function colorName(c) { return c === LIGHT ? "White" : "Black"; }

	function descMove(color, mv) {
		if (mv.type === "place") return { text: `${colorName(color)} place ${coordLabel(mv.to)}` };
		return { text: `${colorName(color)} ${coordLabel(mv.from)}-${coordLabel(mv.to)}` };
	}

	function coordLabel(id) {
		const pt = POINTS[id];
		const col = String.fromCharCode(97 + pt.x);
		const row = 7 - pt.y;
		return `${col}${row}`;
	}

	function endTurn() {
		if (state.gameOver) return;
		const prev = state.turn;
		state.turn = oppColor();
		state.selected = null;
		state.legal = [];
		state.message = "";

		if (checkBlockedCurrent(prev)) return;
		updateHud();
		render();
		maybeRunAI();
	}

	function checkBlockedCurrent(prevPlayerColor) {
		const moves = legalMoves(state.turn);
		// If all pieces are placed and no moves, current player is blocked
		if (state.toPlace[state.turn] === 0 && moves.length === 0) {
			endGame(prevPlayerColor, `${colorName(prevPlayerColor)} wins (opponent blocked)`);
			return true;
		}
		// If no moves but still in placement, pass the turn
		if (moves.length === 0) {
			state.message = "No legal moves (passing)";
			updateHud();
			render();
			setTimeout(() => endTurn(), 300);
			return true;
		}
		return false;
	}

	function checkWin(colorJustCaptured) {
		const opp = colorJustCaptured;
		const oppCount = pieceCount(opp);
		// Only declare win for reaching 2 when opponent has no reserves to place
		if (state.toPlace[opp] === 0 && oppCount <= 2) {
			endGame(state.turn, `${colorName(state.turn)} wins (opponent to 2 pieces)`);
			return true;
		}
		if (state.toPlace[opp] === 0) {
			const moves = legalMoves(opp);
			if (!moves.length) {
				endGame(state.turn, `${colorName(state.turn)} wins (blocked)`);
				return true;
			}
		}
		return false;
	}

	function updateHud() {
		const moves = legalMoves(state.turn);
		turnText.textContent = `Turn: ${state.turn === LIGHT ? "WHITE" : "BLACK"}`;
		aiText.textContent = state.aiEnabled ? `AI: ${state.aiLevel.toUpperCase()} (${state.aiColor === LIGHT ? "WHITE" : "BLACK"})` : "AI: OFF";
		msgText.textContent = state.gameOver ? (state.message || `${state.winner || ""}`) : (state.message || "Ready");
		movesText.textContent = state.gameOver ? "Moves: --" : `Moves: ${moves.length}`;
		reserveText.textContent = `To place W:${state.toPlace[LIGHT]} B:${state.toPlace[DARK]}`;
		pieceText.textContent = `On board W:${pieceCount(LIGHT)} B:${pieceCount(DARK)}`;
		if (state.lastMove) {
			if (state.lastMove.type === "place") lastMoveText.textContent = `Last: place ${coordLabel(state.lastMove.to)}`;
			else if (state.lastMove.type === "move") lastMoveText.textContent = `Last: ${coordLabel(state.lastMove.from)}-${coordLabel(state.lastMove.to)}`;
			else if (state.lastMove.type === "capture") lastMoveText.textContent = `Last: capture ${coordLabel(state.lastMove.to)}`;
		} else lastMoveText.textContent = "Last: --";
		renderHistory();
		// Ensure AI turn triggers even if a prior call was skipped
		if (!state.menuActive && state.aiEnabled && !state.gameOver && state.turn === state.aiColor && !state.thinking) {
			maybeRunAI();
		}
	}

	function renderHistory() {
		moveList.innerHTML = state.moveHistory.map((mv, i) => `<div class="move-line">${i + 1}. ${mv.text}</div>`).join("");
	}

	function toggleHistory(force) {
		const show = force !== undefined ? force : !historyPanel.classList.contains("show");
		historyPanel.classList.toggle("show", show);
	}

	function toggleRules(force) {
		const show = force !== undefined ? force : !rulesOverlay.classList.contains("show");
		rulesOverlay.classList.toggle("show", show);
	}

	function showStartOverlay() {
		startOverlay.style.display = "flex";
		state.menuActive = true;
		setBoardInput(false);
	}

	function setBoardInput(enabled) {
		uiLayer.style.pointerEvents = enabled ? "auto" : "none";
	}

	function handlePointer(e) {
		if (state.menuActive) return;
		const rect = uiLayer.getBoundingClientRect();
		const mx = e.clientX - rect.left;
		const my = e.clientY - rect.top;
		const id = pickPoint(mx, my);
		if (id === null) return;
		cursor = id;
		processAction(id);
	}

	function pickPoint(x, y) {
		let best = null;
		let bestDist = layout.step * 0.3;
		for (let i = 0; i < POINTS.length; i++) {
			const pt = toScreen(POINTS[i]);
			const dx = x - pt.x;
			const dy = y - pt.y;
			const d = Math.sqrt(dx * dx + dy * dy);
			if (d < bestDist) { bestDist = d; best = i; }
		}
		return best;
	}

	function processAction(id) {
		if (state.gameOver) return;
		if (state.pendingCapture) {
			if (capture(id)) { updateHud(); render(); maybeRunAI(); }
			return;
		}
		if (state.toPlace[state.turn] > 0) {
			if (applyMovePlace(id)) { render(); updateHud(); maybeRunAI(); }
			return;
		}
		if (state.selected === null) {
			if (state.board[id] === state.turn) {
				state.selected = id;
				state.legal = legalMovesForPiece(id, state.turn);
				state.message = "Select a destination";
			}
		} else if (id === state.selected) {
			state.selected = null;
			state.legal = [];
			state.message = "";
		} else if (state.legal.includes(id)) {
			if (applyMoveSlide(state.selected, id)) {
				state.selected = null;
				state.legal = [];
			}
		} else if (state.board[id] === state.turn) {
			state.selected = id;
			state.legal = legalMovesForPiece(id, state.turn);
		}
		render();
		updateHud();
	}

	function handleKey(e) {
		const key = e.key.toLowerCase();
		if (rulesOverlay.classList.contains("show")) {
			if (["h","escape","enter"," "].includes(key)) toggleRules(false);
			return;
		}
		if (state.menuActive) {
			if (key === "1") { selectedMode = "1p"; applyModeUI(); }
			else if (key === "2") { selectedMode = "2p"; applyModeUI(); }
			else if (key === "arrowup" || key === "w") { cycleDiff(-1); }
			else if (key === "arrowdown" || key === "s") { cycleDiff(1); }
			else if (key === "enter" || key === " ") { startSelected(); }
			return;
		}
		if (key === "arrowright" || key === "d") moveCursor(1);
		else if (key === "arrowleft" || key === "a") moveCursor(-1);
		else if (key === "arrowup" || key === "w") moveCursor(-3);
		else if (key === "arrowdown" || key === "s") moveCursor(3);
		else if (key === "enter" || key === " ") { processAction(cursor); }
		else if (key === "u") { undo(); }
		else if (key === "r") { resetGame(); render(); updateHud(); }
		else if (key === "h") { toggleRules(); }
		render();
		updateHud();
	}

	function moveCursor(delta) {
		cursor = (cursor + POINTS.length + delta) % POINTS.length;
	}

	function undo() {
		if (!state.moveHistory.length) return;
		let remove = 1;
		if (state.moveHistory[state.moveHistory.length - 1].text.includes("captures")) remove = 2;
		const historyCopy = state.moveHistory.slice(0, Math.max(0, state.moveHistory.length - remove));
		resetGame();
		state.menuActive = false;
		setBoardInput(true);
		state.moveHistory = [];
		historyCopy.forEach(entry => replay(entry.text));
		state.lastMove = null;
		updateHud();
		render();
	}

	function replay(text) {
		// text examples: "White place a7" or "Black a7-a4" or capture line
		const parts = text.split(" ");
		const color = parts[0] === "White" ? LIGHT : DARK;
		state.turn = color;
		if (parts[1] === "place") {
			const coord = parts[2];
			const id = labelToId(coord);
			state.board[id] = color;
			state.toPlace[color] = Math.max(0, state.toPlace[color] - 1);
		}
		else if (parts[1].includes("-")) {
			const [fromLabel, toLabel] = parts[1].split("-");
			const from = labelToId(fromLabel);
			const to = labelToId(toLabel);
			state.board[from] = 0;
			state.board[to] = color;
		} else if (parts[1] === "captures") {
			const coord = parts[4];
			const id = labelToId(coord);
			state.board[id] = 0;
		}
		state.moveHistory.push({ text });
		state.turn = oppColor();
	}

	function labelToId(label) {
		const col = label.charCodeAt(0) - 97;
		const row = parseInt(label.slice(1), 10);
		const y = 7 - row;
		for (let i = 0; i < POINTS.length; i++) {
			if (POINTS[i].x === col && POINTS[i].y === y) return i;
		}
		return 0;
	}

	function maybeRunAI() {
		if (!state.aiEnabled) return;
		if (state.menuActive) return;
		if (state.gameOver) return;
		if (state.turn !== state.aiColor) return;
		if (state.thinking) return;
		if (checkBlockedCurrent(oppColor())) return;
		state.thinking = true;
		setTimeout(() => {
			if (state.gameOver) { state.thinking = false; return; }
			if (state.pendingCapture) {
				const targets = legalCaptureTargets();
				const pick = chooseCapture(targets);
				capture(pick);
			} else if (state.toPlace[state.turn] > 0) {
				const mv = choosePlacement();
				if (mv === null || mv === undefined) {
					endGame(oppColor(), `${colorName(oppColor())} wins (no moves for ${colorName(state.turn)})`);
					return;
				}
				applyMovePlace(mv);
			} else {
				const mv = chooseMove();
				if (mv) applyMoveSlide(mv.from, mv.to);
				else {
					endGame(oppColor(), `${colorName(oppColor())} wins (no moves for ${colorName(state.turn)})`);
					return;
				}
			}
			state.thinking = false;
			render();
			updateHud();
			maybeRunAI();
		}, state.aiLevel === "hard" ? 120 : state.aiLevel === "medium" ? 200 : 260);
	}

	function chooseCapture(list) {
		if (!list.length) return null;
		return list[Math.floor(Math.random() * list.length)];
	}

	function choosePlacement() {
		const empties = [];
		for (let i = 0; i < state.board.length; i++) if (state.board[i] === 0) empties.push(i);
		const best = empties.filter(id => wouldMillPlace(id, state.turn));
		if (best.length && state.aiLevel !== "easy") return best[Math.floor(Math.random() * best.length)];
		return empties[Math.floor(Math.random() * empties.length)];
	}

	function wouldMillPlace(id, color) {
		const board = [...state.board];
		board[id] = color;
		return formedMill(id, color, board);
	}

	function chooseMove() {
		const moves = legalMoves(state.turn);
		if (!moves.length) return null;
		const scoring = moves.map(mv => ({ mv, score: scoreMove(mv) }));
		const max = Math.max(...scoring.map(s => s.score));
		const best = scoring.filter(s => s.score >= max - 0.01);
		return best[Math.floor(Math.random() * best.length)].mv;
	}

	function scoreMove(mv) {
		if (mv.type === "move") {
			if (state.aiLevel === "easy") return Math.random();
			const board = [...state.board];
			board[mv.from] = 0;
			board[mv.to] = state.turn;
			let score = 0;
			if (formedMill(mv.to, state.turn, board)) score += 5;
			score += Math.random() * 0.2;
			return score;
		}
		if (mv.type === "place") {
			const board = [...state.board];
			board[mv.to] = state.turn;
			if (formedMill(mv.to, state.turn, board)) return 4 + Math.random() * 0.2;
			return Math.random();
		}
		return Math.random();
	}

	function applyModeUI() {
		[btn1p, btn2p].forEach(b => b.classList.remove("active"));
		if (selectedMode === "1p") btn1p.classList.add("active"); else btn2p.classList.add("active");
	}

	function setDifficulty(level) {
		state.aiLevel = level;
		selectedDiff = level;
		applyDifficultyUI();
		updateHud();
	}

	function applyDifficultyUI() {
		[btnEasy, btnMed, btnHard].forEach(b => b.classList.remove("active"));
		if (state.aiLevel === "easy") btnEasy.classList.add("active");
		else if (state.aiLevel === "hard") btnHard.classList.add("active");
		else btnMed.classList.add("active");
		selectedDiff = state.aiLevel;
	}

	function cycleDiff(delta) {
		const diffs = ["easy", "medium", "hard"];
		const idx = diffs.indexOf(selectedDiff);
		selectedDiff = diffs[(idx + delta + diffs.length) % diffs.length];
		state.aiLevel = selectedDiff;
		applyDifficultyUI();
	}

	function start1P() {
		state.aiEnabled = true;
		state.aiColor = DARK; // human as White, AI as Black
		state.menuActive = false;
		startOverlay.style.display = "none";
		setBoardInput(true);
		resetGame();
		applyDifficultyUI();
		render();
		updateHud();
		if (state.turn === state.aiColor) maybeRunAI();
	}

	function start2P() {
		state.aiEnabled = false;
		state.menuActive = false;
		startOverlay.style.display = "none";
		setBoardInput(true);
		resetGame();
		applyDifficultyUI();
		render();
		updateHud();
	}

	function startSelected() {
		state.aiLevel = selectedDiff;
		if (selectedMode === "1p") start1P(); else start2P();
	}

	function render() {
		drawBoard(boardLayer.getContext("2d"));
		drawPieces(piecesLayer.getContext("2d"));
	}

	// Init
	resetGame();
	resize();
	applyDifficultyUI();
	applyModeUI();
	setBoardInput(false);
	render();
	updateHud();

	// Events
	uiLayer.addEventListener("mousedown", handlePointer);
	window.addEventListener("resize", () => { resize(); render(); });
	window.addEventListener("keydown", handleKey);
	btn1p.addEventListener("click", () => { selectedMode = "1p"; applyModeUI(); });
	btn2p.addEventListener("click", () => { selectedMode = "2p"; applyModeUI(); });
	btnEasy.addEventListener("click", () => setDifficulty("easy"));
	btnMed.addEventListener("click", () => setDifficulty("medium"));
	btnHard.addEventListener("click", () => setDifficulty("hard"));
	btnStartOverlay.addEventListener("click", startSelected);
	btnRules.addEventListener("click", () => toggleRules(true));
	closeRules.addEventListener("click", () => toggleRules(false));
	hudBtnStart.addEventListener("click", showStartOverlay);
	hudBtnReset.addEventListener("click", () => { resetGame(); render(); updateHud(); });
	hudBtnUndo.addEventListener("click", () => { undo(); render(); updateHud(); });
	hudBtnHistory.addEventListener("click", () => toggleHistory());
	btnHistoryClose.addEventListener("click", () => toggleHistory(false));

})();
</script>
</body>
</html>
