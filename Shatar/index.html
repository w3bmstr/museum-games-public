<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shatar</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; background:#0b0d12; color:#e8ebf2; font-family:"Segoe UI", system-ui, sans-serif; overflow:hidden; }
    #game-container { position:relative; width:100vw; height:100vh; overflow:hidden; background: radial-gradient(circle at 20% 20%, rgba(251,191,36,0.08), transparent 45%), radial-gradient(circle at 80% 70%, rgba(59,130,246,0.08), transparent 45%), #0b0d12; }
    canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }
    .layer-board { z-index:0; pointer-events:none; }
    .layer-pieces { z-index:1; pointer-events:none; }
    #hud { position:absolute; top:10px; left:10px; z-index:5; display:flex; flex-direction:column; gap:8px; }
    .panel { background:rgba(0,0,0,0.58); border:1px solid #1f2430; border-radius:10px; padding:10px 12px; min-width:240px; box-shadow:0 10px 28px rgba(0,0,0,0.35); }
    .panel h4 { margin:0 0 6px 0; font-size:13px; letter-spacing:0.5px; color:#ffc857; }
    .panel p { margin:4px 0; font-size:13px; }
    #controls { display:flex; gap:8px; flex-wrap:wrap; }
    #controls button { padding:8px 10px; border:none; border-radius:8px; background:#252a38; color:#e8e8ec; cursor:pointer; font-size:13px; }
    #controls button.primary { background:linear-gradient(135deg, #fbbf24, #f59e0b); color:#0b0d12; }
    #controls button:disabled { opacity:0.55; cursor:not-allowed; }
    .history-panel { position:relative; max-height:260px; overflow-y:auto; font-family:monospace; font-size:12px; }
    .history-panel .move-line { margin:2px 0; }
    .history-close { position:absolute; top:6px; right:6px; padding:4px 8px; border:none; border-radius:6px; background:#252a38; color:#e8e8ec; cursor:pointer; font-size:11px; }
    #btn-history { display:none; }
    @media (max-width:720px) {
      #hud { position:fixed; top:auto; bottom:0; left:0; right:0; flex-direction:row; gap:6px; padding:6px; background:linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.45) 40%); backdrop-filter:blur(8px); }
      #hud .panel { min-width:0; flex:1; }
      #history { display:none; position:fixed; right:8px; bottom:78px; width:82vw; max-width:380px; max-height:55vh; z-index:12; background:rgba(0,0,0,0.85); border-radius:10px; }
      #history.show { display:block; }
      #btn-history { display:inline-block; }
    }
    #start-overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.72); z-index:10; }
    #start-card { background:#161820; border:1px solid #262c3a; border-radius:12px; padding:18px 22px; color:#f5f5f5; min-width:280px; box-shadow:0 12px 30px rgba(0,0,0,0.35); }
    #start-card h2 { margin:0 0 10px 0; font-size:20px; }
    #start-card p { margin:0 0 12px 0; font-size:14px; color:#cfd3dd; }
    #start-card .btn-row { display:flex; gap:10px; margin-top:10px; }
    #start-card button { flex:1; padding:10px 12px; border:none; border-radius:8px; background:linear-gradient(135deg, #fbbf24, #f59e0b); color:#0b0d12; font-weight:700; cursor:pointer; }
    #start-card button.secondary { background:#3a3f4f; color:#f5f5f5; }
    #start-card button.active { outline:2px solid #fff; }
    #rules-overlay { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.7); z-index:11; }
    #rules-overlay.show { display:flex; }
    #rules-card { background:#161820; border:1px solid #262c3a; border-radius:12px; padding:18px 22px; color:#f5f5f5; max-width:720px; width:90%; box-shadow:0 12px 30px rgba(0,0,0,0.35); line-height:1.45; }
    #rules-card h3 { margin:0 0 8px 0; font-size:18px; }
    #rules-card ul { margin:8px 0 0 18px; padding:0; }
    #rules-card li { margin:4px 0; }
    #close-rules { margin-top:12px; padding:8px 12px; border:none; border-radius:8px; background:#3a3f4f; color:#fff; cursor:pointer; }
  </style>
</head>
<body>
<div id="game-container">
  <div id="hud">
    <div class="panel">
      <h4>Status</h4>
      <p id="turn-text">Turn: --</p>
      <p id="ai-text">AI: --</p>
      <p id="msg-text">Ready</p>
      <p id="lastmove-text">Last: --</p>
    </div>
    <div id="controls" class="panel">
      <button id="btn-start" class="primary">New Game</button>
      <button id="btn-reset">Reset</button>
      <button id="btn-undo">Undo</button>
      <button id="btn-history">History</button>
      <button id="btn-rules">Rules</button>
    </div>
    <div id="history" class="panel history-panel">
      <h4>Moves</h4>
      <button id="btn-history-close" class="history-close">Close</button>
      <div id="move-list"></div>
    </div>
  </div>

  <div id="start-overlay">
    <div id="start-card">
      <h2>Shatar</h2>
      <p>8x8 Mongolian chess: forced d-pawn opening, no castling, pawns single-step after opening, promote to baras (queen).</p>
      <div class="btn-row">
        <button id="btn-1p">1 Player (vs AI)</button>
        <button id="btn-2p" class="secondary">2 Players</button>
      </div>
      <p style="margin-top:12px; margin-bottom:6px;">AI Difficulty</p>
      <div class="btn-row">
        <button id="btn-easy" class="secondary">Easy</button>
        <button id="btn-med" class="active">Medium</button>
        <button id="btn-hard" class="secondary">Hard</button>
      </div>
      <p style="margin-top:12px; margin-bottom:6px;">Start</p>
      <div class="btn-row" style="margin-top:8px;">
        <button id="btn-start-overlay" class="primary">Start Game</button>
      </div>
    </div>
  </div>

  <div id="rules-overlay">
    <div id="rules-card">
      <h3>Rules</h3>
      <ul>
        <li>Board: 8x8. Standard chess setup; no castling.</li>
        <li>Opening: White must play d2→d4 (two steps). Black must reply d7→d5 (two steps). These are the only double-steps.</li>
        <li>Pawns: After the opening, move one forward (no double), capture diagonally; no en passant; promote to queen (baras) on last rank.</li>
        <li>Pieces: Baras (queen) like chess queen; Temee (bishop), Mori (knight), Tereg (rook), Noyon (king) as in chess (king step only).</li>
        <li>Win by checkmate; stalemate is draw. King capture ends game.</li>
        <li>Controls: click squares; U undo; R reset; H rules.</li>
      </ul>
      <button id="close-rules">Close</button>
    </div>
  </div>
</div>

<script>
(() => {
  const ROWS = 8, COLS = 8;
  const WHITE = 1, BLACK = 2;
  const dpr = window.devicePixelRatio || 1;

  const PIECE_VALUES = { K: 10000, Q: 900, R: 500, B: 330, N: 320, P: 100 };
  const GLYPH = {
    [WHITE]: { K:'♔', Q:'♕', R:'♖', B:'♗', N:'♘', P:'♙' },
    [BLACK]: { K:'♚', Q:'♛', R:'♜', B:'♝', N:'♞', P:'♟' }
  };

  const container = document.getElementById('game-container');
  const startOverlay = document.getElementById('start-overlay');
  const btn1p = document.getElementById('btn-1p');
  const btn2p = document.getElementById('btn-2p');
  const btnEasy = document.getElementById('btn-easy');
  const btnMed = document.getElementById('btn-med');
  const btnHard = document.getElementById('btn-hard');
  const btnStartOverlay = document.getElementById('btn-start-overlay');
  const btnRules = document.getElementById('btn-rules');
  const rulesOverlay = document.getElementById('rules-overlay');
  const closeRules = document.getElementById('close-rules');
  const hudBtnStart = document.getElementById('btn-start');
  const hudBtnReset = document.getElementById('btn-reset');
  const hudBtnUndo = document.getElementById('btn-undo');
  const hudBtnHistory = document.getElementById('btn-history');
  const btnHistoryClose = document.getElementById('btn-history-close');
  const historyPanel = document.getElementById('history');
  const turnText = document.getElementById('turn-text');
  const aiText = document.getElementById('ai-text');
  const msgText = document.getElementById('msg-text');
  const lastMoveText = document.getElementById('lastmove-text');
  const moveList = document.getElementById('move-list');

  const boardLayer = document.createElement('canvas');
  const piecesLayer = document.createElement('canvas');
  boardLayer.className = 'layer-board';
  piecesLayer.className = 'layer-pieces';
  container.appendChild(boardLayer);
  container.appendChild(piecesLayer);

  const layout = { width:0, height:0, cell:0, offsetX:0, offsetY:0 };

  const state = {
    board: [],
    turn: WHITE,
    openingStage: 0, // 0 white must d4, 1 black must d5, 2 normal
    vsAI: true,
    aiColor: BLACK,
    aiDepth: 2,
    gameOver: false,
    history: [],
    lastMove: null,
    selected: null,
    moves: []
  };

  function makePiece(color, type) { return { c: color, t: type }; }

  function setupBoard() {
    state.board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
    const back = ['R','N','B','Q','K','B','N','R'];
    for (let c = 0; c < COLS; c++) {
      state.board[7][c] = makePiece(WHITE, back[c]);
      state.board[6][c] = makePiece(WHITE, 'P');
      state.board[0][c] = makePiece(BLACK, back[c]);
      state.board[1][c] = makePiece(BLACK, 'P');
    }
  }

  function resetGame() {
    setupBoard();
    state.turn = WHITE;
    state.openingStage = 0;
    state.gameOver = false;
    state.history = [];
    state.lastMove = null;
    state.selected = null;
    state.moves = [];
    msgText.textContent = 'Opening: White must play d4';
    updateHud();
    resizeAndRedraw();
    maybeAIMove();
  }

  function cloneBoard(b) { return b.map(row => row.map(cell => cell ? { ...cell } : null)); }

  function applyMove(b, mv) {
    const { fr, fc, tr, tc, promo } = mv;
    b[tr][tc] = { ...b[fr][fc] };
    b[fr][fc] = null;
    if (promo) b[tr][tc].t = promo;
  }

  function kingPos(b, color) {
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
      const p = b[r][c];
      if (p && p.c === color && p.t === 'K') return { r, c };
    }
    return null;
  }

  function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }

  function generatePseudo(b, color, openingStage) {
    const moves = [];
    const dir = color === WHITE ? -1 : 1;
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
      const p = b[r][c];
      if (!p || p.c !== color) continue;
      if (p.t === 'P') {
        if (openingStage === 0 && color === WHITE) {
          if (r === 6 && c === 3 && !b[5][3] && !b[4][3]) moves.push({fr:r,fc:c,tr:4,tc:3,promo:null});
          continue;
        }
        if (openingStage === 1 && color === BLACK) {
          if (r === 1 && c === 3 && !b[2][3] && !b[3][3]) moves.push({fr:r,fc:c,tr:3,tc:3,promo:null});
          continue;
        }
        const fwd = { r: r+dir, c };
        if (inBounds(fwd.r, fwd.c) && !b[fwd.r][fwd.c]) {
          moves.push({ fr:r, fc:c, tr:fwd.r, tc:fwd.c, promo: (color===WHITE && fwd.r===0) || (color===BLACK && fwd.r===ROWS-1) ? 'Q' : null });
        }
        const caps = [ {r:r+dir, c:c-1}, {r:r+dir, c:c+1} ];
        for (const cap of caps) {
          if (!inBounds(cap.r, cap.c)) continue;
          const t = b[cap.r][cap.c];
          if (t && t.c !== color) moves.push({ fr:r, fc:c, tr:cap.r, tc:cap.c, promo: (color===WHITE && cap.r===0) || (color===BLACK && cap.r===ROWS-1) ? 'Q' : null });
        }
      } else if (p.t === 'N') {
        const deltas = [[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]];
        for (const [dr,dc] of deltas) {
          const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)) continue;
          const t=b[nr][nc]; if(!t || t.c!==color) moves.push({fr:r,fc:c,tr:nr,tc:nc,promo:null});
        }
      } else if (p.t === 'B' || p.t === 'R' || p.t === 'Q') {
        const dirs = [];
        if (p.t !== 'R') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
        if (p.t !== 'B') dirs.push([1,0],[-1,0],[0,1],[0,-1]);
        for (const [dr,dc] of dirs) {
          let nr=r+dr, nc=c+dc;
          while (inBounds(nr,nc)) {
            const t=b[nr][nc];
            if (!t) moves.push({fr:r,fc:c,tr:nr,tc:nc,promo:null});
            else { if (t.c!==color) moves.push({fr:r,fc:c,tr:nr,tc:nc,promo:null}); break; }
            nr+=dr; nc+=dc;
          }
        }
      } else if (p.t === 'K') {
        for (let dr=-1; dr<=1; dr++) for (let dc=-1; dc<=1; dc++) {
          if (dr===0 && dc===0) continue;
          const nr=r+dr, nc=c+dc; if(!inBounds(nr,nc)) continue;
          const t=b[nr][nc]; if (!t || t.c!==color) moves.push({fr:r,fc:c,tr:nr,tc:nc,promo:null});
        }
      }
    }
    return moves;
  }

  function isCheck(b, color) {
    const enemy = color === WHITE ? BLACK : WHITE;
    const enemyMoves = generatePseudo(b, enemy, 2);
    const k = kingPos(b, color);
    if (!k) return true;
    return enemyMoves.some(m => m.tr === k.r && m.tc === k.c);
  }

  function generateLegal(b, color, openingStage) {
    const pseudo = generatePseudo(b, color, openingStage);
    const legal = [];
    for (const mv of pseudo) {
      const nb = cloneBoard(b);
      applyMove(nb, mv);
      if (!isCheck(nb, color)) legal.push(mv);
    }
    return legal;
  }

  function evaluate(b) {
    let score = 0;
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
      const p = b[r][c]; if (!p) continue;
      score += (p.c === WHITE ? 1 : -1) * PIECE_VALUES[p.t];
    }
    return score;
  }

  function minimax(b, depth, alpha, beta, maximizing, openingStage) {
    if (depth === 0) return { score: evaluate(b) + (Math.random()-0.5)*5 };
    const color = maximizing ? WHITE : BLACK;
    const moves = generateLegal(b, color, openingStage);
    if (!moves.length) return { score: isCheck(b, color) ? (maximizing ? -99999 : 99999) : 0 };
    let bestMove = null;
    if (maximizing) {
      let best = -Infinity;
      for (const mv of moves) {
        const nb = cloneBoard(b);
        applyMove(nb, mv);
        const nextStage = openingStage < 2 ? openingStage + 1 : 2;
        const res = minimax(nb, depth-1, alpha, beta, false, nextStage);
        if (res.score > best) { best = res.score; bestMove = mv; }
        alpha = Math.max(alpha, res.score);
        if (beta <= alpha) break;
      }
      return { score: best, move: bestMove };
    } else {
      let best = Infinity;
      for (const mv of moves) {
        const nb = cloneBoard(b);
        applyMove(nb, mv);
        const nextStage = openingStage < 2 ? openingStage + 1 : 2;
        const res = minimax(nb, depth-1, alpha, beta, true, nextStage);
        if (res.score < best) { best = res.score; bestMove = mv; }
        beta = Math.min(beta, res.score);
        if (beta <= alpha) break;
      }
      return { score: best, move: bestMove };
    }
  }

  function updateHud() {
    turnText.textContent = `Turn: ${state.turn === WHITE ? 'White' : 'Black'}`;
    aiText.textContent = state.vsAI ? `AI: ${state.aiColor === WHITE ? 'White' : 'Black'} depth ${state.aiDepth}` : 'AI: Off';
    msgText.textContent = state.gameOver ? 'Game over' : msgText.textContent;
    lastMoveText.textContent = state.lastMove ? `Last: ${state.lastMove}` : 'Last: --';
  }

  function pushHistory(statusText) {
    moveList.innerHTML = '';
    state.history.forEach((m, i) => {
      const div = document.createElement('div');
      div.className = 'move-line';
      div.textContent = `${i+1}. ${m}`;
      moveList.appendChild(div);
    });
    msgText.textContent = statusText;
  }

  function coordsFromEvent(evt) {
    const rect = container.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * dpr;
    const y = (evt.clientY - rect.top) * dpr;
    const col = Math.floor((x - layout.offsetX*dpr) / (layout.cell*dpr));
    const row = Math.floor((y - layout.offsetY*dpr) / (layout.cell*dpr));
    return { row, col };
  }

  function handleClick(evt) {
    if (state.gameOver || startOverlay.style.display !== 'none') return;
    const { row, col } = coordsFromEvent(evt);
    if (!inBounds(row,col)) return;
    const piece = state.board[row][col];
    if (state.selected) {
      const mv = state.moves.find(m => m.tr===row && m.tc===col);
      if (mv) { makeMove(mv); return; }
      state.selected = null; state.moves = []; redrawPieces(); return;
    }
    if (piece && piece.c === state.turn && (!state.vsAI || piece.c !== state.aiColor)) {
      state.selected = { r:row, c:col };
      state.moves = generateLegal(state.board, state.turn, state.openingStage).filter(m => m.fr===row && m.fc===col);
    } else {
      state.selected = null; state.moves = [];
    }
    redrawPieces();
  }

  function makeMove(mv) {
    const snapshot = {
      board: cloneBoard(state.board),
      turn: state.turn,
      openingStage: state.openingStage,
      lastMove: state.lastMove,
      gameOver: state.gameOver
    };
    state.undoStack = state.undoStack || [];
    state.undoStack.push(snapshot);

    applyMove(state.board, mv);
    if (state.openingStage === 0) state.openingStage = 1;
    else if (state.openingStage === 1) state.openingStage = 2;

    const moveStr = `${fileChar(mv.fc)}${8-mv.fr}→${fileChar(mv.tc)}${8-mv.tr}${mv.promo ? '=' + mv.promo : ''}`;
    state.history.push(moveStr);
    state.lastMove = moveStr;
    state.lastMoveHighlight = mv;

    state.turn = state.turn === WHITE ? BLACK : WHITE;
    state.selected = null;
    state.moves = [];

    const opp = state.turn;
    const oppMoves = generateLegal(state.board, opp, state.openingStage);
    if (!oppMoves.length) {
      const inCheck = isCheck(state.board, opp);
      state.gameOver = true;
      msgText.textContent = inCheck ? 'Checkmate' : 'Stalemate';
    } else {
      msgText.textContent = isCheck(state.board, opp) ? 'Check' : 'Game on';
    }
    updateHud();
    redrawAll();
    maybeAIMove();
  }

  function fileChar(c){ return String.fromCharCode('a'.charCodeAt(0)+c); }

  function undo() {
    if (!state.undoStack || !state.undoStack.length) return;
    const snap = state.undoStack.pop();
    state.board = snap.board;
    state.turn = snap.turn;
    state.openingStage = snap.openingStage;
    state.lastMove = snap.lastMove;
    state.gameOver = snap.gameOver;
    state.selected = null;
    state.moves = [];
    if (state.history.length) state.history.pop();
    msgText.textContent = 'Undo';
    redrawAll();
    updateHud();
  }

  function aiMove() {
    if (!state.vsAI || state.turn !== state.aiColor || state.gameOver) return;
    const depth = state.aiDepth;
    const maximizing = state.aiColor === WHITE;
    const res = minimax(state.board, depth, -Infinity, Infinity, maximizing, state.openingStage);
    if (res.move) makeMove(res.move);
  }

  function maybeAIMove() {
    if (state.vsAI && state.turn === state.aiColor && !state.gameOver) {
      setTimeout(aiMove, 120);
    }
  }

  function resize() {
    layout.width = container.clientWidth;
    layout.height = container.clientHeight;
    const size = Math.min(layout.width, layout.height) * 0.9;
    layout.cell = size / COLS;
    layout.offsetX = (layout.width - size) / 2;
    layout.offsetY = (layout.height - size) / 2;
    [boardLayer, piecesLayer].forEach(layer => {
      layer.width = layout.width * dpr;
      layer.height = layout.height * dpr;
      layer.style.width = layout.width + 'px';
      layer.style.height = layout.height + 'px';
      const ctx = layer.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
    });
  }

  function drawBoard() {
    const ctx = boardLayer.getContext('2d');
    ctx.clearRect(0,0,layout.width, layout.height);
    for (let r=0;r<ROWS;r++) {
      for (let c=0;c<COLS;c++) {
        const light = (r+c)%2===0;
        ctx.fillStyle = light ? '#f0d9b5' : '#b58863';
        ctx.fillRect(layout.offsetX + c*layout.cell, layout.offsetY + r*layout.cell, layout.cell, layout.cell);
      }
    }
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 1;
    for (let i=0;i<=ROWS;i++) {
      const x = layout.offsetX + i*layout.cell;
      ctx.beginPath();
      ctx.moveTo(layout.offsetX, layout.offsetY + i*layout.cell);
      ctx.lineTo(layout.offsetX + layout.cell*COLS, layout.offsetY + i*layout.cell);
      ctx.moveTo(x, layout.offsetY);
      ctx.lineTo(x, layout.offsetY + layout.cell*ROWS);
      ctx.stroke();
    }
    if (state.lastMoveHighlight) {
      ctx.fillStyle = 'rgba(88,198,255,0.2)';
      const { fr, fc, tr, tc } = state.lastMoveHighlight;
      ctx.fillRect(layout.offsetX + fc*layout.cell, layout.offsetY + fr*layout.cell, layout.cell, layout.cell);
      ctx.fillRect(layout.offsetX + tc*layout.cell, layout.offsetY + tr*layout.cell, layout.cell, layout.cell);
    }
  }

  function redrawPieces() {
    const ctx = piecesLayer.getContext('2d');
    ctx.clearRect(0,0,layout.width, layout.height);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${layout.cell * 0.6}px "Segoe UI Symbol"`;
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
      const p = state.board[r][c]; if (!p) continue;
      ctx.fillStyle = p.c === WHITE ? '#ffffff' : '#111111';
      ctx.fillText(GLYPH[p.c][p.t], layout.offsetX + c*layout.cell + layout.cell/2, layout.offsetY + r*layout.cell + layout.cell/2 + 1);
    }
    if (state.selected) {
      ctx.strokeStyle = 'rgba(249,115,22,0.9)';
      ctx.lineWidth = 3;
      ctx.strokeRect(layout.offsetX + state.selected.c*layout.cell + 2, layout.offsetY + state.selected.r*layout.cell + 2, layout.cell-4, layout.cell-4);
      ctx.fillStyle = 'rgba(249,115,22,0.3)';
      for (const mv of state.moves) {
        ctx.beginPath();
        ctx.arc(layout.offsetX + mv.tc*layout.cell + layout.cell/2, layout.offsetY + mv.tr*layout.cell + layout.cell/2, layout.cell*0.18, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  function redrawAll() { drawBoard(); redrawPieces(); pushHistory(msgText.textContent); }

  function resizeAndRedraw() { resize(); redrawAll(); }

  function bindUI() {
    container.addEventListener('click', handleClick);
    window.addEventListener('resize', resizeAndRedraw);
    window.addEventListener('keyup', e => {
      if (e.key === 'u' || e.key === 'U') undo();
      if (e.key === 'r' || e.key === 'R') resetGame();
      if (e.key === 'h' || e.key === 'H') rulesOverlay.classList.add('show');
    });

    btn1p.addEventListener('click', () => { state.vsAI = true; state.aiColor = BLACK; toggleSelect(btn1p, btn2p); });
    btn2p.addEventListener('click', () => { state.vsAI = false; toggleSelect(btn2p, btn1p); });
    btnEasy.addEventListener('click', () => { state.aiDepth = 1; setDiff(btnEasy); });
    btnMed.addEventListener('click', () => { state.aiDepth = 2; setDiff(btnMed); });
    btnHard.addEventListener('click', () => { state.aiDepth = 3; setDiff(btnHard); });
    btnStartOverlay.addEventListener('click', () => { startOverlay.style.display = 'none'; resetGame(); });

    hudBtnStart.addEventListener('click', resetGame);
    hudBtnReset.addEventListener('click', resetGame);
    hudBtnUndo.addEventListener('click', undo);
    btnRules.addEventListener('click', () => rulesOverlay.classList.add('show'));
    closeRules.addEventListener('click', () => rulesOverlay.classList.remove('show'));

    hudBtnHistory.addEventListener('click', () => historyPanel.classList.toggle('show'));
    btnHistoryClose.addEventListener('click', () => historyPanel.classList.remove('show'));
  }

  function toggleSelect(on, off) { on.classList.remove('secondary'); off.classList.add('secondary'); }
  function setDiff(btn) { [btnEasy, btnMed, btnHard].forEach(b => b.classList.remove('active')); btn.classList.add('active'); }

  // init
  setupBoard();
  resize();
  drawBoard();
  redrawPieces();
  bindUI();
})();
</script>
</body>
</html>
