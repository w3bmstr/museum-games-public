<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Shogi</title>
	<style>
		html, body { margin:0; padding:0; width:100%; height:100%; background:#0b0d12; color:#e8ebf2; font-family:"Segoe UI", system-ui, sans-serif; overflow:hidden; }
		#game-container { position:relative; width:100vw; height:100vh; overflow:hidden; background: radial-gradient(circle at 18% 18%, rgba(251,191,36,0.08), transparent 45%), radial-gradient(circle at 80% 70%, rgba(59,130,246,0.08), transparent 45%), #0b0d12; }
		canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }
		.layer-board { z-index:0; pointer-events:none; }
		.layer-pieces { z-index:1; pointer-events:none; }
		#hud { position:absolute; top:10px; left:10px; z-index:5; display:flex; flex-direction:column; gap:8px; }
		.panel { background:rgba(0,0,0,0.58); border:1px solid #1f2430; border-radius:10px; padding:10px 12px; min-width:260px; box-shadow:0 10px 28px rgba(0,0,0,0.35); }
		.panel h4 { margin:0 0 6px 0; font-size:13px; letter-spacing:0.5px; color:#ffc857; }
		.panel p { margin:4px 0; font-size:13px; }
		#controls { display:flex; gap:8px; flex-wrap:wrap; }
		#controls button { padding:8px 10px; border:none; border-radius:8px; background:#252a38; color:#e8e8ec; cursor:pointer; font-size:13px; }
		#controls button.primary { background:linear-gradient(135deg, #fbbf24, #f59e0b); color:#0b0d12; }
		#controls button:disabled { opacity:0.55; cursor:not-allowed; }
		.history-panel { position:relative; max-height:260px; overflow-y:auto; font-family:monospace; font-size:12px; }
		.history-panel .move-line { margin:2px 0; }
		.history-close { position:absolute; top:6px; right:6px; padding:4px 8px; border:none; border-radius:6px; background:#252a38; color:#e8e8ec; cursor:pointer; font-size:11px; }
		#btn-history { display:none; }
		@media (max-width:900px) {
			#hud { position:fixed; top:auto; bottom:0; left:0; right:0; flex-direction:row; gap:6px; padding:6px; background:linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.45) 40%); backdrop-filter:blur(8px); }
			#hud .panel { min-width:0; flex:1; }
			#history { display:none; position:fixed; right:8px; bottom:78px; width:82vw; max-width:380px; max-height:55vh; z-index:12; background:rgba(0,0,0,0.85); border-radius:10px; }
			#history.show { display:block; }
			#btn-history { display:inline-block; }
		}
		#start-overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.72); z-index:10; }
		#start-card { background:#161820; border:1px solid #262c3a; border-radius:12px; padding:18px 22px; color:#f5f5f5; min-width:300px; box-shadow:0 12px 30px rgba(0,0,0,0.35); }
		#start-card h2 { margin:0 0 10px 0; font-size:20px; }
		#start-card p { margin:0 0 12px 0; font-size:14px; color:#cfd3dd; }
		#start-card .btn-row { display:flex; gap:10px; margin-top:10px; }
		#start-card button { flex:1; padding:10px 12px; border:none; border-radius:8px; background:linear-gradient(135deg, #fbbf24, #f59e0b); color:#0b0d12; font-weight:700; cursor:pointer; }
		#start-card button.secondary { background:#3a3f4f; color:#f5f5f5; }
		#start-card button.active { outline:2px solid #fff; }
		#rules-overlay { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.7); z-index:11; }
		#rules-overlay.show { display:flex; }
		#rules-card { background:#161820; border:1px solid #262c3a; border-radius:12px; padding:18px 22px; color:#f5f5f5; max-width:820px; width:90%; box-shadow:0 12px 30px rgba(0,0,0,0.35); line-height:1.45; }
		#rules-card h3 { margin:0 0 8px 0; font-size:18px; }
		#rules-card ul { margin:8px 0 0 18px; padding:0; }
		#rules-card li { margin:4px 0; }
		#close-rules { margin-top:12px; padding:8px 12px; border:none; border-radius:8px; background:#3a3f4f; color:#fff; cursor:pointer; }
	</style>
</head>
<body>
<div id="game-container">
	<div id="hud">
		<div class="panel">
			<h4>Status</h4>
			<p id="turn-text">Turn: --</p>
			<p id="ai-text">AI: --</p>
			<p id="msg-text">Ready</p>
			<p id="lastmove-text">Last: --</p>
			<p id="hand-w">White hand: --</p>
			<p id="hand-b">Black hand: --</p>
		</div>
		<div id="controls" class="panel">
			<button id="btn-start" class="primary">New Game</button>
			<button id="btn-reset">Reset</button>
			<button id="btn-undo">Undo</button>
			<button id="btn-history">History</button>
			<button id="btn-rules">Rules</button>
		</div>
		<div id="history" class="panel history-panel">
			<h4>Moves</h4>
			<button id="btn-history-close" class="history-close">Close</button>
			<div id="move-list"></div>
		</div>
	</div>

	<div id="start-overlay">
		<div id="start-card">
			<h2>Shogi</h2>
			<p>Japanese chess with drops and promotions. Captured pieces change sides and can be dropped back. Promotion occurs in the far three ranks.</p>
			<div class="btn-row">
				<button id="btn-1p">1 Player (vs AI)</button>
				<button id="btn-2p" class="secondary">2 Players</button>
			</div>
			<p style="margin-top:12px; margin-bottom:6px;">AI Difficulty</p>
			<div class="btn-row">
				<button id="btn-easy" class="active">Easy</button>
				<button id="btn-med" class="secondary">Medium</button>
			</div>
			<p style="margin-top:12px; margin-bottom:6px;">Start</p>
			<div class="btn-row" style="margin-top:8px;">
				<button id="btn-start-overlay" class="primary">Start Game</button>
			</div>
		</div>
	</div>

	<div id="rules-overlay">
		<div id="rules-card">
			<h3>Rules (short)</h3>
			<ul>
				<li>Board 9×9. White at bottom moving up; Black at top moving down. Promotion zone: far 3 ranks.</li>
				<li>Pieces / moves: 王/玉 king (1 any direction); 飛 rook (promo 龍 adds king diagonals); 角 bishop (promo 馬 adds king orthogonals); 金 gold (forward, diagonals forward, sides, back straight); 銀 silver (forward + forward diagonals, back diagonals; promo moves as gold); 桂 knight (forward 2+1; promo as gold); 香 lance (any forward; promo as gold); 歩 pawn (1 forward; promo as gold).</li>
				<li>Promotion: optional when moving from/into zone; auto-promoted here for eligible pieces; forced for pawn/lance on last rank and knight on last two. Promotes to gold-move (歩/香/桂/銀), 龍 for 飛, 馬 for 角.</li>
				<li>Drops: captured pieces go to your hand unpromoted. Drop on empty squares. Pawns: no double unpromoted pawn in a file; cannot drop on last rank. Lances cannot drop on last rank; knights not on last two ranks.</li>
				<li>Win by checkmating the enemy king.</li>
				<li>Controls: click to select/move/drop; number keys 1–7 pick a hand piece (歩, 香, 桂, 銀, 金, 角, 飛); U undo; R reset; H rules.</li>
			</ul>
			<button id="close-rules">Close</button>
		</div>
	</div>
</div>

<script>
(() => {
	const ROWS = 9, COLS = 9;
	const WHITE = 1, BLACK = 2;
	const dpr = window.devicePixelRatio || 1;

	const GLYPH = {
		[WHITE]: { K:'王', R:'飛', B:'角', G:'金', S:'銀', N:'桂', L:'香', P:'歩', DR:'龍', DH:'馬', TO:'と', NY:'杏', NK:'圭', NG:'全' },
		[BLACK]: { K:'玉', R:'飛', B:'角', G:'金', S:'銀', N:'桂', L:'香', P:'歩', DR:'龍', DH:'馬', TO:'と', NY:'杏', NK:'圭', NG:'全' }
	};

	const container = document.getElementById('game-container');
	const startOverlay = document.getElementById('start-overlay');
	const btn1p = document.getElementById('btn-1p');
	const btn2p = document.getElementById('btn-2p');
	const btnEasy = document.getElementById('btn-easy');
	const btnMed = document.getElementById('btn-med');
	const btnStartOverlay = document.getElementById('btn-start-overlay');
	const btnRules = document.getElementById('btn-rules');
	const rulesOverlay = document.getElementById('rules-overlay');
	const closeRules = document.getElementById('close-rules');
	const hudBtnStart = document.getElementById('btn-start');
	const hudBtnReset = document.getElementById('btn-reset');
	const hudBtnUndo = document.getElementById('btn-undo');
	const hudBtnHistory = document.getElementById('btn-history');
	const btnHistoryClose = document.getElementById('btn-history-close');
	const historyPanel = document.getElementById('history');
	const turnText = document.getElementById('turn-text');
	const aiText = document.getElementById('ai-text');
	const msgText = document.getElementById('msg-text');
	const lastMoveText = document.getElementById('lastmove-text');
	const handW = document.getElementById('hand-w');
	const handB = document.getElementById('hand-b');
	const moveList = document.getElementById('move-list');

	const boardLayer = document.createElement('canvas');
	const piecesLayer = document.createElement('canvas');
	boardLayer.className = 'layer-board';
	piecesLayer.className = 'layer-pieces';
	container.appendChild(boardLayer);
	container.appendChild(piecesLayer);

	const layout = { width:0, height:0, cell:0, offsetX:0, offsetY:0 };

	const state = {
		board: [],
		turn: WHITE,
		vsAI: true,
		aiColor: BLACK,
		aiDepth: 1,
		gameOver: false,
		history: [],
		lastMove: null,
		lastMoveHighlight: null,
		selected: null,
		moves: [],
		undoStack: [],
		hands: {
			[WHITE]: { P:0, L:0, N:0, S:0, G:0, B:0, R:0 },
			[BLACK]: { P:0, L:0, N:0, S:0, G:0, B:0, R:0 }
		}
	};

	function makePiece(c,t,p=false){ return { c, t, p }; }

	function setupBoard() {
		state.board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
		const back = ['L','N','S','G','K','G','S','N','L'];
		for (let c = 0; c < COLS; c++) state.board[0][c] = makePiece(BLACK, back[c]);
		state.board[1][1] = makePiece(BLACK, 'B');
		state.board[1][7] = makePiece(BLACK, 'R');
		for (let c = 0; c < COLS; c++) state.board[2][c] = makePiece(BLACK, 'P');

		for (let c = 0; c < COLS; c++) state.board[8][c] = makePiece(WHITE, back[c]);
		state.board[7][7] = makePiece(WHITE, 'B');
		state.board[7][1] = makePiece(WHITE, 'R');
		for (let c = 0; c < COLS; c++) state.board[6][c] = makePiece(WHITE, 'P');
		state.hands[WHITE] = { P:0,L:0,N:0,S:0,G:0,B:0,R:0 };
		state.hands[BLACK] = { P:0,L:0,N:0,S:0,G:0,B:0,R:0 };
	}

	function resetGame() {
		setupBoard();
		state.turn = WHITE;
		state.gameOver = false;
		state.history = [];
		state.lastMove = null;
		state.lastMoveHighlight = null;
		state.selected = null;
		state.moves = [];
		state.undoStack = [];
		msgText.textContent = 'Game on';
		updateHud();
		resizeAndRedraw();
		maybeAIMove();
	}

	function cloneBoard(b=state.board){ return b.map(row => row.map(p => p ? { ...p } : null)); }

	function cloneHands(h=state.hands){ return { [WHITE]: { ...h[WHITE] }, [BLACK]: { ...h[BLACK] } }; }

	function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }

	function zone(r, color) { return color === WHITE ? r <= 2 : r >= 6; }

	function lastRank(color){ return color === WHITE ? 0 : ROWS-1; }
	function secondLast(color){ return color === WHITE ? 1 : ROWS-2; }

	function applyMoveToState(mv, board=state.board, hands=state.hands) {
		if (mv.drop) {
			board[mv.tr][mv.tc] = makePiece(mv.color, mv.drop, false);
			hands[mv.color][mv.drop] -= 1;
			return;
		}
		const piece = { ...board[mv.fr][mv.fc] };
		board[mv.fr][mv.fc] = null;
		if (board[mv.tr][mv.tc]) {
			const captured = board[mv.tr][mv.tc];
			const base = captured.t; // drop as unpromoted
			hands[mv.color][base] += 1;
		}
		if (mv.promo) piece.p = true;
		board[mv.tr][mv.tc] = piece;
	}

	function kingPos(b, color) {
		for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
			const p = b[r][c];
			if (p && p.c === color && p.t === 'K') return { r, c };
		}
		return null;
	}

	function attacksFrom(r,c,p,b){
		const moves = [];
		const dir = p.c === WHITE ? -1 : 1;
		const goldD = [[dir,0],[dir,1],[dir,-1],[0,1],[0,-1],[-dir,0]];
		const silverD = [[dir,0],[dir,1],[dir,-1],[-dir,1],[-dir,-1]];
		const kingD = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];

		function slide(drs,dcs){
			for (let i=0;i<drs.length;i++){
				let nr=r+drs[i], nc=c+dcs[i];
				while(inBounds(nr,nc)){
					const t=b[nr][nc];
					moves.push({ r:nr, c:nc });
					if (t) break;
					nr+=drs[i]; nc+=dcs[i];
				}
			}
		}

		if (p.t === 'K') { kingD.forEach(([dr,dc]) => { const nr=r+dr, nc=c+dc; if(inBounds(nr,nc)) moves.push({r:nr,c:nc}); }); return moves; }

		const goldLike = (p.p && ['P','L','N','S'].includes(p.t)) || p.t==='G';
		if (goldLike) { goldD.forEach(([dr,dc]) => { const nr=r+dr,nc=c+dc; if(inBounds(nr,nc)) moves.push({r:nr,c:nc}); }); return moves; }

		if (p.t === 'S' && !p.p) { silverD.forEach(([dr,dc]) => { const nr=r+dr,nc=c+dc; if(inBounds(nr,nc)) moves.push({r:nr,c:nc}); }); return moves; }

		if (p.t === 'N' && !p.p) {
			const jumps = [[2*dir,1],[2*dir,-1]];
			jumps.forEach(([dr,dc]) => { const nr=r+dr,nc=c+dc; if(inBounds(nr,nc)) moves.push({r:nr,c:nc}); });
			return moves;
		}

		if (p.t === 'L' && !p.p) { slide([dir],[0]); return moves; }
		if (p.t === 'P' && !p.p) { const nr=r+dir; if(inBounds(nr,c)) moves.push({r:nr,c}); return moves; }

		if (p.t === 'R') { slide([1,-1,0,0],[0,0,1,-1]); if (p.p) kingD.filter(([dr,dc])=>Math.abs(dr)+Math.abs(dc)===2?false:true).forEach(([dr,dc])=>{const nr=r+dr,nc=c+dc;if(inBounds(nr,nc)) moves.push({r:nr,c:nc});}); return moves; }
		if (p.t === 'B') { slide([1,1,-1,-1],[1,-1,1,-1]); if (p.p) kingD.filter(([dr,dc])=>Math.abs(dr)+Math.abs(dc)===1).forEach(([dr,dc])=>{const nr=r+dr,nc=c+dc;if(inBounds(nr,nc)) moves.push({r:nr,c:nc});}); return moves; }

		return moves;
	}

	function pseudoMovesForPiece(r,c,b){
		const p = b[r][c]; if (!p) return [];
		const moves = attacksFrom(r,c,p,b).filter(({r:rr,c:cc}) => {
			const t = b[rr][cc]; return !t || t.c !== p.c;
		}).map(({r:tr,c:tc}) => ({ fr:r, fc:c, tr, tc }));
		return moves;
	}

	function addPromotionFlag(mv, piece, board){
		const color = piece.c;
		const fr = mv.fr, tr = mv.tr;
		const inPromo = zone(fr, color) || zone(tr, color);
		if (!inPromo) return mv;
		const force = (piece.t==='P' || piece.t==='L') && tr === lastRank(color);
		const forceKnight = piece.t==='N' && (tr === lastRank(color) || tr === secondLast(color));
		const canPromote = piece.t !== 'K' && piece.t !== 'G' && (!piece.p);
		if (canPromote && (force || forceKnight)) { mv.promo = true; return mv; }
		if (canPromote) mv.promo = true; // auto-promote when eligible in zone for simplicity
		return mv;
	}

	function dropMoves(color, board, hands){
		const res = [];
		for (const [ptype,count] of Object.entries(hands[color])) {
			if (!count) continue;
			for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
				if (board[r][c]) continue;
				if (ptype==='P') {
					if (!pawnDropAllowed(color, c, board)) continue;
					if (r === lastRank(color)) continue;
				}
				if (ptype==='L' && r === lastRank(color)) continue;
				if (ptype==='N' && (r === lastRank(color) || r === secondLast(color))) continue;
				res.push({ drop: ptype, tr:r, tc:c, color });
			}
		}
		return res;
	}

	function pawnDropAllowed(color, col, board){
		for (let r=0;r<ROWS;r++) {
			const p = board[r][col];
			if (p && p.c === color && p.t === 'P' && !p.p) return false;
		}
		return true;
	}

	function legalMoves(color, board=state.board, hands=state.hands) {
		const moves = [];
		for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
			const p = board[r][c];
			if (!p || p.c !== color) continue;
			for (const mv of pseudoMovesForPiece(r,c,board)) {
				const move = addPromotionFlag({ ...mv }, p, board);
				const nb = cloneBoard(board);
				const nh = cloneHands(hands);
				applyMoveToState({ ...move, color }, nb, nh);
				if (!isCheck(nb, color)) moves.push({ ...move, color });
			}
		}
		for (const dm of dropMoves(color, board, hands)) {
			const nb = cloneBoard(board); const nh = cloneHands(hands);
			applyMoveToState(dm, nb, nh);
			if (!isCheck(nb, color)) moves.push(dm);
		}
		return moves;
	}

	function isCheck(board, color) {
		const k = kingPos(board, color); if (!k) return true;
		const enemy = color === WHITE ? BLACK : WHITE;
		for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
			const p = board[r][c];
			if (!p || p.c !== enemy) continue;
			const moves = attacksFrom(r,c,p,board);
			if (moves.some(m => m.r===k.r && m.c===k.c)) return true;
		}
		return false;
	}

	function makeMove(mv) {
		state.undoStack.push({
			board: cloneBoard(state.board),
			hands: cloneHands(state.hands),
			turn: state.turn,
			history: [...state.history],
			lastMove: state.lastMove,
			lastMoveHighlight: state.lastMoveHighlight,
			gameOver: state.gameOver
		});

		applyMoveToState(mv, state.board, state.hands);
		state.lastMoveHighlight = mv.drop ? { tr: mv.tr, tc: mv.tc, fr: mv.tr, fc: mv.tc } : { fr: mv.fr, fc: mv.fc, tr: mv.tr, tc: mv.tc };
		const notation = mv.drop ? `Drop ${mv.drop} @ ${fileChar(mv.tc)}${9-mv.tr}` : `${fileChar(mv.fc)}${9-mv.fr}→${fileChar(mv.tc)}${9-mv.tr}${mv.promo ? '+' : ''}`;
		state.history.push(notation);
		state.lastMove = notation;

		state.turn = state.turn === WHITE ? BLACK : WHITE;
		state.selected = null; state.moves = [];

		const opp = state.turn;
		const oppMoves = legalMoves(opp);
		if (!oppMoves.length) {
			const inChk = isCheck(state.board, opp);
			state.gameOver = true;
			msgText.textContent = inChk ? 'Checkmate' : 'No legal moves';
		} else {
			msgText.textContent = isCheck(state.board, opp) ? 'Check' : 'Game on';
		}
		updateHud();
		redrawAll();
		maybeAIMove();
	}

	function fileChar(c){ return String.fromCharCode('a'.charCodeAt(0)+c); }

	function undo() {
		if (!state.undoStack.length) return;
		const snap = state.undoStack.pop();
		state.board = snap.board;
		state.hands = snap.hands;
		state.turn = snap.turn;
		state.history = snap.history;
		state.lastMove = snap.lastMove;
		state.lastMoveHighlight = snap.lastMoveHighlight;
		state.gameOver = snap.gameOver;
		state.selected = null;
		state.moves = [];
		msgText.textContent = 'Undo';
		redrawAll();
		updateHud();
	}

	function aiMove() {
		if (!state.vsAI || state.turn !== state.aiColor || state.gameOver) return;
		const moves = legalMoves(state.aiColor);
		if (!moves.length) return;
		let choice = moves[Math.floor(Math.random()*moves.length)];
		if (state.aiDepth > 1) {
			choice = pickByEval(moves, state.aiColor);
		}
		makeMove(choice);
	}

	function pickByEval(moves, color){
		let best = -Infinity, pick = moves[0];
		for (const mv of moves) {
			const nb = cloneBoard(state.board); const nh = cloneHands(state.hands);
			applyMoveToState({ ...mv }, nb, nh);
			const score = evaluate(nb, nh, color);
			if (score > best) { best = score; pick = mv; }
		}
		return pick;
	}

	function evaluate(b, h, pov){
		const val = { K:10000, R:550, B:520, G:350, S:320, N:300, L:300, P:100 };
		let s = 0;
		for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
			const p = b[r][c]; if(!p) continue;
			const base = val[p.t];
			const bonus = p.p ? 80 : 0;
			s += (p.c===pov?1:-1)*(base+bonus);
		}
		for (const t of Object.keys(h[pov])) s += h[pov][t] * (val[t]/2);
		const opp = pov===WHITE?BLACK:WHITE;
		for (const t of Object.keys(h[opp])) s -= h[opp][t] * (val[t]/2);
		if (isCheck(b, pov===WHITE?BLACK:WHITE)) s += 30;
		return s + (Math.random()-0.5)*5;
	}

	function maybeAIMove() {
		if (state.vsAI && state.turn === state.aiColor && !state.gameOver) {
			setTimeout(aiMove, 120);
		}
	}

	function coordsFromEvent(evt) {
		const rect = container.getBoundingClientRect();
		const x = (evt.clientX - rect.left) * dpr;
		const y = (evt.clientY - rect.top) * dpr;
		const col = Math.floor((x - layout.offsetX*dpr) / (layout.cell*dpr));
		const row = Math.floor((y - layout.offsetY*dpr) / (layout.cell*dpr));
		return { row, col };
	}

	function handleClick(evt) {
		if (state.gameOver || startOverlay.style.display !== 'none') return;
		const { row, col } = coordsFromEvent(evt);
		if (!inBounds(row,col)) return;
		const piece = state.board[row][col];

		if (state.selected && state.selected.hand) {
			const mv = state.moves.find(m => m.drop && m.tr===row && m.tc===col);
			if (mv) { makeMove(mv); return; }
			state.selected = null; state.moves = []; redrawPieces(); return;
		}

		if (state.selected && !state.selected.hand) {
			const mv = state.moves.find(m => !m.drop && m.tr===row && m.tc===col);
			if (mv) { makeMove(mv); return; }
			state.selected = null; state.moves = []; redrawPieces(); return;
		}

		if (piece && piece.c === state.turn && (!state.vsAI || piece.c !== state.aiColor)) {
			state.selected = { r:row, c:col };
			state.moves = legalMoves(state.turn).filter(m => !m.drop && m.fr===row && m.fc===col);
		} else {
			// check hand selection: click HUD? simplest: right now only board selection; so deselect
			state.selected = null; state.moves = [];
		}
		redrawPieces();
	}

	// Hand selection via keyboard numbers: 1-7 for P,L,N,S,G,B,R for current player
	window.addEventListener('keyup', e => {
		const map = { '1':'P','2':'L','3':'N','4':'S','5':'G','6':'B','7':'R' };
		if (map[e.key]) {
			const t = map[e.key];
			if (state.hands[state.turn][t] > 0 && (!state.vsAI || state.turn !== state.aiColor)) {
				state.selected = { hand:true, t };
				state.moves = dropMoves(state.turn, state.board, state.hands).filter(m => m.drop===t);
				redrawPieces();
			}
		}
	});

	function updateHud() {
		turnText.textContent = `Turn: ${state.turn === WHITE ? 'White' : 'Black'}`;
		aiText.textContent = state.vsAI ? `AI: ${state.aiColor === WHITE ? 'White' : 'Black'} (${state.aiDepth === 1 ? 'Easy' : 'Medium'})` : 'AI: Off';
		lastMoveText.textContent = state.lastMove ? `Last: ${state.lastMove}` : 'Last: --';
		handW.textContent = `White hand: ${handStr(WHITE)}`;
		handB.textContent = `Black hand: ${handStr(BLACK)}`;
	}

	function handStr(color){
		const h = state.hands[color];
		const parts = [];
		for (const [k,v] of Object.entries(h)) if (v>0) parts.push(`${k}x${v}`);
		return parts.length ? parts.join(' ') : '--';
	}

	function pushHistory(statusText) {
		moveList.innerHTML = '';
		state.history.forEach((m, i) => {
			const div = document.createElement('div');
			div.className = 'move-line';
			div.textContent = `${i+1}. ${m}`;
			moveList.appendChild(div);
		});
		msgText.textContent = statusText;
	}

	function resize() {
		layout.width = container.clientWidth;
		layout.height = container.clientHeight;
		const size = Math.min(layout.width, layout.height) * 0.9;
		layout.cell = size / COLS;
		layout.offsetX = (layout.width - size) / 2;
		layout.offsetY = (layout.height - size) / 2;
		[boardLayer, piecesLayer].forEach(layer => {
			layer.width = layout.width * dpr;
			layer.height = layout.height * dpr;
			layer.style.width = layout.width + 'px';
			layer.style.height = layout.height + 'px';
			const ctx = layer.getContext('2d');
			ctx.setTransform(dpr,0,0,dpr,0,0);
		});
	}

	function drawBoard() {
		const ctx = boardLayer.getContext('2d');
		ctx.clearRect(0,0,layout.width, layout.height);
		for (let r=0;r<ROWS;r++) {
			for (let c=0;c<COLS;c++) {
				const light = (r+c)%2===0;
				ctx.fillStyle = light ? '#f0e2c3' : '#d2b48c';
				ctx.fillRect(layout.offsetX + c*layout.cell, layout.offsetY + r*layout.cell, layout.cell, layout.cell);
			}
		}
		ctx.strokeStyle = 'rgba(0,0,0,0.35)';
		ctx.lineWidth = 1;
		for (let i=0;i<=ROWS;i++) {
			const x = layout.offsetX + i*layout.cell;
			ctx.beginPath();
			ctx.moveTo(layout.offsetX, layout.offsetY + i*layout.cell);
			ctx.lineTo(layout.offsetX + layout.cell*COLS, layout.offsetY + i*layout.cell);
			ctx.moveTo(x, layout.offsetY);
			ctx.lineTo(x, layout.offsetY + layout.cell*ROWS);
			ctx.stroke();
		}
		if (state.lastMoveHighlight) {
			ctx.fillStyle = 'rgba(88,198,255,0.2)';
			const { fr, fc, tr, tc } = state.lastMoveHighlight;
			ctx.fillRect(layout.offsetX + fc*layout.cell, layout.offsetY + fr*layout.cell, layout.cell, layout.cell);
			ctx.fillRect(layout.offsetX + tc*layout.cell, layout.offsetY + tr*layout.cell, layout.cell, layout.cell);
		}
	}

	function redrawPieces() {
		const ctx = piecesLayer.getContext('2d');
		ctx.clearRect(0,0,layout.width, layout.height);
		ctx.textAlign = 'center';
		ctx.textBaseline = 'middle';
		for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
			const p = state.board[r][c]; if (!p) continue;
			ctx.save();
			ctx.translate(layout.offsetX + c*layout.cell + layout.cell/2, layout.offsetY + r*layout.cell + layout.cell/2);
			if (p.c === BLACK) ctx.rotate(Math.PI);
			const isWhite = p.c === WHITE;
			const w = layout.cell*0.78, h = layout.cell*0.7;
			const body = ctx.createLinearGradient(0, -h/2, 0, h/2);
			if (isWhite) { body.addColorStop(0, '#f6e8cc'); body.addColorStop(1, '#d7c09a'); }
			else { body.addColorStop(0, '#1f1f1f'); body.addColorStop(1, '#2e2a26'); }
			ctx.beginPath();
			ctx.moveTo(-w/2, h/2);
			ctx.lineTo(-w/2, -h/2);
			ctx.lineTo(0, -h/2 - h*0.14);
			ctx.lineTo(w/2, -h/2);
			ctx.lineTo(w/2, h/2);
			ctx.closePath();
			ctx.fillStyle = body;
			ctx.strokeStyle = isWhite ? '#3f2b12' : '#c7a56a';
			ctx.lineWidth = 2.2;
			ctx.shadowColor = 'rgba(0,0,0,0.35)';
			ctx.shadowBlur = 8;
			ctx.fill();
			ctx.shadowBlur = 0;
			ctx.stroke();
			const inset = ctx.createLinearGradient(0, -h/2, 0, h/2);
			if (isWhite) { inset.addColorStop(0, 'rgba(255,255,255,0.65)'); inset.addColorStop(1, 'rgba(255,255,255,0.1)'); }
			else { inset.addColorStop(0, 'rgba(255,255,255,0.2)'); inset.addColorStop(1, 'rgba(255,255,255,0.05)'); }
			ctx.fillStyle = inset;
			ctx.fill();
			ctx.fillStyle = isWhite ? '#1b130b' : '#f7f1e8';
			ctx.font = `${layout.cell * 0.44}px "Yu Mincho", "Noto Sans JP", "Meiryo", "Segoe UI"`;
			function glyphFor(piece){
				if (!piece.p) return GLYPH[piece.c][piece.t];
				if (piece.t === 'R') return GLYPH[piece.c].DR;
				if (piece.t === 'B') return GLYPH[piece.c].DH;
				if (piece.t === 'P') return GLYPH[piece.c].TO;
				if (piece.t === 'L') return GLYPH[piece.c].NY;
				if (piece.t === 'N') return GLYPH[piece.c].NK;
				if (piece.t === 'S') return GLYPH[piece.c].NG;
				return GLYPH[piece.c][piece.t];
			}
			ctx.fillText(glyphFor(p), 0, layout.cell*0.02);
			if (p.p) {
				ctx.fillStyle = '#c1121f';
				ctx.font = `${layout.cell * 0.26}px "Yu Mincho", "Noto Sans JP", "Meiryo", "Segoe UI"`;
				ctx.fillText('成', 0, -h*0.22);
				ctx.fillRect(-w*0.28, -h*0.06, w*0.56, h*0.08);
			}
			ctx.restore();
		}
		if (state.selected) {
			ctx.strokeStyle = 'rgba(249,115,22,0.95)';
			ctx.lineWidth = 3;
			if (!state.selected.hand) {
				ctx.strokeRect(layout.offsetX + state.selected.c*layout.cell + 2, layout.offsetY + state.selected.r*layout.cell + 2, layout.cell-4, layout.cell-4);
			}
			ctx.fillStyle = 'rgba(249,115,22,0.3)';
			for (const mv of state.moves) {
				ctx.beginPath();
				ctx.arc(layout.offsetX + mv.tc*layout.cell + layout.cell/2, layout.offsetY + mv.tr*layout.cell + layout.cell/2, layout.cell*0.18, 0, Math.PI*2);
				ctx.fill();
			}
		}
	}

	function redrawAll() { drawBoard(); redrawPieces(); pushHistory(msgText.textContent); }
	function resizeAndRedraw() { resize(); redrawAll(); }

	function bindUI() {
		container.addEventListener('click', handleClick);
		window.addEventListener('resize', resizeAndRedraw);
		window.addEventListener('keyup', e => {
			if (e.key === 'u' || e.key === 'U') undo();
			if (e.key === 'r' || e.key === 'R') resetGame();
			if (e.key === 'h' || e.key === 'H') rulesOverlay.classList.add('show');
		});

		btn1p.addEventListener('click', () => { state.vsAI = true; state.aiColor = BLACK; toggleSelect(btn1p, btn2p); });
		btn2p.addEventListener('click', () => { state.vsAI = false; toggleSelect(btn2p, btn1p); });
		btnEasy.addEventListener('click', () => { state.aiDepth = 1; setDiff(btnEasy); });
		btnMed.addEventListener('click', () => { state.aiDepth = 2; setDiff(btnMed); });
		btnStartOverlay.addEventListener('click', () => { startOverlay.style.display = 'none'; resetGame(); });

		hudBtnStart.addEventListener('click', resetGame);
		hudBtnReset.addEventListener('click', resetGame);
		hudBtnUndo.addEventListener('click', undo);
		btnRules.addEventListener('click', () => rulesOverlay.classList.add('show'));
		closeRules.addEventListener('click', () => rulesOverlay.classList.remove('show'));

		hudBtnHistory.addEventListener('click', () => historyPanel.classList.toggle('show'));
		btnHistoryClose.addEventListener('click', () => historyPanel.classList.remove('show'));
	}

	function toggleSelect(on, off) { on.classList.remove('secondary'); off.classList.add('secondary'); }
	function setDiff(btn) { [btnEasy, btnMed].forEach(b => b.classList.remove('active')); btn.classList.add('active'); }

	setupBoard();
	resize();
	redrawAll();
	bindUI();
})();
</script>
</body>
</html>
