<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Petteia</title>
	<style>
		:root {
			--bg: #0c0f16;
			--panel: #141a26;
			--panel-2: #0f1623;
			--accent: #58c6ff;
			--accent-2: #ffc857;
			--text: #f5f7fb;
			--muted: #9aa7bd;
			--board-a: #2d3040;
			--board-b: #3d4154;
		}
		* { box-sizing: border-box; }
		html, body { margin: 0; padding: 0; width: 100%; height: 100%; }
		body {
			background: radial-gradient(circle at 20% 20%, #121828, var(--bg) 42%);
			font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
			color: var(--text);
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 0;
			overflow: hidden;
		}
		#app {
			width: 100%;
			height: 100vh;
			max-width: 1500px;
			background: var(--panel);
			border: 1px solid rgba(255,255,255,0.06);
			border-radius: 16px;
			overflow: hidden;
			box-shadow: 0 20px 60px rgba(0,0,0,0.35);
			display: flex;
			flex-direction: column;
			margin: 0 auto;
		}
		header {
			position: sticky;
			top: 0;
			z-index: 5;
			padding: 16px 18px 10px;
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			background: linear-gradient(90deg, rgba(88,198,255,0.16), transparent);
			border-bottom: 1px solid rgba(255,255,255,0.06);
			box-shadow: 0 10px 30px rgba(0,0,0,0.35);
		}
		header h1 { margin: 0; font-size: 20px; letter-spacing: 0.4px; color: var(--accent-2); }
		header .subtitle { margin: 0; color: var(--muted); font-size: 13px; }
		.row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
		button {
			border: none;
			border-radius: 8px;
			padding: 10px 12px;
			font-size: 14px;
			cursor: pointer;
			background: var(--accent);
			color: #0c0f16;
			transition: transform 0.1s ease, box-shadow 0.2s ease;
		}
		button.secondary { background: rgba(255,255,255,0.12); color: var(--text); }
		button.alt { background: var(--accent-2); color: #0c0f16; }
		button:disabled { opacity: 0.5; cursor: not-allowed; }
		button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 10px 22px rgba(0,0,0,0.25); }
		main {
			display: grid;
			grid-template-columns: minmax(0,1fr) 320px;
			gap: 0;
			flex: 1;
			min-height: 0;
			overflow: hidden;
		}
		#board-wrapper {
			position: relative;
			padding: 18px;
			background: #0d121d;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			min-height: 0;
			overflow: hidden;
		}
		#canvas-stack { position: relative; width: 100%; height: 100%; }
		canvas {
			position: absolute;
			inset: 0;
			width: 100%;
			height: 100%;
			display: block;
			border-radius: 10px;
			box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05);
		}
		.layer-board { z-index: 0; pointer-events: none; }
		.layer-pieces { z-index: 1; pointer-events: none; }
		.layer-ui { z-index: 2; }
		#ui-panel {
			padding: 18px 18px 24px;
			border-left: 1px solid rgba(255,255,255,0.06);
			background: rgba(10,14,24,0.78);
			height: 100%;
			overflow-y: auto;
			min-height: 0;
		}
		.section { margin-bottom: 16px; padding: 12px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06); border-radius: 10px; }
		.section h3 { margin: 0 0 8px; font-size: 14px; letter-spacing: 0.6px; color: var(--muted); text-transform: uppercase; }
		.pill { padding: 9px 12px; border-radius: 999px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); font-size: 13px; display: inline-flex; align-items: center; gap: 6px; }
		.status-box { padding: 10px 12px; border-radius: 10px; background: rgba(88,198,255,0.1); border: 1px solid rgba(88,198,255,0.2); font-size: 14px; }
		label { font-size: 13px; color: var(--muted); display: block; margin-top: 6px; }
		.stat-line { margin: 4px 0; color: var(--muted); font-size: 13px; }
		.history-panel { position: relative; max-height: 260px; overflow-y: auto; font-family: monospace; font-size: 12px; display: none; }
		.history-panel.show { display: block; }
		.history-panel .move-line { margin: 2px 0; }
		.history-close { position: absolute; top: 6px; right: 6px; padding: 4px 8px; border: none; border-radius: 6px; background: rgba(255,255,255,0.12); color: var(--text); cursor: pointer; font-size: 11px; }
		@media (max-width: 1040px) {
			main { display: flex; flex-direction: column; }
			#board-wrapper { flex: 1 1 auto; min-height: 60vh; }
			#ui-panel { border-left: none; border-top: 1px solid rgba(255,255,255,0.06); height: auto; max-height: 38vh; }
		}
		@media (max-width: 760px) {
			#board-wrapper { padding: 10px; min-height: 62vh; }
			header { flex-direction: column; align-items: flex-start; padding: 14px 14px 10px; }
			header h1 { font-size: 18px; }
		}
		.overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(8,10,16,0.82); backdrop-filter: blur(4px); z-index: 20; }
		#rules-overlay { display: none; }
		#rules-overlay.show { display: flex; }
		.dialog { background: var(--panel-2); border: 1px solid rgba(255,255,255,0.08); padding: 20px; border-radius: 12px; width: min(540px, 92%); box-shadow: 0 16px 50px rgba(0,0,0,0.35); }
		.dialog h2 { margin: 0 0 8px; }
		.dialog p { margin: 4px 0; color: var(--muted); line-height: 1.6; font-size: 14px; }
		.options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 12px 0; }
		.option-active { outline: 2px solid var(--accent); outline-offset: 1px; }
		#history-overlay .dialog { width: min(600px, 92%); }
		#start-overlay { display: flex; }
	</style>
</head>
<body>
	<div id="app">
		<header>
			<div>
				<h1>Petteia</h1>
				<p class="subtitle">8x8 custodial capture battle</p>
			</div>
			<div class="row">
				<button class="secondary" id="top-start">Start</button>
				<button class="secondary" id="top-reset">Reset</button>
				<button class="secondary" id="top-rules">Rules</button>
			</div>
		</header>
		<main>
			<div id="board-wrapper">
				<div id="canvas-stack">
					<canvas id="board-layer" class="layer-board"></canvas>
					<canvas id="pieces-layer" class="layer-pieces"></canvas>
					<canvas id="ui-layer" class="layer-ui"></canvas>
				</div>
			</div>
			<div id="ui-panel">
				<div class="section">
					<h3>Status</h3>
					<div id="msg-text" class="status-box">Ready</div>
					<p id="turn-text" class="stat-line">Turn: --</p>
					<p id="ai-text" class="stat-line">AI: --</p>
					<p id="cap-text" class="stat-line">Captured W:0 B:0</p>
					<p id="lastmove-text" class="stat-line">Last: --</p>
				</div>
				<div class="section">
					<h3>Actions</h3>
					<div class="row" style="gap:8px; flex-wrap:wrap;">
						<button id="btn-start" class="secondary">New Game</button>
						<button id="btn-reset" class="secondary">Reset</button>
						<button id="btn-undo" class="secondary">Undo</button>
						<button id="btn-history" class="secondary">History</button>
						<button id="btn-rules" class="secondary">Rules</button>
					</div>
				</div>
				<div class="section">
					<h3>Moves</h3>
					<div id="history" class="history-panel">
						<button id="btn-history-close" class="history-close">Close</button>
						<div id="move-list"></div>
					</div>
				</div>
			</div>
		</main>
	</div>

	<div id="start-overlay" class="overlay">
		<div class="dialog">
			<h2>Start Game</h2>
			<p>Choose how to play, set difficulty, then start.</p>
			<div class="options">
				<button id="btn-1p">1 Player (vs AI)</button>
				<button id="btn-2p" class="secondary">2 Players</button>
			</div>
			<label>AI Difficulty</label>
			<div class="options" style="grid-template-columns: repeat(3, 1fr);">
				<button id="btn-easy" class="secondary">Easy</button>
				<button id="btn-med">Medium</button>
				<button id="btn-hard" class="secondary">Hard</button>
			</div>
			<div class="row" style="margin-top:12px; justify-content:flex-end;">
				<button id="btn-start-overlay" style="min-width:160px;" class="alt">Start</button>
			</div>
		</div>
	</div>

	<div id="rules-overlay" class="overlay">
		<div class="dialog">
			<h2>Rules</h2>
			<ul style="margin: 8px 0 0 18px; padding:0; color: var(--muted); line-height:1.5;">
				<li>Board: 8x8. Each side starts with 16 stones on their two closest ranks.</li>
				<li>Move: one piece any number of empty squares orthogonally (rook-like, no jumping).</li>
				<li>Capture: custodial. After moving, any adjacent enemy with your stone immediately on the opposite side is captured. Multiple captures possible.</li>
				<li>Goal: capture all opposing stones.</li>
				<li>Controls: click squares; arrows + Enter/Space; U undo; R reset; H rules.</li>
			</ul>
			<div class="row" style="margin-top:12px; justify-content:flex-end;">
				<button id="close-rules" class="secondary">Close</button>
			</div>
		</div>
	</div>

<script>
(function() {
	const LIGHT = 1;
	const DARK = 2;
	const dpr = window.devicePixelRatio || 1;
	const COLS = 8;
	const ROWS = 8;
	const PIECE_VALUES = { S: 1 };

	const boardWrapper = document.getElementById("board-wrapper");
	const startOverlay = document.getElementById("start-overlay");
	const btn1p = document.getElementById("btn-1p");
	const btn2p = document.getElementById("btn-2p");
	const btnEasy = document.getElementById("btn-easy");
	const btnMed = document.getElementById("btn-med");
	const btnHard = document.getElementById("btn-hard");
	const btnStartOverlay = document.getElementById("btn-start-overlay");
	const btnRules = document.getElementById("btn-rules");
	const rulesOverlay = document.getElementById("rules-overlay");
	const closeRules = document.getElementById("close-rules");
	const topStart = document.getElementById("top-start");
	const topReset = document.getElementById("top-reset");
	const topRules = document.getElementById("top-rules");
	const hudBtnStart = document.getElementById("btn-start");
	const hudBtnReset = document.getElementById("btn-reset");
	const hudBtnUndo = document.getElementById("btn-undo");
	const hudBtnHistory = document.getElementById("btn-history");
	const btnHistoryClose = document.getElementById("btn-history-close");
	const historyPanel = document.getElementById("history");
	const turnText = document.getElementById("turn-text");
	const aiText = document.getElementById("ai-text");
	const msgText = document.getElementById("msg-text");
	const capText = document.getElementById("cap-text");
	const lastMoveText = document.getElementById("lastmove-text");
	const moveList = document.getElementById("move-list");

	const boardLayer = document.getElementById("board-layer");
	const piecesLayer = document.getElementById("pieces-layer");
	const uiLayer = document.getElementById("ui-layer");

	const layout = { width: 0, height: 0, cell: 0, offsetX: 0, offsetY: 0 };

	const state = {
		board: createEmpty(),
		turn: LIGHT,
		moveHistory: [],
		lastMove: null,
		captures: { [LIGHT]: 0, [DARK]: 0 },
		gameOver: false,
		winner: null,
		message: "",
		cursor: { x: 3, y: 7 },
		selected: null,
		legal: [],
		aiEnabled: true,
		aiColor: DARK,
		aiLevel: "medium",
		thinking: false,
		menuActive: true
	};

	let selectedMode = "1p";
	let selectedDiff = "medium";

	function createEmpty() { return Array.from({ length: ROWS }, () => Array(COLS).fill(null)); }
	function p(type, color) { return { type, color }; }
	function onBoard(x, y) { return x >= 0 && x < COLS && y >= 0 && y < ROWS; }

	function resetBoard() {
		state.board = createEmpty();
		for (let y = ROWS - 2; y < ROWS; y++) for (let x = 0; x < COLS; x++) state.board[y][x] = p("S", LIGHT);
		for (let y = 0; y < 2; y++) for (let x = 0; x < COLS; x++) state.board[y][x] = p("S", DARK);
		state.turn = LIGHT;
		state.moveHistory = [];
		state.lastMove = null;
		state.captures = { [LIGHT]: 0, [DARK]: 0 };
		state.gameOver = false;
		state.winner = null;
		state.message = "";
		state.selected = null;
		state.legal = [];
		state.cursor = { x: 3, y: 7 };
		updateHud();
	}

	function resize() {
		const rect = boardWrapper.getBoundingClientRect();
		layout.width = rect.width;
		layout.height = rect.height;
		[boardLayer, piecesLayer, uiLayer].forEach(c => {
			c.width = layout.width * dpr;
			c.height = layout.height * dpr;
			c.style.width = `${layout.width}px`;
			c.style.height = `${layout.height}px`;
			const ctx = c.getContext("2d");
			ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
		});
		const size = Math.min(layout.width * 0.94, layout.height * 0.94);
		layout.cell = size / Math.max(COLS, ROWS);
		layout.offsetX = (layout.width - layout.cell * COLS) / 2;
		layout.offsetY = (layout.height - layout.cell * ROWS) / 2;
		render();
	}

	function drawBoard(ctx) {
		ctx.clearRect(0, 0, layout.width, layout.height);
		ctx.fillStyle = "#0c0d11";
		ctx.fillRect(0, 0, layout.width, layout.height);
		for (let y = 0; y < ROWS; y++) {
			for (let x = 0; x < COLS; x++) {
				const even = (x + y) % 2 === 0;
				ctx.fillStyle = even ? "#2d3040" : "#3d4154";
				ctx.fillRect(layout.offsetX + x * layout.cell, layout.offsetY + y * layout.cell, layout.cell, layout.cell);
			}
		}
	}

	function drawPieces(ctx) {
		ctx.clearRect(0, 0, layout.width, layout.height);
		ctx.font = `${layout.cell * 0.5}px sans-serif`;
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		for (let y = 0; y < ROWS; y++) {
			for (let x = 0; x < COLS; x++) {
				const piece = state.board[y][x];
				if (!piece) continue;
				const cx = layout.offsetX + x * layout.cell + layout.cell / 2;
				const cy = layout.offsetY + y * layout.cell + layout.cell / 2;
				ctx.fillStyle = piece.color === LIGHT ? "#f5f5f7" : "#0f121b";
				ctx.strokeStyle = piece.color === LIGHT ? "#1d1f2a" : "#6ab0ff";
				ctx.lineWidth = 2.5;
				ctx.beginPath();
				ctx.arc(cx, cy, layout.cell * 0.36, 0, Math.PI * 2);
				ctx.fill();
				ctx.stroke();
				ctx.fillStyle = piece.color === LIGHT ? "#111" : "#f5f5f7";
				ctx.fillText(piece.type, cx, cy + layout.cell * 0.02);
			}
		}

		const ui = uiLayer.getContext("2d");
		ui.clearRect(0, 0, layout.width, layout.height);
		if (state.selected) {
			drawCellOutline(ui, state.selected.x, state.selected.y, "#58c6ff", 3);
			state.legal.forEach(m => drawCellOutline(ui, m.x, m.y, "#ffd166", 2));
		}
		if (state.lastMove) {
			drawCellOutline(ui, state.lastMove.from.x, state.lastMove.from.y, "#7ed0ff", 2);
			drawCellOutline(ui, state.lastMove.to.x, state.lastMove.to.y, "#7ed0ff", 2);
		}
		drawCellOutline(ui, state.cursor.x, state.cursor.y, "#58c6ff", 1.5, true);
	}

	function drawCellOutline(ctx, x, y, color, w, dashed=false) {
		const scrX = layout.offsetX + x * layout.cell;
		const scrY = layout.offsetY + y * layout.cell;
		ctx.save();
		if (dashed) ctx.setLineDash([6,4]);
		ctx.strokeStyle = color;
		ctx.lineWidth = w;
		ctx.strokeRect(scrX + 2, scrY + 2, layout.cell - 4, layout.cell - 4);
		ctx.restore();
	}

	function genMovesFor(x, y, board) {
		const piece = board[y][x];
		if (!piece) return [];
		const moves = [];
		const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
		for (const [dx, dy] of dirs) {
			let nx = x + dx, ny = y + dy;
			while (onBoard(nx, ny) && !board[ny][nx]) {
				moves.push({ x: nx, y: ny });
				nx += dx; ny += dy;
			}
		}
		return moves;
	}

	function clickCell(x, y) {
		if (state.menuActive || state.gameOver) return;
		const piece = state.board[y][x];
		if (state.selected) {
			const isLegal = state.legal.some(m => m.x === x && m.y === y);
			if (isLegal) {
				makeMove(state.selected.x, state.selected.y, x, y);
				state.selected = null;
				state.legal = [];
				return;
			}
		}
		if (piece && piece.color === state.turn) {
			state.selected = { x, y };
			state.legal = genMovesFor(x, y, state.board);
			state.cursor = { x, y };
			state.message = "";
		} else {
			state.selected = null;
			state.legal = [];
		}
		updateHud();
		render();
	}

	function makeMove(fx, fy, tx, ty) {
		if (state.gameOver) return;
		const piece = state.board[fy][fx];
		if (!piece) return;
		const target = state.board[ty][tx];
		const move = { from: { x: fx, y: fy }, to: { x: tx, y: ty }, piece: { ...piece }, captured: [] };
		state.board[fy][fx] = null;
		state.board[ty][tx] = piece;
		if (target) move.captured.push({ x: tx, y: ty, piece: { ...target } });

		const caps = checkCaptures(tx, ty, piece.color);
		for (const c of caps) {
			move.captured.push({ x: c.x, y: c.y, piece: { ...state.board[c.y][c.x] } });
			state.captures[piece.color] += PIECE_VALUES[state.board[c.y][c.x].type] || 1;
			state.board[c.y][c.x] = null;
		}

		state.moveHistory.push(move);
		state.lastMove = move;

		if (pieceCount(oppColor(piece.color)) === 0) {
			state.gameOver = true;
			state.winner = piece.color === LIGHT ? "White" : "Black";
			state.message = "All stones captured";
			updateHud();
			render();
			return;
		}

		state.turn = oppColor(piece.color);
		state.message = "";
		updateHud();
		render();
		maybeRunAI();
	}

	function checkCaptures(x, y, color) {
		const res = [];
		const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
		for (const [dx, dy] of dirs) {
			const nx = x + dx, ny = y + dy;
			const bx = nx + dx, by = ny + dy;
			if (!onBoard(nx, ny)) continue;
			const enemy = state.board[ny][nx];
			if (!enemy || enemy.color === color) continue;
			if (onBoard(bx, by) && state.board[by][bx] && state.board[by][bx].color === color) {
				res.push({ x: nx, y: ny });
			}
		}
		return res;
	}

	function pieceCount(color) {
		let c = 0;
		for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) if (state.board[y][x] && state.board[y][x].color === color) c++;
		return c;
	}

	function oppColor(c) { return c === LIGHT ? DARK : LIGHT; }

	function undo() {
		const mv = state.moveHistory.pop();
		if (!mv) return;
		state.board[mv.from.y][mv.from.x] = { ...mv.piece };
		state.board[mv.to.y][mv.to.x] = null;
		for (const cap of mv.captured) {
			state.board[cap.y][cap.x] = { ...cap.piece };
			state.captures[mv.piece.color] -= PIECE_VALUES[cap.piece.type] || 1;
		}
		state.turn = mv.piece.color;
		state.lastMove = state.moveHistory[state.moveHistory.length - 1] || null;
		state.gameOver = false;
		state.winner = null;
		updateHud();
		render();
	}

	function moveCursor(dx, dy) {
		state.cursor.x = Math.max(0, Math.min(COLS - 1, state.cursor.x + dx));
		state.cursor.y = Math.max(0, Math.min(ROWS - 1, state.cursor.y + dy));
	}

	function listMovesForColor(color) {
		const moves = [];
		for (let y = 0; y < ROWS; y++) {
			for (let x = 0; x < COLS; x++) {
				const pc = state.board[y][x];
				if (!pc || pc.color !== color) continue;
				const legal = genMovesFor(x, y, state.board);
				for (const m of legal) moves.push({ from: { x, y }, to: m, piece: pc });
			}
		}
		return moves;
	}

	function aiChooseMove() {
		const moves = listMovesForColor(state.aiColor);
		if (!moves.length) return null;
		if (state.aiLevel === "easy") return moves[Math.floor(Math.random() * moves.length)];
		let best = -Infinity;
		const scored = [];
		for (const mv of moves) {
			const temp = cloneBoard(state.board);
			applyMoveTemp(temp, mv.from.x, mv.from.y, mv.to.x, mv.to.y, state.aiColor);
			let score = countCaptures(temp, state.aiColor) - countCaptures(temp, oppColor(state.aiColor));
			score += Math.random() * 0.05;
			best = Math.max(best, score);
			scored.push({ mv, score });
		}
		const bestMoves = scored.filter(s => s.score >= best - 0.001).map(s => s.mv);
		return bestMoves[Math.floor(Math.random() * bestMoves.length)];
	}

	function cloneBoard(b) { return b.map(row => row.map(p => p ? { ...p } : null)); }

	function applyMoveTemp(board, fx, fy, tx, ty, color) {
		const piece = board[fy][fx];
		board[fy][fx] = null;
		const captured = [];
		board[ty][tx] = piece;
		const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
		for (const [dx, dy] of dirs) {
			const nx = tx + dx, ny = ty + dy;
			const bx = nx + dx, by = ny + dy;
			if (!onBoard(nx, ny)) continue;
			const enemy = board[ny][nx];
			if (!enemy || enemy.color === color) continue;
			if (onBoard(bx, by) && board[by][bx] && board[by][bx].color === color) {
				captured.push({ x: nx, y: ny });
			}
		}
		captured.forEach(c => board[c.y][c.x] = null);
		return captured.length;
	}

	function countCaptures(board, color) {
		let sum = 0;
		for (let y = 0; y < ROWS; y++) {
			for (let x = 0; x < COLS; x++) {
				const pc = board[y][x];
				if (!pc || pc.color !== color) continue;
				const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
				for (const [dx, dy] of dirs) {
					const nx = x + dx, ny = y + dy;
					const bx = nx + dx, by = ny + dy;
					if (!onBoard(nx, ny) || !onBoard(bx, by)) continue;
					const enemy = board[ny][nx];
					if (enemy && enemy.color !== color && board[by][bx] && board[by][bx].color === color) sum++;
				}
			}
		}
		return sum;
	}

	function maybeRunAI() {
		if (!state.aiEnabled || state.menuActive || state.gameOver || state.turn !== state.aiColor || state.thinking) return;
		state.thinking = true;
		setTimeout(() => {
			const mv = aiChooseMove();
			if (mv) makeMove(mv.from.x, mv.from.y, mv.to.x, mv.to.y);
			state.thinking = false;
			updateHud();
		}, state.aiLevel === "hard" ? 140 : state.aiLevel === "medium" ? 200 : 260);
	}

	function renderHistory() {
		const sq = (x, y) => `${String.fromCharCode(97 + x)}${ROWS - y}`;
		moveList.innerHTML = state.moveHistory.map((mv, i) => {
			const caps = mv.captured && mv.captured.length ? ` x${mv.captured.length}` : "";
			return `<div class="move-line">${i + 1}. ${sq(mv.from.x, mv.from.y)}-${sq(mv.to.x, mv.to.y)}${caps}</div>`;
		}).join("");
	}

	function toggleHistory(force) { const show = force !== undefined ? force : !historyPanel.classList.contains("show"); historyPanel.classList.toggle("show", show); }
	function toggleRules(force) { const show = force !== undefined ? force : !rulesOverlay.classList.contains("show"); rulesOverlay.classList.toggle("show", show); }
	function showStartOverlay() { startOverlay.style.display = "flex"; state.menuActive = true; setBoardInput(false); }
	function setBoardInput(enabled) { uiLayer.style.pointerEvents = enabled ? "auto" : "none"; }

	function handlePointer(e) {
		if (state.menuActive) return;
		const rect = uiLayer.getBoundingClientRect();
		const mx = e.clientX - rect.left;
		const my = e.clientY - rect.top;
		const x = Math.floor((mx - layout.offsetX) / layout.cell);
		const y = Math.floor((my - layout.offsetY) / layout.cell);
		if (!onBoard(x, y)) return;
		state.cursor = { x, y };
		clickCell(x, y);
	}

	function handleKey(e) {
		const key = e.key.toLowerCase();
		if (rulesOverlay.classList.contains("show")) { if (["h","escape","enter"," "].includes(key)) toggleRules(false); return; }
		if (state.menuActive) {
			if (key === "1") { selectedMode = "1p"; applyModeUI(); }
			else if (key === "2") { selectedMode = "2p"; applyModeUI(); }
			else if (key === "arrowup" || key === "w") { cycleDiff(-1); }
			else if (key === "arrowdown" || key === "s") { cycleDiff(1); }
			else if (key === "enter" || key === " ") { startSelected(); }
			return;
		}
		if (key === "arrowup") moveCursor(0, -1);
		else if (key === "arrowdown") moveCursor(0, 1);
		else if (key === "arrowleft") moveCursor(-1, 0);
		else if (key === "arrowright") moveCursor(1, 0);
		else if (key === "enter" || key === " ") { clickCell(state.cursor.x, state.cursor.y); }
		else if (key === "escape") { state.selected = null; state.legal = []; state.message = ""; }
		else if (key === "u") { undo(); }
		else if (key === "r") { resetBoard(); render(); updateHud(); }
		else if (key === "h") { toggleRules(); }
		updateHud();
		render();
		maybeRunAI();
	}

	function updateHud() {
		turnText.textContent = `Turn: ${state.turn === LIGHT ? "WHITE" : "BLACK"}`;
		aiText.textContent = state.aiEnabled ? `AI: ${state.aiLevel.toUpperCase()} (${state.aiColor === LIGHT ? "WHITE" : "BLACK"})` : "AI: OFF";
		msgText.textContent = state.gameOver ? `${state.winner || ""}` : (state.message || "Ready");
		capText.textContent = `Captured W:${state.captures[LIGHT]} B:${state.captures[DARK]}`;
		if (state.lastMove) {
			const { from, to } = state.lastMove;
			lastMoveText.textContent = `Last: ${String.fromCharCode(97 + from.x)}${ROWS - from.y}${String.fromCharCode(97 + to.x)}${ROWS - to.y}`;
		} else lastMoveText.textContent = "Last: --";
		renderHistory();
		if (!state.menuActive && state.aiEnabled && !state.gameOver && state.turn === state.aiColor && !state.thinking) maybeRunAI();
	}

	function applyModeUI() { [btn1p, btn2p].forEach(b => b.classList.remove("active")); if (selectedMode === "1p") btn1p.classList.add("active"); else btn2p.classList.add("active"); }
	function setDifficulty(level) { state.aiLevel = level; selectedDiff = level; applyDifficultyUI(); updateHud(); }
	function applyDifficultyUI() { [btnEasy, btnMed, btnHard].forEach(b => b.classList.remove("active")); if (state.aiLevel === "easy") btnEasy.classList.add("active"); else if (state.aiLevel === "hard") btnHard.classList.add("active"); else btnMed.classList.add("active"); selectedDiff = state.aiLevel; }
	function cycleDiff(delta) { const diffs = ["easy","medium","hard"]; const idx = diffs.indexOf(selectedDiff); selectedDiff = diffs[(idx + delta + diffs.length) % diffs.length]; state.aiLevel = selectedDiff; applyDifficultyUI(); }

	function start1P() { state.aiEnabled = true; state.aiColor = DARK; state.menuActive = false; startOverlay.style.display = "none"; setBoardInput(true); resetBoard(); applyDifficultyUI(); render(); updateHud(); maybeRunAI(); }
	function start2P() { state.aiEnabled = false; state.menuActive = false; startOverlay.style.display = "none"; setBoardInput(true); resetBoard(); applyDifficultyUI(); render(); updateHud(); }
	function startSelected() { state.aiLevel = selectedDiff; if (selectedMode === "1p") start1P(); else start2P(); }

	function render() { drawBoard(boardLayer.getContext("2d")); drawPieces(piecesLayer.getContext("2d")); }

	// Init
	resetBoard();
	resize();
	applyDifficultyUI();
	applyModeUI();
	setBoardInput(false);
	render();
	updateHud();
	toggleHistory(true);

	// Events
	uiLayer.addEventListener("mousedown", handlePointer);
	window.addEventListener("resize", () => { resize(); render(); });
	window.addEventListener("keydown", handleKey);
	btn1p.addEventListener("click", () => { selectedMode = "1p"; applyModeUI(); });
	btn2p.addEventListener("click", () => { selectedMode = "2p"; applyModeUI(); });
	btnEasy.addEventListener("click", () => setDifficulty("easy"));
	btnMed.addEventListener("click", () => setDifficulty("medium"));
	btnHard.addEventListener("click", () => setDifficulty("hard"));
	btnStartOverlay.addEventListener("click", startSelected);
	btnRules.addEventListener("click", () => toggleRules(true));
	closeRules.addEventListener("click", () => toggleRules(false));
	hudBtnStart.addEventListener("click", showStartOverlay);
	hudBtnReset.addEventListener("click", () => { resetBoard(); render(); updateHud(); });
	hudBtnUndo.addEventListener("click", () => { undo(); render(); updateHud(); });
	hudBtnHistory.addEventListener("click", () => toggleHistory());
	btnHistoryClose.addEventListener("click", () => toggleHistory(false));
	topStart.addEventListener("click", showStartOverlay);
	topReset.addEventListener("click", () => { resetBoard(); render(); updateHud(); });
	topRules.addEventListener("click", () => toggleRules(true));

})();
</script>
</body>
</html>
