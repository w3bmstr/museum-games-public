<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chaturanga – Standalone</title>
<style>
	html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #0f0f12; color: #eee; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; font-size: 16px; }
	#game-container { position: relative; width: 100vw; height: 100vh; background: #0f0f12; overflow: hidden; }
	canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
	.layer-board { z-index: 0; pointer-events: none; }
	.layer-pieces { z-index: 1; pointer-events: none; }
	.layer-ui { z-index: 2; }
	#top-bar { position: absolute; top: 0; left: 0; right: 0; height: 56px; padding: 10px 14px; display: flex; align-items: center; justify-content: space-between; gap: 10px; background: linear-gradient(90deg, rgba(124,77,255,0.24), rgba(0,0,0,0.55)); border-bottom: 1px solid rgba(255,255,255,0.08); z-index: 6; box-shadow: 0 10px 30px rgba(0,0,0,0.35); }
	#top-bar .title { font-size: 20px; font-weight: 700; letter-spacing: 0.4px; color: #ffd166; }
	#top-bar .subtitle { font-size: 13px; color: #a9b6d2; margin-top: 2px; }
	#top-bar .title-wrap { display: flex; flex-direction: column; }
	#top-actions { display: flex; gap: 8px; flex-wrap: wrap; }
	.pill-btn { padding: 8px 11px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.12); color: #f5f5f5; cursor: pointer; font-size: 14px; }
	.pill-btn.primary { background: linear-gradient(135deg, #7c4dff, #512da8); color: #fff; border-color: rgba(255,255,255,0.2); }
	#start-overlay { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.7); z-index: 10; }
	#start-card { background: #1d1d1f; border: 1px solid #333; border-radius: 12px; padding: 20px 22px; color: #f5f5f5; min-width: 320px; box-shadow: 0 12px 30px rgba(0,0,0,0.35); }
	#start-card h2 { margin: 0 0 12px 0; font-size: 22px; }
	#start-card p { margin: 0 0 12px 0; font-size: 15px; color: #ccc; }
	#start-card .btn-row { display: flex; gap: 10px; margin-top: 10px; }
	#start-card button { flex: 1; padding: 11px 13px; border: none; border-radius: 10px; background: linear-gradient(135deg, #7c4dff, #512da8); color: #fff; font-weight: 700; cursor: pointer; font-size: 15px; }
	#start-card button.secondary { background: #444; }
	#start-card button.active { outline: 2px solid #fff; }
	#hud { position: absolute; top: 64px; left: 10px; z-index: 5; display: flex; flex-direction: column; gap: 10px; }
	.panel { background: rgba(0,0,0,0.58); border: 1px solid #333; border-radius: 12px; padding: 12px 14px; min-width: 240px; color: #eee; box-shadow: 0 8px 20px rgba(0,0,0,0.3); font-size: 15px; }
	.panel h4 { margin: 0 0 6px 0; font-size: 15px; letter-spacing: 0.4px; color: #9cf; }
	.panel p { margin: 4px 0; font-size: 15px; }
	#controls { display: flex; gap: 8px; flex-wrap: wrap; }
	#controls button { padding: 9px 11px; border: none; border-radius: 10px; background: #2d2d33; color: #eee; cursor: pointer; font-size: 14px; }
	#controls button.primary { background: linear-gradient(135deg, #7c4dff, #512da8); color: #fff; }
	.history-panel { position: relative; max-height: 240px; overflow-y: auto; font-family: monospace; font-size: 12px; }
	.history-panel .move-line { margin: 2px 0; }
	.history-close { position: absolute; top: 6px; right: 6px; padding: 4px 8px; border: none; border-radius: 6px; background: #2d2d33; color: #eee; cursor: pointer; font-size: 11px; }
	#rules-overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.7); z-index: 11; }
	#rules-overlay.show { display: flex; }
	#rules-card { background: #1d1d1f; border: 1px solid #333; border-radius: 12px; padding: 18px 22px; color: #f5f5f5; max-width: 640px; width: 90%; box-shadow: 0 12px 30px rgba(0,0,0,0.35); line-height: 1.45; }
	#rules-card h3 { margin: 0 0 8px 0; font-size: 18px; }
	#rules-card ul { margin: 8px 0 0 18px; padding: 0; }
	#rules-card li { margin: 4px 0; }
	#close-rules { margin-top: 12px; padding: 8px 12px; border: none; border-radius: 8px; background: #444; color: #fff; cursor: pointer; }
	#toast { position: fixed; left: 50%; bottom: 24px; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: #fff; padding: 8px 12px; border-radius: 6px; font-size: 13px; opacity: 0; transition: opacity 0.15s ease; z-index: 9999; pointer-events: none; }
	#toast.show { opacity: 1; }

	/* Mobile layout to avoid history overlap */
	#btn-history { display: none; }
	@media (max-width: 720px) {
		html, body { font-size: 17px; }
		#top-bar { height: 58px; padding: 12px 14px; gap: 8px; }
		#top-bar .title { font-size: 19px; }
		#top-bar .subtitle { font-size: 13px; }
		#top-actions { gap: 6px; }
		.pill-btn { font-size: 14px; padding: 8px 10px; }
		#hud { position: fixed; top: auto; bottom: 0; left: 0; right: 0; flex-direction: row; gap: 6px; padding: 8px; background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.45) 40%); backdrop-filter: blur(8px); }
		#hud .panel { min-width: 0; flex: 1; font-size: 15px; }
		.panel h4 { font-size: 15px; }
		.panel p { font-size: 15px; }
		#history { display: none; position: fixed; right: 8px; bottom: 88px; width: 82vw; max-width: 360px; max-height: 55vh; z-index: 12; background: rgba(0,0,0,0.86); border-radius: 12px; }
		#history.show { display: block; }
		#btn-history { display: inline-block; }
		#start-card { min-width: 0; width: 92vw; }
		#start-card h2 { font-size: 24px; }
		#start-card p, #start-card button { font-size: 16px; }
	}
</style>
</head>
<body>
<div id="game-container">
	<div id="top-bar">
		<div class="title-wrap">
			<div class="title">Chaturanga</div>
			<div class="subtitle">Roots of chess</div>
		</div>
		<div id="top-actions">
			<button id="top-start" class="pill-btn primary">Start</button>
			<button id="top-rules" class="pill-btn">Rules</button>
			<button id="top-reset" class="pill-btn">Reset</button>
		</div>
	</div>
	<div id="hud">
		<div class="panel">
			<h4>Status</h4>
			<p id="turn-text">Turn: --</p>
			<p id="ai-text">AI: --</p>
			<p id="mode-text">Mode: --</p>
			<p id="msg-text">Ready</p>
			<p id="cap-text">Captures W0 B0</p>
			<p id="lastmove-text">Last: --</p>
		</div>
		<div id="controls" class="panel">
			<button id="btn-start" class="primary">New Game</button>
			<button id="btn-reset">Reset</button>
			<button id="btn-undo">Undo</button>
			<button id="btn-history" class="secondary">History</button>
			<button id="btn-rules">Rules</button>
		</div>
		<div id="history" class="panel history-panel">
			<h4>Moves</h4>
			<button id="btn-history-close" class="history-close">Close</button>
			<div id="move-list"></div>
		</div>
	</div>
	<div id="start-overlay">
		<div id="start-card">
			<h2>Chaturanga</h2>
			<p>Choose players and AI</p>
			<p style="margin-bottom:6px;">Humans</p>
			<div class="btn-row">
				<button id="btn-1p">1P (White human, Black AI)</button>
				<button id="btn-2p" class="secondary">2P Hotseat</button>
			</div>
			<p style="margin-top:12px; margin-bottom:6px;">AI Difficulty</p>
			<div class="btn-row">
				<button id="btn-easy" class="secondary">Easy</button>
				<button id="btn-med" class="active">Medium</button>
				<button id="btn-hard" class="secondary">Hard</button>
			</div>
			<div class="btn-row" style="margin-top:12px;">
				<button id="btn-start-overlay" class="primary">Start</button>
			</div>
		</div>
	</div>
	<div id="rules-overlay">
		<div id="rules-card">
			<h3>Rules</h3>
			<ul>
				<li>2 armies: White (bottom) and Black (top). Turn order: White → Black.</li>
				<li>Pieces: King steps 1; Mantri (advisor) moves 1 diagonally; Elephant leaps exactly 2 diagonally (can jump); Horse is knight; Chariot is rook; Pawns move 1 forward, capture diagonally forward, no double-step or en-passant; promote to Mantri on back rank.</li>
				<li>Setup: Standard 8×8; back rank R H E M K E H R; pawns on second rank.</li>
				<li>Goal: capture the opposing king (no check/checkmate enforcement here).</li>
				<li>Controls: mouse click; keyboard arrows + Enter/Space; controller stick/D-pad to move, A select/move, B cancel, X reset, LB undo, Y rules, Start opens start screen.</li>
			</ul>
			<button id="close-rules">Close</button>
		</div>
	</div>
</div>
<div id="toast"></div>
<script>
(function() {
	const COLS = 8, ROWS = 8;
	const dpr = window.devicePixelRatio || 1;
	const W = 0, B = 1;
	const COLORS = [W, B];
	const COLOR_NAMES = ["White", "Black"];
	const COLOR_FILL = ["#e6e6e6", "#444"];
	const PIECE_VALUES = { K: 1000, M: 3, E: 3, H: 3, R: 5, P: 1 };

	const container = document.getElementById("game-container");
	const startOverlay = document.getElementById("start-overlay");
	const btn1p = document.getElementById("btn-1p");
	const btn2p = document.getElementById("btn-2p");
	const btnEasy = document.getElementById("btn-easy");
	const btnMed = document.getElementById("btn-med");
	const btnHard = document.getElementById("btn-hard");
	const btnStartOverlay = document.getElementById("btn-start-overlay");
	const btnRules = document.getElementById("btn-rules");
	const rulesOverlay = document.getElementById("rules-overlay");
	const closeRules = document.getElementById("close-rules");
	const topStart = document.getElementById("top-start");
	const topRules = document.getElementById("top-rules");
	const topReset = document.getElementById("top-reset");
	const hudBtnStart = document.getElementById("btn-start");
	const hudBtnReset = document.getElementById("btn-reset");
	const hudBtnUndo = document.getElementById("btn-undo");
	const hudBtnHistory = document.getElementById("btn-history");
	const btnHistoryClose = document.getElementById("btn-history-close");
	const turnText = document.getElementById("turn-text");
	const aiText = document.getElementById("ai-text");
	const modeText = document.getElementById("mode-text");
	const msgText = document.getElementById("msg-text");
	const capText = document.getElementById("cap-text");
	const lastMoveText = document.getElementById("lastmove-text");
	const moveList = document.getElementById("move-list");
	const historyPanel = document.getElementById("history");
	const toast = document.getElementById("toast");

	const boardLayer = document.createElement("canvas");
	const piecesLayer = document.createElement("canvas");
	const uiLayer = document.createElement("canvas");
	boardLayer.className = "layer-board";
	piecesLayer.className = "layer-pieces";
	uiLayer.className = "layer-ui";
	container.appendChild(boardLayer);
	container.appendChild(piecesLayer);
	container.appendChild(uiLayer);

	const layout = { width: 0, height: 0, cell: 0, offsetX: 0, offsetY: 0 };

	const state = {
		board: createEmptyBoard(),
		alive: [true, true],
		turnIndex: 0,
		moveHistory: [],
		lastMove: null,
		captures: [0,0],
		gameOver: false,
		winner: null,
		message: "",
		cursor: { x: 4, y: 7 },
		selected: null,
		legal: [],
		aiLevel: "medium",
		humans: [true, false],
		thinking: false,
		menuActive: true
	};

	let selectedPlayers = "1p";
	let selectedDiff = "medium";

	function createEmptyBoard() { return Array.from({ length: ROWS }, () => Array(COLS).fill(null)); }
	function cloneBoard(b) { return b.map(row => row.map(pc => pc ? { ...pc } : null)); }

	function initBoard() {
		state.board = createEmptyBoard();
		// White bottom
		state.board[7] = [
			{ type: "R", color: W },
			{ type: "H", color: W },
			{ type: "E", color: W },
			{ type: "M", color: W },
			{ type: "K", color: W },
			{ type: "E", color: W },
			{ type: "H", color: W },
			{ type: "R", color: W }
		];
		state.board[6] = Array.from({ length: COLS }, () => ({ type: "P", color: W }));
		// Black top
		state.board[0] = [
			{ type: "R", color: B },
			{ type: "H", color: B },
			{ type: "E", color: B },
			{ type: "M", color: B },
			{ type: "K", color: B },
			{ type: "E", color: B },
			{ type: "H", color: B },
			{ type: "R", color: B }
		];
		state.board[1] = Array.from({ length: COLS }, () => ({ type: "P", color: B }));
	}

	function resetGame() {
		initBoard();
		state.alive = [true, true];
		state.turnIndex = 0;
		state.moveHistory = [];
		state.lastMove = null;
		state.captures = [0,0];
		state.gameOver = false;
		state.winner = null;
		state.message = "";
		state.selected = null;
		state.legal = [];
		state.cursor = { x: 4, y: 7 };
		updateHud();
	}

	function resize() {
		layout.width = window.innerWidth;
		layout.height = window.innerHeight;
		[boardLayer, piecesLayer, uiLayer].forEach(c => {
			c.width = layout.width * dpr;
			c.height = layout.height * dpr;
			c.style.width = `${layout.width}px`;
			c.style.height = `${layout.height}px`;
			const ctx = c.getContext("2d");
			ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
		});
		layout.cell = Math.min(layout.width, layout.height) * 0.8 / COLS;
		layout.offsetX = (layout.width - layout.cell * COLS) / 2;
		layout.offsetY = (layout.height - layout.cell * ROWS) / 2;
	}

	function drawBoard(ctx) {
		ctx.clearRect(0, 0, layout.width, layout.height);
		ctx.fillStyle = "#0f0f12";
		ctx.fillRect(0, 0, layout.width, layout.height);
		for (let y = 0; y < ROWS; y++) {
			for (let x = 0; x < COLS; x++) {
				const even = (x + y) % 2 === 0;
				ctx.fillStyle = even ? "#2d2d33" : "#444452";
				ctx.fillRect(layout.offsetX + x * layout.cell, layout.offsetY + y * layout.cell, layout.cell, layout.cell);
			}
		}
	}

	function drawPieces(ctx) {
		ctx.clearRect(0, 0, layout.width, layout.height);
		ctx.font = `${layout.cell * 0.45}px sans-serif`;
		ctx.textAlign = "center"; ctx.textBaseline = "middle";
		for (let y = 0; y < ROWS; y++) {
			for (let x = 0; x < COLS; x++) {
				const pc = state.board[y][x];
				if (!pc) continue;
				const cx = layout.offsetX + x * layout.cell + layout.cell / 2;
				const cy = layout.offsetY + y * layout.cell + layout.cell / 2;
				ctx.fillStyle = COLOR_FILL[pc.color];
				ctx.strokeStyle = "#000"; ctx.lineWidth = 1;
				ctx.beginPath(); ctx.arc(cx, cy, layout.cell * 0.36, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
				ctx.fillStyle = pc.color === W ? "#000" : "#f5f5f5";
				ctx.fillText(pc.type, cx, cy + layout.cell * 0.04);
			}
		}

		const ui = uiLayer.getContext("2d");
		ui.clearRect(0, 0, layout.width, layout.height);
		if (state.selected) {
			drawCellOutline(ui, state.selected.x, state.selected.y, "#4fc3f7", 3);
			state.legal.forEach(m => drawCellOutline(ui, m.x, m.y, "#9ad3ff", 2));
		}
		if (state.lastMove) {
			drawCellOutline(ui, state.lastMove.from.x, state.lastMove.from.y, "#ffd166", 2);
			drawCellOutline(ui, state.lastMove.to.x, state.lastMove.to.y, "#ffd166", 2);
		}
		drawCellOutline(ui, state.cursor.x, state.cursor.y, "#66b2ff", 2);

		if (state.gameOver && state.winner) showToast(`${state.winner} wins`);
	}

	function render() {
		drawBoard(boardLayer.getContext("2d"));
		drawPieces(piecesLayer.getContext("2d"));
	}

	function drawCellOutline(ctx, x, y, color, w) {
		ctx.strokeStyle = color; ctx.lineWidth = w;
		ctx.strokeRect(layout.offsetX + x * layout.cell + 2, layout.offsetY + y * layout.cell + 2, layout.cell - 4, layout.cell - 4);
	}

	function onBoard(x, y) { return x >= 0 && x < COLS && y >= 0 && y < ROWS; }

	function slideDirs(dirs, x, y, board, color, out) {
		for (const [dx, dy] of dirs) {
			let nx = x + dx, ny = y + dy;
			while (onBoard(nx, ny)) {
				if (!board[ny][nx]) out.push({ x: nx, y: ny });
				else { if (board[ny][nx].color !== color) out.push({ x: nx, y: ny }); break; }
				nx += dx; ny += dy;
			}
		}
	}

	function pawnVectors(color) {
		if (color === W) return { fwd: [0, -1], caps: [[-1, -1], [1, -1]], promo: (x, y) => y === 0 };
		return { fwd: [0, 1], caps: [[-1, 1], [1, 1]], promo: (x, y) => y === ROWS - 1 };
	}

	function genMovesFor(x, y, board) {
		const pc = board[y][x];
		if (!pc) return [];
		const color = pc.color;
		const moves = [];
		const push = (nx, ny) => { if (onBoard(nx, ny)) moves.push({ x: nx, y: ny }); };
		switch (pc.type) {
			case "P": {
				const v = pawnVectors(color);
				const tx = x + v.fwd[0], ty = y + v.fwd[1];
				if (onBoard(tx, ty) && !board[ty][tx]) push(tx, ty);
				for (const [dx, dy] of v.caps) {
					const nx = x + dx, ny = y + dy;
					if (onBoard(nx, ny) && board[ny][nx] && board[ny][nx].color !== color) push(nx, ny);
				}
				break;
			}
			case "H": {
				const steps = [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]];
				for (const [dx, dy] of steps) {
					const nx = x + dx, ny = y + dy;
					if (!onBoard(nx, ny)) continue;
					if (!board[ny][nx] || board[ny][nx].color !== color) push(nx, ny);
				}
				break;
			}
			case "E": {
				const leaps = [[2,2],[2,-2],[-2,2],[-2,-2]];
				for (const [dx, dy] of leaps) {
					const nx = x + dx, ny = y + dy;
					if (!onBoard(nx, ny)) continue;
					if (!board[ny][nx] || board[ny][nx].color !== color) push(nx, ny);
				}
				break;
			}
			case "R": slideDirs([[1,0],[-1,0],[0,1],[0,-1]], x, y, board, color, moves); break;
			case "M": {
				const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
				for (const [dx, dy] of dirs) {
					const nx = x + dx, ny = y + dy;
					if (onBoard(nx, ny) && (!board[ny][nx] || board[ny][nx].color !== color)) push(nx, ny);
				}
				break;
			}
			case "K": {
				const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
				for (const [dx, dy] of dirs) {
					const nx = x + dx, ny = y + dy;
					if (onBoard(nx, ny) && (!board[ny][nx] || board[ny][nx].color !== color)) push(nx, ny);
				}
				break;
			}
		}
		return moves;
	}

	function listMovesForColor(color) {
		if (!state.alive[color]) return [];
		const moves = [];
		for (let y = 0; y < ROWS; y++) {
			for (let x = 0; x < COLS; x++) {
				const pc = state.board[y][x];
				if (!pc || pc.color !== color) continue;
				const legal = genMovesFor(x, y, state.board);
				for (const m of legal) moves.push({ from: { x, y }, to: m, piece: pc });
			}
		}
		return moves;
	}

	function makeMove(fx, fy, tx, ty) {
		const pc = state.board[fy][fx];
		const target = state.board[ty][tx];
		if (!pc) return;
		const move = { from: { x: fx, y: fy }, to: { x: tx, y: ty }, piece: { ...pc }, captured: target ? { ...target } : null };
		state.board[fy][fx] = null;
		state.board[ty][tx] = pc;

		if (pc.type === "P") {
			const v = pawnVectors(pc.color);
			if (v.promo(tx, ty)) pc.type = "M", move.promoted = true;
		}

		if (target) {
			state.captures[pc.color] += PIECE_VALUES[target.type] || 1;
			if (target.type === "K") {
				state.alive[target.color] = false;
				state.gameOver = true;
				state.winner = COLOR_NAMES[pc.color];
				state.message = `${state.winner} wins`;
			}
		}

		state.moveHistory.push(move);
		state.lastMove = move;

		if (!state.gameOver) advanceTurn();
		updateHud();
	}

	function advanceTurn() {
		state.turnIndex = (state.turnIndex + 1) % 2;
	}

	function isHumanTurn() { return state.humans[COLORS[state.turnIndex]]; }
	function currentColor() { return COLORS[state.turnIndex]; }

	function undo() {
		const mv = state.moveHistory.pop();
		if (!mv) return;
		state.board[mv.from.y][mv.from.x] = { ...mv.piece };
		state.board[mv.to.y][mv.to.x] = mv.captured ? { ...mv.captured } : null;
		if (mv.promoted) state.board[mv.from.y][mv.from.x].type = "P";
		state.lastMove = state.moveHistory[state.moveHistory.length - 1] || null;
		if (mv.captured && mv.captured.type === "K") state.alive[mv.captured.color] = true;
		state.captures[mv.piece.color] -= mv.captured ? (PIECE_VALUES[mv.captured.type] || 1) : 0;
		state.gameOver = false; state.winner = null;
		state.turnIndex = COLORS.indexOf(mv.piece.color);
		updateHud(); render();
	}

	function showToast(msg) {
		toast.textContent = msg;
		toast.classList.add("show");
		clearTimeout(showToast.tid);
		showToast.tid = setTimeout(() => toast.classList.remove("show"), 1600);
	}

	function clickCell(x, y) {
		if (state.menuActive || state.gameOver) return;
		const pc = state.board[y][x];
		const color = currentColor();
		if (state.selected) {
			const isLegal = state.legal.some(m => m.x === x && m.y === y);
			if (isLegal) {
				makeMove(state.selected.x, state.selected.y, x, y);
				state.selected = null; state.legal = [];
				render(); maybeRunAI();
				return;
			}
		}
		if (pc && pc.color === color && state.alive[color]) {
			state.selected = { x, y };
			state.legal = genMovesFor(x, y, state.board);
			state.cursor = { x, y };
			state.message = "";
		} else {
			state.selected = null; state.legal = [];
		}
		updateHud();
	}

	function moveCursor(dx, dy) {
		if (state.menuActive) return;
		state.cursor.x = Math.max(0, Math.min(COLS - 1, state.cursor.x + dx));
		state.cursor.y = Math.max(0, Math.min(ROWS - 1, state.cursor.y + dy));
		state.message = "";
		render(); updateHud();
	}

	function handlePointer(e) {
		if (state.menuActive) return;
		const rect = uiLayer.getBoundingClientRect();
		const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
		const x = Math.floor((mx - layout.offsetX) / layout.cell);
		const y = Math.floor((my - layout.offsetY) / layout.cell);
		if (!onBoard(x, y)) return;
		state.cursor = { x, y };
		clickCell(x, y);
		render(); maybeRunAI();
	}

	function handleKey(e) {
		const key = e.key.toLowerCase();
		if (rulesOverlay.classList.contains("show")) {
			if (["h","escape","enter"," "].includes(key)) toggleRules(false);
			return;
		}
		if (state.menuActive) {
			if (key === "1") { selectedPlayers = "1p"; applyPlayersUI(); }
			else if (key === "2") { selectedPlayers = "2p"; applyPlayersUI(); }
			else if (key === "arrowup" || key === "w") { cycleDiff(-1); }
			else if (key === "arrowdown" || key === "s") { cycleDiff(1); }
			else if (key === "enter" || key === " ") { startSelected(); }
			return;
		}
		if (key === "arrowup") moveCursor(0, -1);
		else if (key === "arrowdown") moveCursor(0, 1);
		else if (key === "arrowleft") moveCursor(-1, 0);
		else if (key === "arrowright") moveCursor(1, 0);
		else if (key === "enter" || key === " ") { clickCell(state.cursor.x, state.cursor.y); render(); maybeRunAI(); }
		else if (key === "escape") { state.selected = null; state.legal = []; state.message = ""; render(); }
		else if (key === "u") { undo(); }
		else if (key === "r") { resetGame(); render(); }
		else if (key === "h") { toggleRules(); }
		render(); updateHud();
	}

	function isAiTurn() { return !isHumanTurn() && !state.gameOver && !state.menuActive; }

	function aiChooseMove(color) {
		const moves = listMovesForColor(color);
		if (!moves.length) return null;
		if (state.aiLevel === "easy") return moves[Math.floor(Math.random() * moves.length)];
		let best = -Infinity; const candidates = [];
		for (const mv of moves) {
			const tgt = state.board[mv.to.y][mv.to.x];
			const cap = tgt ? (PIECE_VALUES[tgt.type] || 1) : 0;
			let score = cap + Math.random() * 0.05;
			if (state.aiLevel === "hard") score += cap * 2 - (PIECE_VALUES[mv.piece.type] || 1) * 0.25;
			if (score > best) { best = score; candidates.length = 0; candidates.push(mv); }
			else if (Math.abs(score - best) < 1e-4) candidates.push(mv);
		}
		return candidates[Math.floor(Math.random() * candidates.length)];
	}

	function maybeRunAI() {
		if (!isAiTurn()) return;
		state.thinking = true;
		setTimeout(() => {
			const color = currentColor();
			const mv = aiChooseMove(color);
			if (mv) makeMove(mv.from.x, mv.from.y, mv.to.x, mv.to.y);
			state.thinking = false;
			render(); updateHud();
			maybeRunAI();
		}, 140);
	}

	function applyPlayersUI() {
		[btn1p, btn2p].forEach(b => b.classList.remove("active"));
		if (selectedPlayers === "1p") btn1p.classList.add("active");
		else btn2p.classList.add("active");
	}

	function applyDifficultyUI() {
		[btnEasy, btnMed, btnHard].forEach(b => b.classList.remove("active"));
		if (selectedDiff === "easy") btnEasy.classList.add("active");
		else if (selectedDiff === "hard") btnHard.classList.add("active");
		else btnMed.classList.add("active");
	}

	function cycleDiff(delta) {
		const diffs = ["easy","medium","hard"];
		const idx = diffs.indexOf(selectedDiff);
		selectedDiff = diffs[(idx + delta + diffs.length) % diffs.length];
		applyDifficultyUI();
	}

	function setHumans() {
		if (selectedPlayers === "1p") state.humans = [true,false];
		else state.humans = [true,true];
	}

	function startSelected() {
		state.aiLevel = selectedDiff;
		setHumans();
		state.turnIndex = 0;
		state.menuActive = false;
		startOverlay.style.display = "none";
		resetGame();
		render(); updateHud();
		maybeRunAI();
	}

	function toggleRules(force) {
		const show = force !== undefined ? force : !rulesOverlay.classList.contains("show");
		rulesOverlay.classList.toggle("show", show);
	}

	function showStartOverlay() {
		startOverlay.style.display = "flex";
		state.menuActive = true;
	}

	function renderHistory() {
		const sq = (x, y) => `${String.fromCharCode(97 + x)}${ROWS - y}`;
		moveList.innerHTML = state.moveHistory.map((mv, i) => {
			const capMark = mv.captured ? "x" : "-";
			const promo = mv.promoted ? "=M" : "";
			const c = COLOR_NAMES[mv.piece.color][0];
			return `<div class="move-line">${i + 1}. ${c} ${sq(mv.from.x, mv.from.y)}${capMark}${sq(mv.to.x, mv.to.y)}${promo}</div>`;
		}).join("");
	}

	function toggleHistory(force) {
		const isMobile = window.innerWidth <= 720;
		if (!isMobile) return; // desktop keeps panel visible
		const show = force !== undefined ? force : !historyPanel.classList.contains("show");
		historyPanel.classList.toggle("show", show);
	}

	function updateHud() {
		const turnColor = COLOR_NAMES[currentColor()] || "--";
		turnText.textContent = `Turn: ${turnColor}`;
		aiText.textContent = `AI: ${state.aiLevel.toUpperCase()} (humans: ${state.humans.map((h,i)=>h?COLOR_NAMES[i][0]:null).filter(Boolean).join(",")||"none"})`;
		modeText.textContent = "Mode: Classic";
		if (state.gameOver && state.winner) msgText.textContent = `${state.winner} wins`;
		else msgText.textContent = state.message || "Ready";
		capText.textContent = `Captures W${state.captures[W]} B${state.captures[B]}`;
		if (state.lastMove) {
			const { from, to } = state.lastMove;
			lastMoveText.textContent = `Last: ${String.fromCharCode(97 + from.x)}${ROWS - from.y}→${String.fromCharCode(97 + to.x)}${ROWS - to.y}`;
		} else lastMoveText.textContent = "Last: --";
		renderHistory();
	}

	// Gamepad support
	let prevButtons = [];
	let lastPadMove = -1e9;
	const padRepeatMs = 170;
	const PAD_DEADZONE = 0.2;
	let gpDebug = false;
	const debugEl = document.createElement("div");
	debugEl.style.position = "fixed";
	debugEl.style.left = "8px";
	debugEl.style.bottom = "8px";
	debugEl.style.zIndex = "9999";
	debugEl.style.fontSize = "12px";
	debugEl.style.color = "#9cf";
	debugEl.style.fontFamily = "monospace";
	debugEl.style.whiteSpace = "pre";
	debugEl.style.pointerEvents = "none";
	debugEl.style.background = "rgba(0,0,0,0.35)";
	debugEl.style.padding = "4px 6px";
	debugEl.style.borderRadius = "4px";
	debugEl.style.display = "none";
	document.body.appendChild(debugEl);

	function decodeHatAxis9(v) {
		if (v === undefined || v === null) return { x: 0, y: 0 };
		if (v < -0.9) return { x: 0, y: -1 };
		if (v < -0.7) return { x: 1, y: -1 };
		if (v < -0.45) return { x: -1, y: 0 };
		if (v < -0.2) return { x: -1, y: 1 };
		if (v < 0.2) return { x: 0, y: 1 };
		if (v < 0.45) return { x: 1, y: 1 };
		if (v < 0.7) return { x: 1, y: 0 };
		if (v < 0.9) return { x: 1, y: -1 };
		return { x: 0, y: -1 };
	}

	function pollGamepad() {
		const pads = navigator.getGamepads ? navigator.getGamepads() : [];
		const pad = pads && pads[0];
		if (pad) {
			const now = performance.now();
			const axes = pad.axes || [];
			const buttons = pad.buttons || [];
			const ax0 = axes[0] ?? 0, ax1 = axes[1] ?? 0, ax6 = axes[6] ?? 0, ax7 = axes[7] ?? 0, ax9 = axes[9];
			const hat9 = decodeHatAxis9(ax9);
			const dxAxis = Math.abs(ax0) > PAD_DEADZONE ? Math.sign(ax0) : 0;
			const dyAxis = Math.abs(ax1) > PAD_DEADZONE ? Math.sign(ax1) : 0;
			const hatX = Math.abs(ax6) > PAD_DEADZONE ? Math.sign(ax6) : 0;
			const hatY = Math.abs(ax7) > PAD_DEADZONE ? Math.sign(ax7) : 0;
			const dpadX = (buttons[15]?.pressed ? 1 : 0) - (buttons[14]?.pressed ? 1 : 0);
			const dpadY = (buttons[13]?.pressed ? 1 : 0) - (buttons[12]?.pressed ? 1 : 0);
			const moveX = dpadX || hatX || hat9.x || dxAxis;
			const moveY = dpadY || hatY || hat9.y || dyAxis;

			if (gpDebug) {
				debugEl.textContent = `h:${moveX} v:${moveY} ax0:${ax0.toFixed(2)} ax1:${ax1.toFixed(2)} ax6:${ax6.toFixed(2)} ax7:${ax7.toFixed(2)} ax9:${ax9 !== undefined ? ax9.toFixed(2) : "--"} b14:${buttons[14]?.pressed ? 1 : 0} b15:${buttons[15]?.pressed ? 1 : 0}`;
			}

			const edge = idx => buttons[idx]?.pressed && !prevButtons[idx];

			if (rulesOverlay.classList.contains("show")) {
				if (edge(0) || edge(1) || edge(3) || edge(9)) toggleRules(false);
				prevButtons = buttons.map(b => b?.pressed);
				return requestAnimationFrame(pollGamepad);
			}

			if (state.menuActive) {
				if ((moveX || moveY) && now - lastPadMove > padRepeatMs) {
					if (moveY) { cycleDiff(moveY > 0 ? 1 : -1); }
					lastPadMove = now;
				}
				if (edge(14) || edge(15)) { selectedPlayers = selectedPlayers === "1p" ? "2p" : "1p"; applyPlayersUI(); }
				if (edge(12)) { cycleDiff(-1); }
				if (edge(13)) { cycleDiff(1); }
				if (edge(0) || edge(9)) startSelected();
			} else {
				if ((moveX || moveY) && now - lastPadMove > padRepeatMs) {
					moveCursor(moveX, moveY);
					lastPadMove = now;
				}
				if (edge(0)) { clickCell(state.cursor.x, state.cursor.y); render(); maybeRunAI(); }
				if (edge(1)) { state.selected = null; state.legal = []; state.message = ""; render(); }
				if (edge(3)) { toggleRules(); render(); }
				if (edge(4)) { undo(); render(); updateHud(); }
				if (edge(2)) { resetGame(); render(); updateHud(); }
				if (edge(8)) { gpDebug = !gpDebug; debugEl.style.display = gpDebug ? "block" : "none"; }
				if (edge(9)) { showStartOverlay(); }
			}

			prevButtons = buttons.map(b => b?.pressed);
		}
		requestAnimationFrame(pollGamepad);
	}
	requestAnimationFrame(pollGamepad);

	window.addEventListener("keydown", ev => { if (ev.key.toLowerCase() === "g") { gpDebug = !gpDebug; debugEl.style.display = gpDebug ? "block" : "none"; } });

	uiLayer.addEventListener("mousedown", handlePointer);
	window.addEventListener("keydown", handleKey);
	window.addEventListener("resize", () => { resize(); render(); toggleHistory(false); });
	btn1p.addEventListener("click", () => { selectedPlayers = "1p"; applyPlayersUI(); });
	btn2p.addEventListener("click", () => { selectedPlayers = "2p"; applyPlayersUI(); });
	btnEasy.addEventListener("click", () => { selectedDiff = "easy"; applyDifficultyUI(); });
	btnMed.addEventListener("click", () => { selectedDiff = "medium"; applyDifficultyUI(); });
	btnHard.addEventListener("click", () => { selectedDiff = "hard"; applyDifficultyUI(); });
	btnStartOverlay.addEventListener("click", startSelected);
	btnRules.addEventListener("click", () => toggleRules(true));
	closeRules.addEventListener("click", () => toggleRules(false));
	if (topStart) topStart.addEventListener("click", showStartOverlay);
	if (topRules) topRules.addEventListener("click", () => toggleRules(true));
	if (topReset) topReset.addEventListener("click", () => { resetGame(); render(); updateHud(); });
	hudBtnStart.addEventListener("click", showStartOverlay);
	hudBtnReset.addEventListener("click", () => { resetGame(); render(); updateHud(); });
	hudBtnUndo.addEventListener("click", () => { undo(); render(); updateHud(); });
	hudBtnHistory.addEventListener("click", () => toggleHistory());
	btnHistoryClose.addEventListener("click", () => toggleHistory(false));

	// Init
	resetGame();
	resize();
	applyPlayersUI();
	applyDifficultyUI();
	render();
	updateHud();
})();
</script>
</body>
</html>