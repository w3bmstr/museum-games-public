<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Xiangqi</title>
<style>
  html, body { margin: 0; padding: 0; width: 100%; height: 100%; background: #0f0f12; overflow: hidden; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; color: #eee; }
  #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; background: #0f0f12; }
  canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
  .layer-board { z-index: 0; pointer-events: none; }
  .layer-pieces { z-index: 1; pointer-events: none; }
  .layer-ui { z-index: 2; }
  #hud { position: absolute; top: 10px; left: 10px; z-index: 5; display: flex; flex-direction: column; gap: 8px; }
  .panel { background: rgba(0,0,0,0.6); border: 1px solid #1f2430; border-radius: 10px; padding: 10px 12px; min-width: 240px; box-shadow: 0 10px 28px rgba(0,0,0,0.35); }
  .panel h4 { margin: 0 0 6px 0; font-size: 13px; letter-spacing: 0.5px; color: #ffc857; }
  .panel p { margin: 4px 0; font-size: 13px; }
  #controls { display: flex; gap: 8px; flex-wrap: wrap; }
  #controls button { padding: 8px 10px; border: none; border-radius: 8px; background: #252a38; color: #e8e8ec; cursor: pointer; font-size: 13px; }
  #controls button.primary { background: linear-gradient(135deg, #38bdf8, #6366f1); color: #0a0c12; }
  #controls button:disabled { opacity: 0.55; cursor: not-allowed; }
  .history-panel { position: relative; max-height: 260px; overflow-y: auto; font-family: monospace; font-size: 12px; }
  .history-panel .move-line { margin: 2px 0; }
  .history-close { position: absolute; top: 6px; right: 6px; padding: 4px 8px; border: none; border-radius: 6px; background: #252a38; color: #e8e8ec; cursor: pointer; font-size: 11px; }
  #btn-history { display: none; }
  @media (max-width: 820px) {
    #hud { position: fixed; top: auto; bottom: 0; left: 0; right: 0; flex-direction: row; gap: 6px; padding: 6px; background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.45) 40%); backdrop-filter: blur(8px); }
    #hud .panel { min-width: 0; flex: 1; }
    #history { display: none; position: fixed; right: 8px; bottom: 78px; width: 82vw; max-width: 380px; max-height: 55vh; z-index: 12; background: rgba(0,0,0,0.85); border-radius: 10px; }
    #history.show { display: block; }
    #btn-history { display: inline-block; }
  }
  #start-overlay { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.72); z-index: 10; }
  #start-card { background: #161820; border: 1px solid #262c3a; border-radius: 12px; padding: 18px 22px; color: #f5f5f5; min-width: 320px; box-shadow: 0 12px 30px rgba(0,0,0,0.35); }
  #start-card h2 { margin: 0 0 10px 0; font-size: 20px; }
  #start-card p { margin: 0 0 12px 0; font-size: 14px; color: #cfd3dd; }
  #start-card .btn-row { display: flex; gap: 10px; margin-top: 10px; }
  #start-card button { flex: 1; padding: 10px 12px; border: none; border-radius: 8px; background: linear-gradient(135deg, #38bdf8, #6366f1); color: #0a0c12; font-weight: 700; cursor: pointer; }
  #start-card button.secondary { background: #3a3f4f; color: #f5f5f5; }
  #start-card button.active { outline: 2px solid #fff; }
  #rules-overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.7); z-index: 11; }
  #rules-overlay.show { display: flex; }
  #rules-card { background: #161820; border: 1px solid #262c3a; border-radius: 12px; padding: 18px 22px; color: #f5f5f5; max-width: 880px; width: 90%; box-shadow: 0 12px 30px rgba(0,0,0,0.35); line-height: 1.45; }
  #rules-card h3 { margin: 0 0 8px 0; font-size: 18px; }
  #rules-card ul { margin: 8px 0 0 18px; padding: 0; }
  #rules-card li { margin: 4px 0; }
  #close-rules { margin-top: 12px; padding: 8px 12px; border: none; border-radius: 8px; background: #3a3f4f; color: #fff; cursor: pointer; }
</style>
</head>
<body>
<div id="game-container">
  <div id="hud">
    <div class="panel">
      <h4>Status</h4>
      <p id="turn-text">Turn: --</p>
      <p id="ai-text">AI: --</p>
      <p id="msg-text">Ready</p>
      <p id="lastmove-text">Last: --</p>
    </div>
    <div id="controls" class="panel">
      <button id="btn-start" class="primary">New Game</button>
      <button id="btn-reset">Reset</button>
      <button id="btn-undo">Undo</button>
      <button id="btn-history">History</button>
      <button id="btn-rules">Rules</button>
    </div>
    <div id="history" class="panel history-panel">
      <h4>Moves</h4>
      <button id="btn-history-close" class="history-close">Close</button>
      <div id="move-list"></div>
    </div>
  </div>

  <div id="start-overlay">
    <div id="start-card">
      <h2>Xiangqi</h2>
      <p>Choose players, set difficulty, then Start Game.</p>
      <div class="btn-row">
        <button id="btn-1p">1 Player (vs AI)</button>
        <button id="btn-2p" class="secondary">2 Players</button>
      </div>
      <p style="margin-top:12px; margin-bottom:6px;">AI Difficulty</p>
      <div class="btn-row">
        <button id="btn-easy" class="secondary">Easy</button>
        <button id="btn-med" class="active">Medium</button>
      </div>
      <p style="margin-top:12px; margin-bottom:6px;">Start</p>
      <div class="btn-row" style="margin-top:8px;">
        <button id="btn-start-overlay" class="primary">Start Game</button>
      </div>
    </div>
  </div>

  <div id="rules-overlay">
    <div id="rules-card">
      <h3>Rules (Xiangqi)</h3>
      <ul>
        <li>Board: 9 files × 10 ranks. Generals stay inside the 3×3 palace and cannot face each other on an open file.</li>
        <li>Pieces: G (general), A (advisor/guard), E (elephant), H (horse), R (chariot), C (cannon), S (soldier). Red moves up, Black moves down.</li>
        <li>Soldiers move forward 1; after crossing the river they may also move sideways. No backward moves.</li>
        <li>Elephant/horse feet can be blocked; cannons capture by jumping one screen piece; elephants cannot cross the river.</li>
        <li>Win by checkmating the opposing general. Stalemate and threefold repetition are draws.</li>
        <li>Controls: click/tap to select then move; U undo; R reset; H rules; History shows moves.</li>
      </ul>
      <button id="close-rules">Close</button>
    </div>
  </div>
</div>

<script>
(function() {
  const COLS = 9;
  const ROWS = 10;
  const RED = "r";
  const BLACK = "b";
  const dpr = window.devicePixelRatio || 1;

  const container = document.getElementById("game-container");
  const boardLayer = document.createElement("canvas");
  const piecesLayer = document.createElement("canvas");
  const uiLayer = document.createElement("canvas");
  boardLayer.className = "layer-board";
  piecesLayer.className = "layer-pieces";
  uiLayer.className = "layer-ui";
  container.appendChild(boardLayer);
  container.appendChild(piecesLayer);
  container.appendChild(uiLayer);

  const turnEl = document.getElementById("turn-text");
  const aiEl = document.getElementById("ai-text");
  const msgEl = document.getElementById("msg-text");
  const lastEl = document.getElementById("lastmove-text");
  const moveList = document.getElementById("move-list");
  const historyPanel = document.getElementById("history");
  const btnHistory = document.getElementById("btn-history");
  const btnHistoryClose = document.getElementById("btn-history-close");
  const btnStart = document.getElementById("btn-start");
  const btnReset = document.getElementById("btn-reset");
  const btnUndo = document.getElementById("btn-undo");
  const btnRules = document.getElementById("btn-rules");
  const rulesOverlay = document.getElementById("rules-overlay");
  const btnCloseRules = document.getElementById("close-rules");
  const startOverlay = document.getElementById("start-overlay");
  const btn1p = document.getElementById("btn-1p");
  const btn2p = document.getElementById("btn-2p");
  const btnEasy = document.getElementById("btn-easy");
  const btnMed = document.getElementById("btn-med");
  const btnStartOverlay = document.getElementById("btn-start-overlay");

  const layout = { width: 0, height: 0, cell: 0, offsetX: 0, offsetY: 0 };

  const state = {
    board: createInitialBoard(),
    turn: RED,
    selected: null,
    legal: [],
    gameOver: false,
    aiThinking: false,
    lastMove: null,
    moveHistory: [],
    posCounts: new Map(),
    info: "",
    status: "",
    repDraw: false,
    vsAI: true,
    aiLevel: "medium",
    menuActive: true,
    _undo: []
  };

  // ---------- Setup ----------
  btnStart.addEventListener("click", showStart);
  btnReset.addEventListener("click", restart);
  btnUndo.addEventListener("click", undo);
  btnHistory?.addEventListener("click", () => toggleHistory(true));
  btnHistoryClose?.addEventListener("click", () => toggleHistory(false));
  btnRules.addEventListener("click", () => rulesOverlay.classList.add("show"));
  btnCloseRules.addEventListener("click", () => rulesOverlay.classList.remove("show"));
  btn1p.addEventListener("click", () => setPlayers(true));
  btn2p.addEventListener("click", () => setPlayers(false));
  btnEasy.addEventListener("click", () => setDifficulty("easy"));
  btnMed.addEventListener("click", () => setDifficulty("medium"));
  btnStartOverlay.addEventListener("click", startFromOverlay);

  uiLayer.addEventListener("mousedown", handlePointer);
  window.addEventListener("keydown", handleKey);
  window.addEventListener("resize", resize);

  setPlayers(state.vsAI);
  setDifficulty(state.aiLevel);
  resize();
  updatePosHash();
  updateHud();
  showStart();
  requestAnimationFrame(loop);

  // ---------- Core loop ----------
  function loop() {
    update();
    drawBoard(boardLayer.getContext("2d"));
    drawPieces(piecesLayer.getContext("2d"));
    drawUI(uiLayer.getContext("2d"));
    requestAnimationFrame(loop);
  }

  function resize() {
    layout.width = window.innerWidth;
    layout.height = window.innerHeight;
    [boardLayer, piecesLayer, uiLayer].forEach(c => {
      c.width = layout.width * dpr;
      c.height = layout.height * dpr;
      c.style.width = `${layout.width}px`;
      c.style.height = `${layout.height}px`;
      const ctx = c.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    });
    layout.cell = Math.min(layout.width / (COLS + 2), layout.height / (ROWS + 2));
    layout.offsetX = (layout.width - layout.cell * (COLS - 1)) / 2;
    layout.offsetY = (layout.height - layout.cell * (ROWS - 1)) / 2;
  }

  // ---------- UI helpers ----------
  function showStart() {
    state.menuActive = true;
    startOverlay.style.display = "flex";
    uiLayer.style.pointerEvents = "none";
  }

  function hideStart() {
    state.menuActive = false;
    startOverlay.style.display = "none";
    uiLayer.style.pointerEvents = "auto";
  }

  function setPlayers(vsAI) {
    state.vsAI = vsAI;
    btn1p.classList.toggle("secondary", !vsAI);
    btn2p.classList.toggle("secondary", vsAI);
    btn1p.classList.toggle("active", vsAI);
    btn2p.classList.toggle("active", !vsAI);
  }

  function setDifficulty(level) {
    state.aiLevel = level;
    btnEasy.classList.toggle("active", level === "easy");
    btnMed.classList.toggle("active", level === "medium");
    btnEasy.classList.toggle("secondary", level !== "easy");
    btnMed.classList.toggle("secondary", level !== "medium");
  }

  function startFromOverlay() {
    restart();
    hideStart();
  }

  function toggleHistory(show) {
    if (!historyPanel) return;
    historyPanel.classList.toggle("show", show);
  }

  // ---------- State management ----------
  function restart() {
    state.board = createInitialBoard();
    state.turn = RED;
    state.selected = null;
    state.legal = [];
    state.gameOver = false;
    state.aiThinking = false;
    state.lastMove = null;
    state.moveHistory = [];
    state.posCounts = new Map();
    state.repDraw = false;
    state.info = "Ready";
    state.status = "Turn: Red";
    state._undo = [];
    updatePosHash();
    updateHud();
    renderHistory();
  }

  function undo() {
    const snap = state._undo.pop?.();
    if (!snap) return;
    state.board = snap.board;
    state.turn = snap.turn;
    state.selected = null;
    state.legal = [];
    state.gameOver = snap.gameOver;
    state.aiThinking = false;
    state.lastMove = snap.lastMove;
    state.moveHistory = snap.moveHistory;
    state.posCounts = new Map(snap.posCounts);
    state.repDraw = snap.repDraw;
    state.info = "Undid move";
    updateHud();
    renderHistory();
  }

  function pushUndo() {
    state._undo.push({
      board: cloneBoard(state.board),
      turn: state.turn,
      gameOver: state.gameOver,
      lastMove: state.lastMove,
      moveHistory: [...state.moveHistory],
      posCounts: Array.from(state.posCounts.entries()),
      repDraw: state.repDraw
    });
  }

  // ---------- Update ----------
  function update() {
    if (state.menuActive) return;
    if (!state.gameOver && state.vsAI && state.turn === BLACK && !state.aiThinking) {
      state.aiThinking = true;
      setTimeout(() => {
        const mv = chooseAIMove(state.board, BLACK, state.aiLevel);
        if (mv) applyMoveAndAdvance(mv.from, mv.to, mv.piece);
        state.aiThinking = false;
      }, 120);
    }
  }

  // ---------- Drawing ----------
  function drawBoard(ctx) {
    ctx.clearRect(0, 0, layout.width, layout.height);
    ctx.fillStyle = "#0d0f14";
    ctx.fillRect(0, 0, layout.width, layout.height);

    ctx.strokeStyle = "#d4b483";
    ctx.lineWidth = 2;
    for (let y = 0; y < ROWS; y++) {
      const yy = layout.offsetY + y * layout.cell;
      ctx.beginPath();
      ctx.moveTo(layout.offsetX, yy);
      ctx.lineTo(layout.offsetX + (COLS - 1) * layout.cell, yy);
      ctx.stroke();
    }
    for (let x = 0; x < COLS; x++) {
      const xx = layout.offsetX + x * layout.cell;
      ctx.beginPath();
      ctx.moveTo(xx, layout.offsetY);
      ctx.lineTo(xx, layout.offsetY + 4 * layout.cell);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(xx, layout.offsetY + 5 * layout.cell);
      ctx.lineTo(xx, layout.offsetY + 9 * layout.cell);
      ctx.stroke();
    }
    ctx.fillStyle = "rgba(0,0,0,0.28)";
    ctx.font = `${Math.floor(layout.cell * 0.7)}px serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("楚河", layout.offsetX + 2 * layout.cell, layout.offsetY + 4.5 * layout.cell);
    ctx.fillText("漢界", layout.offsetX + 6 * layout.cell, layout.offsetY + 4.5 * layout.cell);
    ctx.strokeStyle = "#d4b483";
    ctx.lineWidth = 2;
    drawPalace(ctx, 3, 0, 5, 2);
    drawPalace(ctx, 3, 7, 5, 9);
    if (state.lastMove) {
      ctx.fillStyle = "rgba(56,189,248,0.18)";
      for (const pos of [state.lastMove.from, state.lastMove.to]) {
        const cx = layout.offsetX + pos.x * layout.cell;
        const cy = layout.offsetY + pos.y * layout.cell;
        ctx.fillRect(cx - layout.cell/2 + 2, cy - layout.cell/2 + 2, layout.cell - 4, layout.cell - 4);
      }
    }
  }

  function drawPalace(ctx, x1, y1, x2, y2) {
    const ax = layout.offsetX + x1 * layout.cell;
    const ay = layout.offsetY + y1 * layout.cell;
    const bx = layout.offsetX + x2 * layout.cell;
    const by = layout.offsetY + y2 * layout.cell;
    ctx.beginPath(); ctx.moveTo(ax, ay); ctx.lineTo(bx, by); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bx, ay); ctx.lineTo(ax, by); ctx.stroke();
  }

  function drawPieces(ctx) {
    ctx.clearRect(0, 0, layout.width, layout.height);
    ctx.textAlign = "center"; ctx.textBaseline = "middle";
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const p = state.board[y][x];
        if (!p) continue;
        const cx = layout.offsetX + x * layout.cell;
        const cy = layout.offsetY + y * layout.cell;
        const r = layout.cell * 0.38;
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fillStyle = "#f5f5f5"; ctx.fill();
        ctx.strokeStyle = "#333"; ctx.lineWidth = 2; ctx.stroke();
        ctx.font = `${Math.floor(r * 1.08)}px serif`;
        ctx.fillStyle = p.color === RED ? "#d1495b" : "#0f172a";
        ctx.fillText(pieceChar(p), cx, cy + 1);
      }
    }
  }

  function drawUI(ctx) {
    ctx.clearRect(0, 0, layout.width, layout.height);
    if (state.selected) {
      const { x, y } = state.selected;
      const cx = layout.offsetX + x * layout.cell;
      const cy = layout.offsetY + y * layout.cell;
      ctx.strokeStyle = "#38bdf8"; ctx.lineWidth = 3;
      ctx.strokeRect(cx - layout.cell/2 + 3, cy - layout.cell/2 + 3, layout.cell - 6, layout.cell - 6);
    }
    for (const mv of state.legal) {
      const cx = layout.offsetX + mv.x * layout.cell;
      const cy = layout.offsetY + mv.y * layout.cell;
      ctx.fillStyle = "rgba(99,102,241,0.6)";
      ctx.beginPath(); ctx.arc(cx, cy, layout.cell * 0.12, 0, Math.PI * 2); ctx.fill();
    }
    const redCheck = isInCheck(state.board, RED);
    const blackCheck = isInCheck(state.board, BLACK);
    ctx.strokeStyle = "#e11d48"; ctx.lineWidth = 3;
    if (redCheck) outlineCell(ctx, findGeneral(RED, state.board));
    if (blackCheck) outlineCell(ctx, findGeneral(BLACK, state.board));
    if (state.gameOver) {
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(16, layout.height - 90, 320, 70);
      ctx.fillStyle = "#fff";
      ctx.font = "16px system-ui, sans-serif";
      ctx.fillText(state.status, 26, layout.height - 60);
      ctx.fillText(state.info, 26, layout.height - 38);
    }
  }

  function outlineCell(ctx, pos) {
    if (!pos) return;
    const cx = layout.offsetX + pos.x * layout.cell;
    const cy = layout.offsetY + pos.y * layout.cell;
    ctx.strokeRect(cx - layout.cell/2 + 2, cy - layout.cell/2 + 2, layout.cell - 4, layout.cell - 4);
  }

  // ---------- Input ----------
  function handlePointer(e) {
    if (e.button !== 0) return;
    if (state.menuActive || state.gameOver) return;
    if (state.vsAI && state.turn !== RED) return; // player controls red vs AI
    const x = Math.round((e.offsetX - layout.offsetX) / layout.cell);
    const y = Math.round((e.offsetY - layout.offsetY) / layout.cell);
    if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return;
    const clicked = state.board[y][x];
    if (clicked && clicked.color === state.turn) {
      state.selected = { x, y };
      state.legal = legalMovesFrom(state.board, x, y, state.turn);
      return;
    }
    if (state.selected) {
      const mv = state.legal.find(m => m.x === x && m.y === y);
      if (mv) {
        applyMoveAndAdvance(state.selected, mv, state.board[state.selected.y][state.selected.x]);
        state.selected = null; state.legal = [];
        return;
      }
    }
    state.selected = null; state.legal = [];
  }

  function handleKey(e) {
    const k = e.key.toLowerCase();
    if (k === "r") restart();
    if (k === "u") undo();
    if (k === "h") toggleHistory(true);
    if (k === "escape") toggleHistory(false);
  }

  // ---------- Moves & rules ----------
  function applyMoveAndAdvance(from, to, piece) {
    pushUndo();
    const target = state.board[to.y][to.x];
    applyMove(state.board, from, to);
    const capture = !!target;
    state.lastMove = { from, to };
    const text = formatHistory(state.turn, from, to, piece, capture);
    state.moveHistory.push(text);
    renderHistory();
    state.turn = state.turn === RED ? BLACK : RED;
    checkGameEnd();
    updatePosHash();
    updateHud();
  }

  function formatHistory(color, from, to, piece, capture) {
    const side = color === RED ? "r" : "b";
    return `${side}: ${piece.type} ${fileLetter(from.x)}${rankNumber(from.y)}${capture ? "x" : "-"}${fileLetter(to.x)}${rankNumber(to.y)}`;
  }

  function renderHistory() {
    if (!moveList) return;
    moveList.innerHTML = "";
    state.moveHistory.forEach((m, idx) => {
      const div = document.createElement("div");
      div.className = "move-line";
      div.textContent = `${idx + 1}. ${m}`;
      moveList.appendChild(div);
    });
  }

  function updatePosHash() {
    const key = hashPosition(state.board, state.turn);
    const c = (state.posCounts.get(key) || 0) + 1;
    state.posCounts.set(key, c);
    if (c >= 3 && !state.gameOver) {
      state.gameOver = true;
      state.repDraw = true;
      state.status = "Draw";
      state.info = "Threefold repetition";
    }
  }

  function checkGameEnd() {
    if (state.gameOver) return;
    const mover = state.turn;
    if (hasAnyLegalMove(state.board, mover)) return;
    const inChk = isInCheck(state.board, mover);
    state.gameOver = true;
    if (inChk) {
      state.status = mover === RED ? "Black wins" : "Red wins";
      state.info = "Checkmate";
    } else {
      state.status = "Draw";
      state.info = "Stalemate";
    }
  }

  function updateHud() {
    let statusText = `Turn: ${state.turn === RED ? "Red" : "Black"}`;
    if (state.vsAI) statusText += state.turn === RED ? " (You)" : " (AI)";
    state.status = statusText;
    const infoText = state.gameOver ? state.info : (isInCheck(state.board, state.turn) ? "Check" : state.info || "");
    state.info = infoText;
    if (turnEl) turnEl.textContent = statusText;
    if (aiEl) aiEl.textContent = state.vsAI ? `AI: ${state.aiLevel}` : "AI: Off";
    if (msgEl) msgEl.textContent = infoText || "";
    if (lastEl) {
      if (state.lastMove) {
        const { from, to } = state.lastMove;
        lastEl.textContent = `Last: ${fileLetter(from.x)}${rankNumber(from.y)}->${fileLetter(to.x)}${rankNumber(to.y)}`;
      } else lastEl.textContent = "Last: --";
    }
  }

  // ---------- Board helpers ----------
  function createInitialBoard() {
    const b = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
    const place = (x, y, color, type) => { b[y][x] = { color, type }; };
    // Black
    place(4, 0, BLACK, "G"); place(3, 0, BLACK, "A"); place(5, 0, BLACK, "A");
    place(2, 0, BLACK, "E"); place(6, 0, BLACK, "E");
    place(1, 0, BLACK, "H"); place(7, 0, BLACK, "H");
    place(0, 0, BLACK, "R"); place(8, 0, BLACK, "R");
    place(1, 2, BLACK, "C"); place(7, 2, BLACK, "C");
    [0,2,4,6,8].forEach(x => place(x, 3, BLACK, "S"));
    // Red
    place(4, 9, RED, "G"); place(3, 9, RED, "A"); place(5, 9, RED, "A");
    place(2, 9, RED, "E"); place(6, 9, RED, "E");
    place(1, 9, RED, "H"); place(7, 9, RED, "H");
    place(0, 9, RED, "R"); place(8, 9, RED, "R");
    place(1, 7, RED, "C"); place(7, 7, RED, "C");
    [0,2,4,6,8].forEach(x => place(x, 6, RED, "S"));
    return b;
  }

  function cloneBoard(b) { return b.map(row => row.map(p => p ? { color: p.color, type: p.type } : null)); }
  function applyMove(b, from, to) { const p = b[from.y][from.x]; b[to.y][to.x] = p; b[from.y][from.x] = null; }
  function hashPosition(b, turn) { return JSON.stringify({ b, t: turn }); }
  function fileLetter(x) { return String.fromCharCode("a".charCodeAt(0) + x); }
  function rankNumber(y) { return String(ROWS - y); }

  // ---------- Rules ----------
  function inBounds(x, y) { return x >= 0 && x < COLS && y >= 0 && y < ROWS; }
  function inPalace(x, y, color) { return color === BLACK ? (x >= 3 && x <= 5 && y >= 0 && y <= 2) : (x >= 3 && x <= 5 && y >= 7 && y <= 9); }
  function sameSideOfRiver(y1, y2, color) { return color === BLACK ? (y1 <= 4 && y2 <= 4) : (y1 >= 5 && y2 >= 5); }
  function hasCrossedRiver(y, color) { return color === BLACK ? y >= 5 : y <= 4; }
  function findGeneral(color, b) { for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) { const p = b[y][x]; if (p && p.color === color && p.type === "G") return { x, y }; } return null; }

  function getPseudoMoves(board, x, y) {
    const piece = board[y][x];
    if (!piece) return [];
    const { color, type } = piece;
    const moves = [];
    if (type === "G") {
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for (const [dx, dy] of dirs) {
        const nx = x + dx, ny = y + dy;
        if (!inBounds(nx, ny) || !inPalace(nx, ny, color)) continue;
        const t = board[ny][nx];
        if (!t || t.color !== color) moves.push({ x: nx, y: ny });
      }
    } else if (type === "A") {
      for (const [dx, dy] of [[1,1],[1,-1],[-1,1],[-1,-1]]) {
        const nx = x + dx, ny = y + dy;
        if (!inBounds(nx, ny) || !inPalace(nx, ny, color)) continue;
        const t = board[ny][nx];
        if (!t || t.color !== color) moves.push({ x: nx, y: ny });
      }
    } else if (type === "E") {
      for (const [dx, dy] of [[2,2],[2,-2],[-2,2],[-2,-2]]) {
        const nx = x + dx, ny = y + dy;
        const ex = x + dx/2, ey = y + dy/2;
        if (!inBounds(nx, ny)) continue;
        if (!sameSideOfRiver(y, ny, color)) continue;
        if (board[ey][ex]) continue;
        const t = board[ny][nx];
        if (!t || t.color !== color) moves.push({ x: nx, y: ny });
      }
    } else if (type === "H") {
      const defs = [
        { leg:[1,0], dest:[2,1] }, { leg:[1,0], dest:[2,-1] },
        { leg:[-1,0], dest:[-2,1] }, { leg:[-1,0], dest:[-2,-1] },
        { leg:[0,1], dest:[1,2] }, { leg:[0,1], dest:[-1,2] },
        { leg:[0,-1], dest:[1,-2] }, { leg:[0,-1], dest:[-1,-2] }
      ];
      for (const m of defs) {
        const lx = x + m.leg[0], ly = y + m.leg[1];
        if (!inBounds(lx, ly) || board[ly][lx]) continue;
        const nx = x + m.dest[0], ny = y + m.dest[1];
        if (!inBounds(nx, ny)) continue;
        const t = board[ny][nx];
        if (!t || t.color !== color) moves.push({ x: nx, y: ny });
      }
    } else if (type === "R") {
      for (const [dx, dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
        let nx = x + dx, ny = y + dy;
        while (inBounds(nx, ny)) {
          const t = board[ny][nx];
          if (!t) moves.push({ x: nx, y: ny });
          else { if (t.color !== color) moves.push({ x: nx, y: ny }); break; }
          nx += dx; ny += dy;
        }
      }
    } else if (type === "C") {
      for (const [dx, dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
        let nx = x + dx, ny = y + dy;
        while (inBounds(nx, ny) && !board[ny][nx]) { moves.push({ x: nx, y: ny }); nx += dx; ny += dy; }
        nx += dx; ny += dy;
        while (inBounds(nx, ny)) {
          const t = board[ny][nx];
          if (t) { if (t.color !== color) moves.push({ x: nx, y: ny }); break; }
          nx += dx; ny += dy;
        }
      }
    } else if (type === "S") {
      const dir = color === RED ? -1 : 1;
      const ny = y + dir;
      if (inBounds(x, ny)) {
        const t = board[ny][x]; if (!t || t.color !== color) moves.push({ x, y: ny });
      }
      if (hasCrossedRiver(y, color)) {
        for (const dx of [-1, 1]) {
          const nx = x + dx; if (!inBounds(nx, y)) continue;
          const t = board[y][nx]; if (!t || t.color !== color) moves.push({ x: nx, y });
        }
      }
    }
    return moves;
  }

  function violatesFlyingGeneral(board) {
    const redG = findGeneral(RED, board);
    const blackG = findGeneral(BLACK, board);
    if (!redG || !blackG) return false;
    if (redG.x !== blackG.x) return false;
    const x = redG.x;
    const [y1, y2] = redG.y < blackG.y ? [redG.y, blackG.y] : [blackG.y, redG.y];
    for (let y = y1 + 1; y < y2; y++) { if (board[y][x]) return false; }
    return true;
  }

  function isInCheck(board, color) {
    const gen = findGeneral(color, board);
    if (!gen) return false;
    const enemy = color === RED ? BLACK : RED;
    const redG = findGeneral(RED, board);
    const blackG = findGeneral(BLACK, board);
    if (redG && blackG && redG.x === blackG.x) {
      const x = redG.x;
      let blocked = false;
      const [y1, y2] = redG.y < blackG.y ? [redG.y, blackG.y] : [blackG.y, redG.y];
      for (let y = y1 + 1; y < y2; y++) { if (board[y][x]) { blocked = true; break; } }
      if (!blocked) return true;
    }
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const p = board[y][x];
        if (!p || p.color !== enemy) continue;
        const pseudo = getPseudoMoves(board, x, y);
        if (pseudo.some(m => m.x === gen.x && m.y === gen.y)) return true;
      }
    }
    return false;
  }

  function legalMovesFrom(board, x, y, color) {
    const p = board[y][x];
    if (!p || p.color !== color) return [];
    const pseudo = getPseudoMoves(board, x, y);
    const legal = [];
    for (const m of pseudo) {
      const bCopy = cloneBoard(board);
      applyMove(bCopy, { x, y }, m);
      if (violatesFlyingGeneral(bCopy)) continue;
      if (isInCheck(bCopy, color)) continue;
      legal.push(m);
    }
    return legal;
  }

  function hasAnyLegalMove(board, color) {
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const p = board[y][x];
        if (!p || p.color !== color) continue;
        if (legalMovesFrom(board, x, y, color).length) return true;
      }
    }
    return false;
  }

  // ---------- AI ----------
  const VALUES = { G: 1000, R: 10, C: 7, H: 5, E: 3, A: 3, S: 2 };
  function pieceValue(t) { return VALUES[t] || 0; }

  function squareAttackedBy(board, color, x, y) {
    for (let yy = 0; yy < board.length; yy++) {
      for (let xx = 0; xx < board[0].length; xx++) {
        const p = board[yy][xx];
        if (!p || p.color !== color) continue;
        const pseudo = getPseudoMoves(board, xx, yy);
        if (pseudo.some(m => m.x === x && m.y === y)) return true;
      }
    }
    return false;
  }

  function evaluateMove(board, move, color) {
    const { from, to, piece } = move;
    const bCopy = cloneBoard(board);
    const target = bCopy[to.y][to.x];
    const captureScore = target ? pieceValue(target.type) * 12 : 0;
    applyMove(bCopy, from, to);
    let activity = 0;
    if (piece.type === "S") {
      activity += (color === BLACK ? (to.y - from.y) : (from.y - to.y)) * 2;
      if (color === BLACK ? to.y >= 5 : to.y <= 4) activity += 2;
    }
    if (piece.type === "R") { activity += 4 + (4 - Math.abs(to.x - 4)); }
    if (piece.type === "C") activity += 2;
    const danger = squareAttackedBy(bCopy, color === BLACK ? RED : BLACK, to.x, to.y) ? pieceValue(piece.type) * 6 : 0;
    const enemy = color === BLACK ? RED : BLACK;
    const checkBonus = isInCheck(bCopy, enemy) ? 30 : 0;
    return captureScore + activity + checkBonus - danger + Math.random() * 0.1;
  }

  function legalMovesForColor(board, color) {
    const moves = [];
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const p = board[y][x];
        if (!p || p.color !== color) continue;
        for (const mv of legalMovesFrom(board, x, y, color)) moves.push({ from:{ x, y }, to: mv, piece: p });
      }
    }
    return moves;
  }

  function chooseAIMove(board, color = BLACK, level = "medium") {
    const moves = legalMovesForColor(board, color);
    if (!moves.length) return null;
    if (level === "easy") return moves[Math.floor(Math.random() * moves.length)];
    let best = -Infinity; let bestMoves = [];
    for (const mv of moves) {
      const score = evaluateMove(board, mv, color);
      if (score > best) { best = score; bestMoves = [mv]; }
      else if (score === best) { bestMoves.push(mv); }
    }
    return bestMoves[Math.floor(Math.random() * bestMoves.length)];
  }

  // ---------- Piece display ----------
  function pieceChar(p) {
    if (p.color === RED) {
      if (p.type === "G") return "帥";
      if (p.type === "A") return "仕";
      if (p.type === "E") return "相";
      if (p.type === "H") return "傌";
      if (p.type === "R") return "俥";
      if (p.type === "C") return "炮";
      if (p.type === "S") return "兵";
    } else {
      if (p.type === "G") return "將";
      if (p.type === "A") return "士";
      if (p.type === "E") return "象";
      if (p.type === "H") return "馬";
      if (p.type === "R") return "車";
      if (p.type === "C") return "砲";
      if (p.type === "S") return "卒";
    }
    return "?";
  }
})();
</script>
</body>
</html>
