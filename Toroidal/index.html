<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Toroidal Chess</title>
	<style>
		html, body { margin:0; padding:0; width:100%; height:100%; background:#0a0e16; color:#e8edf7; font-family:"Segoe UI", system-ui, sans-serif; overflow:hidden; }
		#game-container { position:relative; width:100vw; height:100vh; overflow:hidden; background:radial-gradient(circle at 18% 24%, rgba(59,130,246,0.12), transparent 48%), radial-gradient(circle at 78% 72%, rgba(251,191,36,0.12), transparent 46%), #0a0e16; }
		canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }
		.layer-board { z-index:0; pointer-events:none; }
		.layer-pieces { z-index:1; pointer-events:none; }
		#hud { position:absolute; top:10px; left:10px; z-index:5; display:flex; flex-direction:column; gap:8px; }
		.panel { background:rgba(0,0,0,0.6); border:1px solid #1f2430; border-radius:10px; padding:10px 12px; min-width:260px; box-shadow:0 10px 28px rgba(0,0,0,0.35); }
		.panel h4 { margin:0 0 6px 0; font-size:13px; letter-spacing:0.5px; color:#ffc857; }
		.panel p { margin:4px 0; font-size:13px; }
		#controls { display:flex; gap:8px; flex-wrap:wrap; }
		#controls button { padding:8px 10px; border:none; border-radius:8px; background:#252a38; color:#e8e8ec; cursor:pointer; font-size:13px; }
		#controls button.primary { background:linear-gradient(135deg, #38bdf8, #6366f1); color:#0a0e16; }
		#controls button:disabled { opacity:0.55; cursor:not-allowed; }
		.history-panel { position:relative; max-height:260px; overflow-y:auto; font-family:monospace; font-size:12px; }
		.history-panel .move-line { margin:2px 0; }
		.history-close { position:absolute; top:6px; right:6px; padding:4px 8px; border:none; border-radius:6px; background:#252a38; color:#e8e8ec; cursor:pointer; font-size:11px; }
		#btn-history { display:none; }
		@media (max-width:820px) {
			#hud { position:fixed; top:auto; bottom:0; left:0; right:0; flex-direction:row; gap:6px; padding:6px; background:linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.45) 40%); backdrop-filter:blur(8px); }
			#hud .panel { min-width:0; flex:1; }
			#history { display:none; position:fixed; right:8px; bottom:78px; width:82vw; max-width:380px; max-height:55vh; z-index:12; background:rgba(0,0,0,0.85); border-radius:10px; }
			#history.show { display:block; }
			#btn-history { display:inline-block; }
		}
		#start-overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.72); z-index:10; }
		#start-card { background:#161820; border:1px solid #262c3a; border-radius:12px; padding:18px 22px; color:#f5f5f5; min-width:320px; box-shadow:0 12px 30px rgba(0,0,0,0.35); }
		#start-card h2 { margin:0 0 10px 0; font-size:20px; }
		#start-card p { margin:0 0 12px 0; font-size:14px; color:#cfd3dd; }
		#start-card .btn-row { display:flex; gap:10px; margin-top:10px; }
		#start-card button { flex:1; padding:10px 12px; border:none; border-radius:8px; background:linear-gradient(135deg, #38bdf8, #6366f1); color:#0a0e16; font-weight:700; cursor:pointer; }
		#start-card button.secondary { background:#3a3f4f; color:#f5f5f5; }
		#start-card button.active { outline:2px solid #fff; }
		#rules-overlay { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.7); z-index:11; }
		#rules-overlay.show { display:flex; }
		#rules-card { background:#161820; border:1px solid #262c3a; border-radius:12px; padding:18px 22px; color:#f5f5f5; max-width:820px; width:90%; box-shadow:0 12px 30px rgba(0,0,0,0.35); line-height:1.45; }
		#rules-card h3 { margin:0 0 8px 0; font-size:18px; }
		#rules-card ul { margin:8px 0 0 18px; padding:0; }
		#rules-card li { margin:4px 0; }
		#close-rules { margin-top:12px; padding:8px 12px; border:none; border-radius:8px; background:#3a3f4f; color:#fff; cursor:pointer; }
	</style>
</head>
<body>
<div id="game-container">
	<div id="hud">
		<div class="panel">
			<h4>Status</h4>
			<p id="turn-text">Turn: --</p>
			<p id="ai-text">AI: --</p>
			<p id="msg-text">Ready</p>
			<p id="lastmove-text">Last: --</p>
		</div>
		<div id="controls" class="panel">
			<button id="btn-start" class="primary">New Game</button>
			<button id="btn-reset">Reset</button>
			<button id="btn-undo">Undo</button>
			<button id="btn-history">History</button>
			<button id="btn-rules">Rules</button>
		</div>
		<div id="history" class="panel history-panel">
			<h4>Moves</h4>
			<button id="btn-history-close" class="history-close">Close</button>
			<div id="move-list"></div>
		</div>
	</div>

	<div id="start-overlay">
		<div id="start-card">
			<h2>Toroidal Chess</h2>
			<p>Standard chess pieces on an 8×8 board where edges wrap: files and ranks connect like a torus. No castling or en passant; promotion to queen on the far rank.</p>
			<div class="btn-row">
				<button id="btn-1p">1 Player (vs AI)</button>
				<button id="btn-2p" class="secondary">2 Players</button>
			</div>
			<p style="margin-top:12px; margin-bottom:6px;">AI Difficulty</p>
			<div class="btn-row">
				<button id="btn-easy" class="active">Easy</button>
				<button id="btn-med" class="secondary">Medium</button>
			</div>
			<p style="margin-top:12px; margin-bottom:6px;">Start</p>
			<div class="btn-row" style="margin-top:8px;">
				<button id="btn-start-overlay" class="primary">Start Game</button>
			</div>
		</div>
	</div>

	<div id="rules-overlay">
		<div id="rules-card">
			<h3>Rules (toroidal)</h3>
			<ul>
				<li>Board: 8×8; edges wrap. Moving off a side re-enters from the opposite side. Sliders continue across wraps until blocked or return to origin.</li>
				<li>Pieces: standard chess moves, but all moves use wraparound coordinates. Castling and en passant are disabled. No double pawn push.</li>
				<li>Pawns: 1 step forward; capture forward-diagonal. Promotion to queen on the far rank (row 0 for White, row 7 for Black).</li>
				<li>Check/checkmate as usual; stalemate is a loss for the side with no legal moves.</li>
				<li>Controls: click to select/move; U undo; R reset; H rules.</li>
			</ul>
			<button id="close-rules">Close</button>
		</div>
	</div>
</div>

<script>
(() => {
	const ROWS = 8, COLS = 8;
	const WHITE = 1, BLACK = 2;
	const dpr = window.devicePixelRatio || 1;

	const GLYPH = {
		[WHITE]: { K:'♔', Q:'♕', R:'♖', B:'♗', N:'♘', P:'♙' },
		[BLACK]: { K:'♚', Q:'♛', R:'♜', B:'♝', N:'♞', P:'♟' }
	};

	const VAL = { K: 99999, Q: 900, R: 500, B: 330, N: 320, P: 100 };

	const container = document.getElementById('game-container');
	const startOverlay = document.getElementById('start-overlay');
	const btn1p = document.getElementById('btn-1p');
	const btn2p = document.getElementById('btn-2p');
	const btnEasy = document.getElementById('btn-easy');
	const btnMed = document.getElementById('btn-med');
	const btnStartOverlay = document.getElementById('btn-start-overlay');
	const btnRules = document.getElementById('btn-rules');
	const rulesOverlay = document.getElementById('rules-overlay');
	const closeRules = document.getElementById('close-rules');
	const hudBtnStart = document.getElementById('btn-start');
	const hudBtnReset = document.getElementById('btn-reset');
	const hudBtnUndo = document.getElementById('btn-undo');
	const hudBtnHistory = document.getElementById('btn-history');
	const btnHistoryClose = document.getElementById('btn-history-close');
	const historyPanel = document.getElementById('history');
	const turnText = document.getElementById('turn-text');
	const aiText = document.getElementById('ai-text');
	const msgText = document.getElementById('msg-text');
	const lastMoveText = document.getElementById('lastmove-text');
	const moveList = document.getElementById('move-list');

	const boardLayer = document.createElement('canvas');
	const piecesLayer = document.createElement('canvas');
	boardLayer.className = 'layer-board';
	piecesLayer.className = 'layer-pieces';
	container.appendChild(boardLayer);
	container.appendChild(piecesLayer);

	const layout = { width:0, height:0, cell:0, offsetX:0, offsetY:0 };

	const state = {
		board: [],
		turn: WHITE,
		vsAI: true,
		aiColor: BLACK,
		aiDepth: 1,
		gameOver: false,
		history: [],
		lastMove: null,
		lastMoveHighlight: null,
		selected: null,
		moves: [],
		undoStack: []
	};

	function makePiece(c,t,p=false){ return { c, t, p }; }
	const wrapR = r => (r + ROWS) % ROWS;
	const wrapC = c => (c + COLS) % COLS;

	function setupBoard() {
		state.board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
		const back = ['R','N','B','Q','K','B','N','R'];
		for (let c=0;c<COLS;c++) {
			state.board[7][c] = makePiece(WHITE, back[c]);
			state.board[0][c] = makePiece(BLACK, back[c]);
			state.board[6][c] = makePiece(WHITE, 'P');
			state.board[1][c] = makePiece(BLACK, 'P');
		}
		state.turn = WHITE;
		state.history = [];
		state.lastMove = null;
		state.lastMoveHighlight = null;
		state.selected = null;
		state.moves = [];
		state.undoStack = [];
		state.gameOver = false;
		msgText.textContent = 'Game on';
	}

	function resetGame() {
		setupBoard();
		updateHud();
		resizeAndRedraw();
		maybeAIMove();
	}

	function cloneBoard(b=state.board){ return b.map(row => row.map(p => p ? { ...p } : null)); }

	function applyMove(b, mv) {
		const { fr, fc, tr, tc, promo } = mv;
		const piece = { ...b[fr][fc] };
		b[fr][fc] = null;
		if (promo) piece.t = 'Q';
		b[tr][tc] = piece;
	}

	function kingPos(b, color) {
		for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
			const p = b[r][c];
			if (p && p.c === color && p.t === 'K') return { r, c };
		}
		return null;
	}

	function slideMoves(r,c,b,dirs,color){
		const res=[];
		for (const [dr,dc] of dirs){
			let step=1; let nr=r, nc=c;
			while (true) {
				nr = wrapR(nr+dr); nc = wrapC(nc+dc);
				if (nr===r && nc===c) break; // looped around
				const t = b[nr][nc];
				if (!t) { res.push({r:nr,c:nc}); step++; continue; }
				if (t.c !== color) res.push({r:nr,c:nc});
				break;
			}
		}
		return res;
	}

	function attacksFrom(r,c,p,b){
		const moves = [];
		const dir = p.c === WHITE ? -1 : 1;
		const kingD = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
		if (p.t==='K') {
			for (const [dr,dc] of kingD) { moves.push({r:wrapR(r+dr), c:wrapC(c+dc)}); }
			return moves;
		}
		if (p.t==='Q') return slideMoves(r,c,b,[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], p.c);
		if (p.t==='R') return slideMoves(r,c,b,[[1,0],[-1,0],[0,1],[0,-1]], p.c);
		if (p.t==='B') return slideMoves(r,c,b,[[1,1],[1,-1],[-1,1],[-1,-1]], p.c);
		if (p.t==='N') {
			const deltas = [[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]];
			for (const [dr,dc] of deltas) moves.push({r:wrapR(r+dr), c:wrapC(c+dc)});
			return moves;
		}
		if (p.t==='P') {
			const f = wrapR(r+dir);
			moves.push({r:f, c});
			moves.push({r:wrapR(r+dir), c:wrapC(c+1)});
			moves.push({r:wrapR(r+dir), c:wrapC(c-1)});
			return moves;
		}
		return moves;
	}

	function pseudoMoves(b, color) {
		const res = [];
		for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
			const p = b[r][c]; if (!p || p.c !== color) continue;
			const att = attacksFrom(r,c,p,b);
			for (const m of att) {
				const t = b[m.r][m.c];
				if (p.t==='P') {
					const isForward = (m.c===c) && !t;
					const isCapture = (m.c!==c) && t && t.c!==color;
					if (!isForward && !isCapture) continue;
				}
				if (t && t.c===color) continue;
				const mv = { fr:r, fc:c, tr:m.r, tc:m.c, promo:false };
				if (p.t==='P') {
					if ((p.c===WHITE && mv.tr===0) || (p.c===BLACK && mv.tr===ROWS-1)) mv.promo = true;
				}
				res.push(mv);
			}
		}
		return res;
	}

	function isCheck(b, color) {
		const k = kingPos(b, color); if (!k) return true;
		const enemy = color===WHITE?BLACK:WHITE;
		for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
			const p = b[r][c]; if(!p || p.c!==enemy) continue;
			const att = attacksFrom(r,c,p,b);
			if (att.some(m => m.r===k.r && m.c===k.c && (!b[m.r][m.c] || b[m.r][m.c].c!==enemy))) return true;
		}
		return false;
	}

	function legalMoves(b, color) {
		const res = [];
		for (const mv of pseudoMoves(b, color)) {
			const nb = cloneBoard(b);
			applyMove(nb, mv);
			if (!isCheck(nb, color)) res.push(mv);
		}
		return res;
	}

	function evaluate(b, pov){
		let s=0;
		for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
			const p=b[r][c]; if(!p) continue;
			s += (p.c===pov?1:-1) * (VAL[p.t] + (p.t==='P' ? 2*(p.c===WHITE ? (ROWS-1-r) : r) : 0));
		}
		return s + (Math.random()-0.5)*2.5;
	}

	function minimax(b, depth, alpha, beta, maximizing, pov){
		if (depth===0) return { score: evaluate(b,pov) };
		const color = maximizing ? pov : (pov===WHITE?BLACK:WHITE);
		const moves = legalMoves(b, color);
		if (!moves.length) {
			const inChk = isCheck(b, color);
			const score = inChk ? (maximizing ? -999999 : 999999) : (maximizing ? -800000 : 800000);
			return { score };
		}
		let bestMove=null;
		if (maximizing) {
			let best=-Infinity;
			for (const mv of moves){
				const nb=cloneBoard(b); applyMove(nb,mv);
				const res=minimax(nb, depth-1, alpha, beta, false, pov);
				if (res.score>best){ best=res.score; bestMove=mv; }
				alpha=Math.max(alpha,res.score); if (beta<=alpha) break;
			}
			return { score:best, move:bestMove };
		} else {
			let best=Infinity;
			for (const mv of moves){
				const nb=cloneBoard(b); applyMove(nb,mv);
				const res=minimax(nb, depth-1, alpha, beta, true, pov);
				if (res.score<best){ best=res.score; bestMove=mv; }
				beta=Math.min(beta,res.score); if (beta<=alpha) break;
			}
			return { score:best, move:bestMove };
		}
	}

	function updateHud() {
		turnText.textContent = `Turn: ${state.turn === WHITE ? 'White' : 'Black'}`;
		aiText.textContent = state.vsAI ? `AI: ${state.aiColor === WHITE ? 'White' : 'Black'} (${state.aiDepth===1?'Easy':'Medium'})` : 'AI: Off';
		lastMoveText.textContent = state.lastMove ? `Last: ${state.lastMove}` : 'Last: --';
	}

	function pushHistory(statusText) {
		moveList.innerHTML = '';
		state.history.forEach((m, i) => {
			const div = document.createElement('div');
			div.className = 'move-line';
			div.textContent = `${i+1}. ${m}`;
			moveList.appendChild(div);
		});
		msgText.textContent = statusText;
	}

	function coordsFromEvent(evt) {
		const rect = container.getBoundingClientRect();
		const x = (evt.clientX - rect.left) * dpr;
		const y = (evt.clientY - rect.top) * dpr;
		const col = Math.floor((x - layout.offsetX*dpr) / (layout.cell*dpr));
		const row = Math.floor((y - layout.offsetY*dpr) / (layout.cell*dpr));
		return { row, col };
	}

	function handleClick(evt) {
		if (state.gameOver || startOverlay.style.display !== 'none') return;
		const { row, col } = coordsFromEvent(evt);
		if (row<0 || row>=ROWS || col<0 || col>=COLS) return;
		const piece = state.board[row][col];
		if (state.selected) {
			const mv = state.moves.find(m => m.tr===row && m.tc===col);
			if (mv) { makeMove(mv); return; }
			state.selected = null; state.moves = []; redrawPieces(); return;
		}
		if (piece && piece.c === state.turn && (!state.vsAI || piece.c !== state.aiColor)) {
			state.selected = { r:row, c:col };
			state.moves = legalMoves(state.board, state.turn).filter(m => m.fr===row && m.fc===col);
		} else {
			state.selected = null; state.moves = [];
		}
		redrawPieces();
	}

	function makeMove(mv) {
		state.undoStack.push({
			board: cloneBoard(state.board),
			turn: state.turn,
			history: [...state.history],
			lastMove: state.lastMove,
			lastMoveHighlight: state.lastMoveHighlight,
			gameOver: state.gameOver
		});

		applyMove(state.board, mv);
		state.lastMoveHighlight = mv;
		const moveStr = `${fileChar(mv.fc)}${8-mv.fr}→${fileChar(mv.tc)}${8-mv.tr}${mv.promo?'+':''}`;
		state.history.push(moveStr);
		state.lastMove = moveStr;

		state.turn = state.turn === WHITE ? BLACK : WHITE;
		state.selected = null; state.moves = [];

		const opp = state.turn;
		const oppMoves = legalMoves(state.board, opp);
		if (!oppMoves.length) {
			const inChk = isCheck(state.board, opp);
			state.gameOver = true;
			msgText.textContent = inChk ? 'Checkmate' : 'No legal moves';
		} else {
			msgText.textContent = isCheck(state.board, opp) ? 'Check' : 'Game on';
		}
		updateHud();
		redrawAll();
		maybeAIMove();
	}

	function fileChar(c){ return String.fromCharCode('a'.charCodeAt(0)+c); }

	function undo() {
		if (!state.undoStack.length) return;
		const snap = state.undoStack.pop();
		state.board = snap.board;
		state.turn = snap.turn;
		state.history = snap.history;
		state.lastMove = snap.lastMove;
		state.lastMoveHighlight = snap.lastMoveHighlight;
		state.gameOver = snap.gameOver;
		state.selected = null;
		state.moves = [];
		msgText.textContent = 'Undo';
		redrawAll();
		updateHud();
	}

	function aiMove() {
		if (!state.vsAI || state.turn !== state.aiColor || state.gameOver) return;
		const depth = state.aiDepth;
		const maximizing = state.aiColor === WHITE;
		const res = minimax(state.board, depth, -Infinity, Infinity, maximizing, state.aiColor);
		if (res.move) makeMove(res.move);
	}

	function maybeAIMove() {
		if (state.vsAI && state.turn === state.aiColor && !state.gameOver) {
			setTimeout(aiMove, 120);
		}
	}

	function resize() {
		layout.width = container.clientWidth;
		layout.height = container.clientHeight;
		const size = Math.min(layout.width * 0.92, layout.height * 0.92);
		layout.cell = size / COLS;
		layout.offsetX = (layout.width - layout.cell*COLS) / 2;
		layout.offsetY = (layout.height - layout.cell*ROWS) / 2;
		[boardLayer, piecesLayer].forEach(layer => {
			layer.width = layout.width * dpr;
			layer.height = layout.height * dpr;
			layer.style.width = layout.width + 'px';
			layer.style.height = layout.height + 'px';
			const ctx = layer.getContext('2d');
			ctx.setTransform(dpr,0,0,dpr,0,0);
		});
	}

	function drawBoard() {
		const ctx = boardLayer.getContext('2d');
		ctx.clearRect(0,0,layout.width, layout.height);
		for (let r=0;r<ROWS;r++) {
			for (let c=0;c<COLS;c++) {
				const light = (r+c)%2===0;
				ctx.fillStyle = light ? '#e6d3b1' : '#b48b67';
				ctx.fillRect(layout.offsetX + c*layout.cell, layout.offsetY + r*layout.cell, layout.cell, layout.cell);
			}
		}
		ctx.strokeStyle = 'rgba(0,0,0,0.35)';
		ctx.lineWidth = 1;
		for (let i=0;i<=ROWS;i++) {
			const y = layout.offsetY + i*layout.cell;
			ctx.beginPath();
			ctx.moveTo(layout.offsetX, y);
			ctx.lineTo(layout.offsetX + layout.cell*COLS, y);
			ctx.stroke();
		}
		for (let j=0;j<=COLS;j++) {
			const x = layout.offsetX + j*layout.cell;
			ctx.beginPath();
			ctx.moveTo(x, layout.offsetY);
			ctx.lineTo(x, layout.offsetY + layout.cell*ROWS);
			ctx.stroke();
		}
		if (state.lastMoveHighlight) {
			ctx.fillStyle = 'rgba(56,189,248,0.24)';
			const { fr, fc, tr, tc } = state.lastMoveHighlight;
			ctx.fillRect(layout.offsetX + fc*layout.cell, layout.offsetY + fr*layout.cell, layout.cell, layout.cell);
			ctx.fillRect(layout.offsetX + tc*layout.cell, layout.offsetY + tr*layout.cell, layout.cell, layout.cell);
		}
	}

	function redrawPieces() {
		const ctx = piecesLayer.getContext('2d');
		ctx.clearRect(0,0,layout.width, layout.height);
		ctx.textAlign = 'center';
		ctx.textBaseline = 'middle';
		ctx.font = `${layout.cell * 0.62}px "Segoe UI Symbol"`;
		for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
			const p = state.board[r][c]; if (!p) continue;
			ctx.fillStyle = p.c === WHITE ? '#ffffff' : '#0f131b';
			ctx.fillText(GLYPH[p.c][p.t], layout.offsetX + c*layout.cell + layout.cell/2, layout.offsetY + r*layout.cell + layout.cell/2 + 1);
		}
		if (state.selected) {
			ctx.strokeStyle = 'rgba(99,102,241,0.9)';
			ctx.lineWidth = 3;
			ctx.strokeRect(layout.offsetX + state.selected.c*layout.cell + 2, layout.offsetY + state.selected.r*layout.cell + 2, layout.cell-4, layout.cell-4);
			ctx.fillStyle = 'rgba(99,102,241,0.3)';
			for (const mv of state.moves) {
				ctx.beginPath();
				ctx.arc(layout.offsetX + mv.tc*layout.cell + layout.cell/2, layout.offsetY + mv.tr*layout.cell + layout.cell/2, layout.cell*0.18, 0, Math.PI*2);
				ctx.fill();
			}
		}
	}

	function redrawAll() { drawBoard(); redrawPieces(); pushHistory(msgText.textContent); }
	function resizeAndRedraw() { resize(); redrawAll(); }

	function bindUI() {
		container.addEventListener('click', handleClick);
		window.addEventListener('resize', resizeAndRedraw);
		window.addEventListener('keyup', e => {
			if (e.key === 'u' || e.key === 'U') undo();
			if (e.key === 'r' || e.key === 'R') resetGame();
			if (e.key === 'h' || e.key === 'H') rulesOverlay.classList.add('show');
		});

		btn1p.addEventListener('click', () => { state.vsAI = true; state.aiColor = BLACK; toggleSelect(btn1p, btn2p); });
		btn2p.addEventListener('click', () => { state.vsAI = false; toggleSelect(btn2p, btn1p); });
		btnEasy.addEventListener('click', () => { state.aiDepth = 1; setDiff(btnEasy); });
		btnMed.addEventListener('click', () => { state.aiDepth = 2; setDiff(btnMed); });
		btnStartOverlay.addEventListener('click', () => { startOverlay.style.display = 'none'; resetGame(); });

		hudBtnStart.addEventListener('click', resetGame);
		hudBtnReset.addEventListener('click', resetGame);
		hudBtnUndo.addEventListener('click', undo);
		btnRules.addEventListener('click', () => rulesOverlay.classList.add('show'));
		closeRules.addEventListener('click', () => rulesOverlay.classList.remove('show'));

		hudBtnHistory.addEventListener('click', () => historyPanel.classList.toggle('show'));
		btnHistoryClose.addEventListener('click', () => historyPanel.classList.remove('show'));
	}

	function toggleSelect(on, off) { on.classList.remove('secondary'); off.classList.add('secondary'); }
	function setDiff(btn) { [btnEasy, btnMed].forEach(b => b.classList.remove('active')); btn.classList.add('active'); }

	setupBoard();
	resize();
	redrawAll();
	bindUI();
})();
</script>
</body>
</html>
