<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Baby Chess  Standalone</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #0f0f12;
        overflow: hidden;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        color: #eee;
    }
    #game-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background: #0f0f12;
    }
    canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
    }
    .layer-board { z-index: 0; pointer-events: none; }
    .layer-pieces { z-index: 1; pointer-events: none; }
    .layer-ui { z-index: 2; }
    #start-overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0,0,0,0.7);
        z-index: 10;
    }
    #start-card {
        background: #1d1d1f;
        border: 1px solid #333;
        border-radius: 12px;
        padding: 18px 22px;
        color: #f5f5f5;
        min-width: 280px;
        box-shadow: 0 12px 30px rgba(0,0,0,0.35);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    #start-card h2 { margin: 0 0 10px 0; font-size: 20px; }
    #start-card p { margin: 0 0 12px 0; font-size: 14px; color: #ccc; }
    #start-card .btn-row { display: flex; gap: 10px; margin-top: 10px; }
    #start-card button {
        flex: 1;
        padding: 10px 12px;
        border: none;
        border-radius: 8px;
        background: linear-gradient(135deg, #ffb74d, #f57c00);
        color: #fff;
        font-weight: 700;
        cursor: pointer;
    }
    #start-card button.secondary { background: #444; }
    #start-card button.active { outline: 2px solid #fff; }
    #hud {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 5;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    .panel {
        background: rgba(0,0,0,0.5);
        border: 1px solid #333;
        border-radius: 10px;
        padding: 10px 12px;
        min-width: 220px;
        color: #eee;
        box-shadow: 0 8px 20px rgba(0,0,0,0.3);
    }
    .panel h4 { margin: 0 0 6px 0; font-size: 13px; letter-spacing: 0.5px; color: #ffd166; }
    .panel p { margin: 4px 0; font-size: 13px; }
    #controls { display: flex; gap: 8px; flex-wrap: wrap; }
    #controls button { padding: 8px 10px; border: none; border-radius: 8px; background: #2d2d33; color: #eee; cursor: pointer; font-size: 13px; }
    #controls button.primary { background: linear-gradient(135deg, #ffb74d, #f57c00); color: #fff; }
    .history-panel { position: relative; max-height: 260px; overflow-y: auto; font-family: monospace; font-size: 12px; }
    .history-panel .move-line { margin: 2px 0; }
    .history-close { position: absolute; top: 6px; right: 6px; padding: 4px 8px; border: none; border-radius: 6px; background: #2d2d33; color: #eee; cursor: pointer; font-size: 11px; }
    #btn-history { display: none; }
    @media (max-width: 720px) {
        #hud { position: fixed; top: auto; bottom: 0; left: 0; right: 0; flex-direction: row; gap: 6px; padding: 6px; background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.45) 40%); backdrop-filter: blur(8px); }
        #hud .panel { min-width: 0; flex: 1; }
        #history { display: none; position: fixed; right: 8px; bottom: 78px; width: 82vw; max-width: 380px; max-height: 55vh; z-index: 12; background: rgba(0,0,0,0.85); border-radius: 10px; }
        #history.show { display: block; }
        #btn-history { display: inline-block; }
    }
    #rules-overlay {
        position: absolute; inset: 0;
        display: none; align-items: center; justify-content: center;
        background: rgba(0,0,0,0.7); z-index: 11;
    }
    #rules-overlay.show { display: flex; }
    #rules-card {
        background: #1d1d1f; border: 1px solid #333; border-radius: 12px;
        padding: 18px 22px; color: #f5f5f5; max-width: 640px; width: 90%;
        box-shadow: 0 12px 30px rgba(0,0,0,0.35); line-height: 1.45;
    }
    #rules-card h3 { margin: 0 0 8px 0; font-size: 18px; }
    #rules-card ul { margin: 8px 0 0 18px; padding: 0; }
    #rules-card li { margin: 4px 0; }
    #close-rules { margin-top: 12px; padding: 8px 12px; border: none; border-radius: 8px; background: #444; color: #fff; cursor: pointer; }
</style>
</head>
<body>
<div id="game-container">
    <div id="hud">
        <div class="panel">
            <h4>Status</h4>
            <p id="turn-text">Turn: --</p>
            <p id="ai-text">AI: --</p>
            <p id="msg-text">Ready</p>
            <p id="cap-text">Captures W:0 B:0</p>
            <p id="lastmove-text">Last: --</p>
        </div>
        <div id="controls" class="panel">
            <button id="btn-start" class="primary">New Game</button>
            <button id="btn-reset">Reset</button>
            <button id="btn-undo">Undo</button>
            <button id="btn-history">History</button>
            <button id="btn-rules">Rules</button>
        </div>
        <div id="history" class="panel history-panel">
            <h4>Moves</h4>
            <button id="btn-history-close" class="history-close">Close</button>
            <div id="move-list"></div>
        </div>
    </div>
    <div id="start-overlay">
        <div id="start-card">
            <h2>Baby Chess</h2>
            <p>Choose players, set difficulty, then Start Game.</p>
            <div class="btn-row">
                <button id="btn-1p">1 Player (vs AI)</button>
                <button id="btn-2p" class="secondary">2 Players</button>
            </div>
            <p style="margin-top:12px; margin-bottom:6px;">AI Difficulty</p>
            <div class="btn-row">
                <button id="btn-easy" class="secondary">Easy</button>
                <button id="btn-med" class="active">Medium</button>
                <button id="btn-hard" class="secondary">Hard</button>
            </div>
            <p style="margin-top:12px; margin-bottom:6px;">Start</p>
            <div class="btn-row" style="margin-top:8px;">
                <button id="btn-start-overlay" class="primary">Start Game</button>
            </div>
        </div>
    </div>
    <div id="rules-overlay">
        <div id="rules-card">
            <h3>Rules</h3>
            <ul>
                <li>5x6 board. Capture the king to win.</li>
                <li>No castling or en passant. Pawns move 1, capture diagonally, promote to queen on last rank.</li>
                <li>Starting setup: R N K N R on back rank, pawns in front.</li>
                <li>Controls: mouse click or keyboard arrows + Enter/Space. Controller stick/D-pad to move, A select/move, B cancel, X reset, LB undo, Y toggles rules. Start opens start screen.</li>
            </ul>
            <button id="close-rules">Close</button>
        </div>
    </div>
</div>
<script>
// Standalone Baby Chess (5x6)  no module imports, works via file://
(function() {
    const COLS = 5;
    const ROWS = 6;
    const dpr = window.devicePixelRatio || 1;
    const LIGHT = 1; // White
    const DARK = 2;  // Black
    const PIECE_VALUES = { K: 100, Q: 9, R: 5, B: 3, N: 3, P: 1 };
    const ruleLines = [
        "5x6 board. Capture the king to win.",
        "No castling or en passant. Pawns move 1, capture diagonally.",
        "Promotion to queen on last rank.",
        "AI plays simple capture-preferring moves."
    ];

    const container = document.getElementById("game-container");
    const startOverlay = document.getElementById("start-overlay");
    const btn1p = document.getElementById("btn-1p");
    const btn2p = document.getElementById("btn-2p");
    const btnEasy = document.getElementById("btn-easy");
    const btnMed = document.getElementById("btn-med");
    const btnHard = document.getElementById("btn-hard");
    const btnStartOverlay = document.getElementById("btn-start-overlay");
    const btnRules = document.getElementById("btn-rules");
    const rulesOverlay = document.getElementById("rules-overlay");
    const closeRules = document.getElementById("close-rules");
    const hud = document.getElementById("hud");
    const hudBtnStart = document.getElementById("btn-start");
    const hudBtnReset = document.getElementById("btn-reset");
    const hudBtnUndo = document.getElementById("btn-undo");
    const hudBtnHistory = document.getElementById("btn-history");
    const btnHistoryClose = document.getElementById("btn-history-close");
    const historyPanel = document.getElementById("history");
    const turnText = document.getElementById("turn-text");
    const aiText = document.getElementById("ai-text");
    const msgText = document.getElementById("msg-text");
    const capText = document.getElementById("cap-text");
    const lastMoveText = document.getElementById("lastmove-text");
    const moveList = document.getElementById("move-list");
    const boardLayer = document.createElement("canvas");
    const piecesLayer = document.createElement("canvas");
    const uiLayer = document.createElement("canvas");
    boardLayer.className = "layer-board";
    piecesLayer.className = "layer-pieces";
    uiLayer.className = "layer-ui";
    container.appendChild(boardLayer);
    container.appendChild(piecesLayer);
    container.appendChild(uiLayer);

    const layout = { width: 0, height: 0, boardSize: 0, cell: 0, offsetX: 0, offsetY: 0 };

    const state = {
        board: createEmptyBoard(),
        turn: LIGHT,
        moveHistory: [],
        lastMove: null,
        captures: { [LIGHT]: 0, [DARK]: 0 },
        gameOver: false,
        winner: null,
        message: "",
        cursor: { x: 2, y: 5 },
        selected: null,
        legal: [],
        aiEnabled: true,
        aiColor: DARK,
        aiLevel: "medium",
        thinking: false,
        menuActive: true
    };

    let selectedMode = "1p";
    let selectedDiff = "medium";

    function setBoardInput(enabled) {
        uiLayer.style.pointerEvents = enabled ? "auto" : "none";
    }

    function updateHud() {
        turnText.textContent = `Turn: ${state.turn === LIGHT ? "WHITE" : "BLACK"}`;
        aiText.textContent = state.aiEnabled ? `AI: ${state.aiLevel.toUpperCase()} (${state.aiColor === LIGHT ? "WHITE" : "BLACK"})` : "AI: OFF";
        if (state.gameOver && state.winner) msgText.textContent = `${state.winner} wins`;
        else msgText.textContent = state.message || "Ready";
        capText.textContent = `Captures W:${state.captures[LIGHT]} B:${state.captures[DARK]}`;
        if (state.lastMove) {
            const { from, to } = state.lastMove;
            lastMoveText.textContent = `Last: ${String.fromCharCode(97 + from.x)}${ROWS - from.y}${String.fromCharCode(97 + to.x)}${ROWS - to.y}`;
        } else {
            lastMoveText.textContent = "Last: --";
        }
        renderHistory();
    }

    function renderHistory() {
        const sq = (x, y) => `${String.fromCharCode(97 + x)}${ROWS - y}`;
        moveList.innerHTML = state.moveHistory.map((mv, i) => {
            const capMark = mv.captured ? "x" : "-";
            const promo = mv.promoted ? "=Q" : "";
            return `<div class="move-line">${i + 1}. ${sq(mv.from.x, mv.from.y)}${capMark}${sq(mv.to.x, mv.to.y)}${promo}</div>`;
        }).join("");
    }

    function toggleRules(force) {
        const show = force !== undefined ? force : !rulesOverlay.classList.contains("show");
        rulesOverlay.classList.toggle("show", show);
    }

    function toggleHistory(force) {
        const show = force !== undefined ? force : !historyPanel.classList.contains("show");
        historyPanel.classList.toggle("show", show);
    }

    function showStartOverlay() {
        startOverlay.style.display = "flex";
        state.menuActive = true;
        setBoardInput(false);
    }

    function createEmptyBoard() {
        return Array.from({ length: ROWS }, () => Array(COLS).fill(null));
    }

    function cloneBoard(b) {
        return b.map(row => row.map(p => p ? { ...p } : null));
    }

    function resetBoard() {
        const b = createEmptyBoard();
        // Black setup (top rows 0,1)
        b[0] = [p("r", DARK), p("n", DARK), p("k", DARK), p("n", DARK), p("r", DARK)];
        b[1] = Array(COLS).fill(p("p", DARK));
        // White setup (rows 4,5)
        b[ROWS - 2] = Array(COLS).fill(p("p", LIGHT));
        b[ROWS - 1] = [p("r", LIGHT), p("n", LIGHT), p("k", LIGHT), p("n", LIGHT), p("r", LIGHT)];

        state.board = b;
        state.turn = LIGHT;
        state.moveHistory = [];
        state.lastMove = null;
        state.captures = { [LIGHT]: 0, [DARK]: 0 };
        state.gameOver = false;
        state.winner = null;
        state.message = "";
        state.selected = null;
        state.legal = [];
        state.cursor = { x: 2, y: 5 };
        updateHud();
    }

    function p(type, color) {
        return { type: type.toUpperCase(), color };
    }

    function resize() {
        layout.width = window.innerWidth;
        layout.height = window.innerHeight;
        [boardLayer, piecesLayer, uiLayer].forEach(c => {
            c.width = layout.width * dpr;
            c.height = layout.height * dpr;
            c.style.width = `${layout.width}px`;
            c.style.height = `${layout.height}px`;
            const ctx = c.getContext("2d");
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        });

        const isMobile = window.matchMedia("(max-width: 720px)").matches;
        const leftPad = isMobile ? 0 : 12;
        const rightPad = isMobile ? 0 : 12;
        const availWidth = Math.max(420, layout.width - leftPad - rightPad);
        const maxBoardSize = Math.min(availWidth, layout.height * 0.95);

        layout.cell = maxBoardSize / Math.max(COLS, ROWS);
        const boardPixelWidth = layout.cell * COLS;
        const boardPixelHeight = layout.cell * ROWS;
        layout.boardSize = Math.max(boardPixelWidth, boardPixelHeight);

        layout.offsetX = leftPad + Math.max(0, (availWidth - boardPixelWidth) / 2);
        layout.offsetY = Math.max(0, (layout.height - boardPixelHeight) / 2);
        maybeRunAI();
    }

    function drawBoard(ctx) {
        ctx.clearRect(0, 0, layout.width, layout.height);
        ctx.fillStyle = "#0f0f12";
        ctx.fillRect(0, 0, layout.width, layout.height);

        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                const even = (x + y) % 2 === 0;
                ctx.fillStyle = even ? "#2f2f36" : "#454552";
                ctx.fillRect(layout.offsetX + x * layout.cell, layout.offsetY + y * layout.cell, layout.cell, layout.cell);
            }
        }
    }

    function drawPieces(ctx) {
        ctx.clearRect(0, 0, layout.width, layout.height);
        ctx.font = `${layout.cell * 0.55}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                const piece = state.board[y][x];
                if (!piece) continue;
                const cx = layout.offsetX + x * layout.cell + layout.cell / 2;
                const cy = layout.offsetY + y * layout.cell + layout.cell / 2;
                ctx.fillStyle = piece.color === LIGHT ? "#f5f5f5" : "#111";
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(cx, cy, layout.cell * 0.38, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = piece.color === LIGHT ? "#111" : "#f5f5f5";
                ctx.fillText(piece.type, cx, cy + layout.cell * 0.04);
            }
        }

        // Selection and last move highlights
        const ui = uiLayer.getContext("2d");
        ui.clearRect(0, 0, layout.width, layout.height);
        if (state.selected) {
            drawCellOutline(ui, state.selected.x, state.selected.y, "#ffb74d", 3);
            state.legal.forEach(m => drawCellOutline(ui, m.x, m.y, "#ffd166", 2));
        }
        if (state.lastMove) {
            drawCellOutline(ui, state.lastMove.from.x, state.lastMove.from.y, "#64b5f6", 2);
            drawCellOutline(ui, state.lastMove.to.x, state.lastMove.to.y, "#64b5f6", 2);
        }
        drawCursor(ui);
        drawUI(ui);
    }

    function drawCellOutline(ctx, x, y, color, w) {
        ctx.strokeStyle = color;
        ctx.lineWidth = w;
        ctx.strokeRect(layout.offsetX + x * layout.cell + 2, layout.offsetY + y * layout.cell + 2, layout.cell - 4, layout.cell - 4);
    }

    function drawCursor(ctx) {
        const { x, y } = state.cursor;
        ctx.strokeStyle = "#ffb74d";
        ctx.lineWidth = 2;
        ctx.strokeRect(layout.offsetX + x * layout.cell + 3, layout.offsetY + y * layout.cell + 3, layout.cell - 6, layout.cell - 6);
    }

    function drawUI(ctx) {
        // HUD moved to DOM panels; keep canvas UI minimal
        if (state.gameOver) {
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(14, 14, 260, 50);
            ctx.fillStyle = "#fff";
            ctx.font = "16px system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
            ctx.fillText(`Winner: ${state.winner}`, 24, 44);
        }
    }

    function handlePointer(e) {
        if (state.menuActive) return;
        const mx = e.offsetX;
        const my = e.offsetY;
        const x = Math.floor((mx - layout.offsetX) / layout.cell);
        const y = Math.floor((my - layout.offsetY) / layout.cell);
        if (!onBoard(x, y)) return;
        state.cursor = { x, y };
        clickCell(x, y);
        render();
        maybeRunAI();
        updateHud();
    }

    function handleKey(e) {
        const key = e.key.toLowerCase();
        if (rulesOverlay.classList.contains("show")) {
            if (key === "h" || key === "escape" || key === "enter" || key === " ") toggleRules(false);
            return;
        }
        if (state.menuActive) {
            if (key === "1") { selectedMode = "1p"; applyModeUI(); }
            else if (key === "2") { selectedMode = "2p"; applyModeUI(); }
            else if (key === "arrowup" || key === "w") { cycleDiff(-1); }
            else if (key === "arrowdown" || key === "s") { cycleDiff(1); }
            else if (key === "enter" || key === " ") { startSelected(); }
            return;
        }
        if (key === "arrowup") moveCursor(0, -1);
        else if (key === "arrowdown") moveCursor(0, 1);
        else if (key === "arrowleft") moveCursor(-1, 0);
        else if (key === "arrowright") moveCursor(1, 0);
        else if (key === "enter" || key === " ") {
            clickCell(state.cursor.x, state.cursor.y);
            maybeRunAI();
        } else if (key === "escape") {
            state.selected = null; state.legal = []; state.message = "";
        } else if (key === "u") { undo(); }
        else if (key === "r") { resetBoard(); }
        else if (key === "h") { toggleRules(); }
        else if (key === "v") { state.aiEnabled = !state.aiEnabled; state.message = state.aiEnabled ? "AI enabled" : "AI disabled"; }
        render(); updateHud();
    }

    function clickCell(x, y) {
        const piece = state.board[y][x];
        if (state.selected) {
            const isLegal = state.legal.some(m => m.x === x && m.y === y);
            if (isLegal) {
                makeMove(state.selected.x, state.selected.y, x, y);
                state.selected = null;
                state.legal = [];
                return;
            }
        }
        if (piece && piece.color === state.turn) {
            state.selected = { x, y };
            state.legal = genMovesFor(x, y, state.board);
            state.cursor = { x, y };
            state.message = "";
        } else {
            state.selected = null;
            state.legal = [];
        }
        updateHud();
    }

    function onBoard(x, y) { return x >= 0 && x < COLS && y >= 0 && y < ROWS; }

    function genMovesFor(x, y, board) {
        const piece = board[y][x];
        if (!piece) return [];
        const moves = [];
        const forward = piece.color === LIGHT ? -1 : 1;
        const push = (nx, ny) => { if (onBoard(nx, ny)) moves.push({ x: nx, y: ny }); };

        switch (piece.type) {
            case "P": {
                const ny = y + forward;
                if (onBoard(x, ny) && !board[ny][x]) push(x, ny);
                for (const dx of [-1, 1]) {
                    const nx = x + dx;
                    const cy = y + forward;
                    if (onBoard(nx, cy) && board[cy][nx] && board[cy][nx].color !== piece.color) push(nx, cy);
                }
                break;
            }
            case "N": {
                const steps = [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]];
                for (const [dx, dy] of steps) {
                    const nx = x + dx, ny = y + dy;
                    if (!onBoard(nx, ny)) continue;
                    if (!board[ny][nx] || board[ny][nx].color !== piece.color) push(nx, ny);
                }
                break;
            }
            case "B": slideDirs([[1,1],[1,-1],[-1,1],[-1,-1]], x, y, board, piece.color, moves); break;
            case "R": slideDirs([[1,0],[-1,0],[0,1],[0,-1]], x, y, board, piece.color, moves); break;
            case "Q": slideDirs([[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], x, y, board, piece.color, moves); break;
            case "K": {
                const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
                for (const [dx, dy] of dirs) {
                    const nx = x + dx, ny = y + dy;
                    if (!onBoard(nx, ny)) continue;
                    if (!board[ny][nx] || board[ny][nx].color !== piece.color) push(nx, ny);
                }
                break;
            }
        }
        return moves;
    }

    function slideDirs(dirs, x, y, board, color, out) {
        for (const [dx, dy] of dirs) {
            let nx = x + dx, ny = y + dy;
            while (onBoard(nx, ny)) {
                if (!board[ny][nx]) {
                    out.push({ x: nx, y: ny });
                } else {
                    if (board[ny][nx].color !== color) out.push({ x: nx, y: ny });
                    break;
                }
                nx += dx; ny += dy;
            }
        }
    }

    function makeMove(fx, fy, tx, ty) {
        const piece = state.board[fy][fx];
        const target = state.board[ty][tx];
        const move = { from: { x: fx, y: fy }, to: { x: tx, y: ty }, piece: { ...piece }, captured: target ? { ...target } : null };

        // move piece
        state.board[fy][fx] = null;
        state.board[ty][tx] = piece;

        // promotion
        if (piece.type === "P" && ((piece.color === LIGHT && ty === 0) || (piece.color === DARK && ty === ROWS - 1))) {
            piece.type = "Q";
            move.promoted = true;
        }

        // capture tracking
        if (target) state.captures[piece.color] += PIECE_VALUES[target.type] || 1;

        state.moveHistory.push(move);
        state.lastMove = move;

        // win if king captured
        if (target && target.type === "K") {
            state.gameOver = true;
            state.winner = piece.color === LIGHT ? "White" : "Black";
            state.message = "King captured";
            return;
        }

        state.turn = state.turn === LIGHT ? DARK : LIGHT;
        state.message = "";
        updateHud();
    }

    function undo() {
        const mv = state.moveHistory.pop();
        if (!mv) return;
        state.board[mv.from.y][mv.from.x] = { ...mv.piece };
        state.board[mv.to.y][mv.to.x] = mv.captured ? { ...mv.captured } : null;
        if (mv.promoted) state.board[mv.from.y][mv.from.x].type = "P";
        if (mv.captured) state.captures[mv.piece.color] -= PIECE_VALUES[mv.captured.type] || 1;
        state.turn = mv.piece.color;
        state.lastMove = state.moveHistory[state.moveHistory.length - 1] || null;
        state.gameOver = false;
        state.winner = null;
        updateHud();
    }

    function moveCursor(dx, dy) {
        if (state.menuActive) return;
        state.cursor.x = Math.max(0, Math.min(COLS - 1, state.cursor.x + dx));
        state.cursor.y = Math.max(0, Math.min(ROWS - 1, state.cursor.y + dy));
        state.message = "";
        render();
        updateHud();
    }

    function listMovesForColor(color) {
        const moves = [];
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                const pc = state.board[y][x];
                if (!pc || pc.color !== color) continue;
                const legal = genMovesFor(x, y, state.board);
                for (const m of legal) moves.push({ from: { x, y }, to: m, piece: pc });
            }
        }
        return moves;
    }

    function aiChooseMove() {
        const moves = listMovesForColor(state.aiColor);
        if (!moves.length) return null;
        if (state.aiLevel === "easy") {
            return moves[Math.floor(Math.random() * moves.length)];
        }

        // Medium/Hard scoring
        let bestScore = -Infinity;
        const scored = [];
        for (const mv of moves) {
            const target = state.board[mv.to.y][mv.to.x];
            const cap = target ? (PIECE_VALUES[target.type] || 1) : 0;
            let score = cap + Math.random() * 0.05;
            if (state.aiLevel === "hard") {
                // Prefer safer captures: subtract value of moving piece if moving into capture square (very shallow)
                score += cap * 2 - (PIECE_VALUES[mv.piece.type] || 1) * 0.5;
            }
            bestScore = Math.max(bestScore, score);
            scored.push({ mv, score });
        }
        const bestMoves = scored.filter(s => s.score >= bestScore - 0.001).map(s => s.mv);
        return bestMoves[Math.floor(Math.random() * bestMoves.length)];
    }

    function maybeRunAI() {
        if (!state.aiEnabled) return;
        if (state.menuActive) return;
        if (state.gameOver) return;
        if (state.turn !== state.aiColor) return;
        if (state.thinking) return;
        state.thinking = true;
        setTimeout(() => {
            const mv = aiChooseMove();
            if (mv) {
                makeMove(mv.from.x, mv.from.y, mv.to.x, mv.to.y);
            }
            state.thinking = false;
            render();
            updateHud();
            maybeRunAI();
        }, 140);
    }

    function start1P() {
        state.aiEnabled = true;
        state.aiColor = DARK;
        state.menuActive = false;
        setBoardInput(true);
        startOverlay.style.display = "none";
        resetBoard();
        applyDifficultyUI();
        render();
        updateHud();
        maybeRunAI();
    }

    function start2P() {
        state.aiEnabled = false;
        state.menuActive = false;
        setBoardInput(true);
        startOverlay.style.display = "none";
        resetBoard();
        applyDifficultyUI();
        render();
        updateHud();
    }

    function startSelected() {
        state.aiLevel = selectedDiff;
        if (selectedMode === "1p") start1P(); else start2P();
    }

    function setDifficulty(level) {
        state.aiLevel = level;
        selectedDiff = level;
        applyDifficultyUI();
        updateHud();
    }

    function applyModeUI() {
        [btn1p, btn2p].forEach(b => b.classList.remove("active"));
        if (selectedMode === "1p") btn1p.classList.add("active"); else btn2p.classList.add("active");
    }

    function applyDifficultyUI() {
        [btnEasy, btnMed, btnHard].forEach(b => b.classList.remove("active"));
        if (state.aiLevel === "easy") btnEasy.classList.add("active");
        else if (state.aiLevel === "hard") btnHard.classList.add("active");
        else btnMed.classList.add("active");
        selectedDiff = state.aiLevel;
    }

    function cycleDiff(delta) {
        const diffs = ["easy", "medium", "hard"];
        const idx = diffs.indexOf(selectedDiff);
        selectedDiff = diffs[(idx + delta + diffs.length) % diffs.length];
        state.aiLevel = selectedDiff;
        applyDifficultyUI();
    }

    function render() {
        drawBoard(boardLayer.getContext("2d"));
        drawPieces(piecesLayer.getContext("2d"));
    }

    // Init
    resetBoard();
    resize();
    applyDifficultyUI();
    applyModeUI();
    setBoardInput(false);
    render();
    updateHud();

    // Input
    uiLayer.addEventListener("mousedown", handlePointer);
    window.addEventListener("keydown", handleKey);
    window.addEventListener("resize", () => { resize(); render(); });
    btn1p.addEventListener("click", () => { selectedMode = "1p"; applyModeUI(); });
    btn2p.addEventListener("click", () => { selectedMode = "2p"; applyModeUI(); });
    btnEasy.addEventListener("click", () => { setDifficulty("easy"); });
    btnMed.addEventListener("click", () => { setDifficulty("medium"); });
    btnHard.addEventListener("click", () => { setDifficulty("hard"); });
    btnStartOverlay.addEventListener("click", startSelected);
    btnRules.addEventListener("click", () => toggleRules(true));
    closeRules.addEventListener("click", () => toggleRules(false));
    hudBtnStart.addEventListener("click", showStartOverlay);
    hudBtnReset.addEventListener("click", () => { resetBoard(); render(); updateHud(); });
    hudBtnUndo.addEventListener("click", () => { undo(); render(); updateHud(); });
    hudBtnHistory.addEventListener("click", () => toggleHistory());
    btnHistoryClose.addEventListener("click", () => toggleHistory(false));

    // Gamepad support (matches Go)
    let prevButtons = [];
    let lastPadMove = -1e9; // allow immediate first move
    const padRepeatMs = 170;
    const PAD_DEADZONE = 0.2;
    let gpDebug = false;
    const debugEl = document.createElement("div");
    debugEl.style.position = "fixed";
    debugEl.style.left = "8px";
    debugEl.style.bottom = "8px";
    debugEl.style.zIndex = "9999";
    debugEl.style.fontSize = "12px";
    debugEl.style.color = "#9cf";
    debugEl.style.fontFamily = "monospace";
    debugEl.style.pointerEvents = "none";
    debugEl.style.background = "rgba(0,0,0,0.35)";
    debugEl.style.padding = "4px 6px";
    debugEl.style.borderRadius = "4px";
    debugEl.style.display = "none";
    debugEl.style.whiteSpace = "pre";
    document.body.appendChild(debugEl);

    function decodeHatAxis9(v) {
        // Some browsers expose D-pad on axis 9 with stepped values
        if (v === undefined || v === null) return { x: 0, y: 0 };
        if (v < -0.9) return { x: 0, y: -1 };      // up
        if (v < -0.7) return { x: 1, y: -1 };       // up-right
        if (v < -0.45) return { x: -1, y: 0 };      // left
        if (v < -0.2) return { x: -1, y: 1 };       // down-left
        if (v < 0.2) return { x: 0, y: 1 };         // down
        if (v < 0.45) return { x: 1, y: 1 };        // down-right
        if (v < 0.7) return { x: 1, y: 0 };         // right
        if (v < 0.9) return { x: 1, y: -1 };        // up-right (repeat bucket)
        return { x: 0, y: -1 };                     // up
    }

    function pollGamepad() {
        const pads = navigator.getGamepads ? navigator.getGamepads() : [];
        const pad = pads && pads[0];
        if (pad) {
            const now = performance.now();
            const axes = pad.axes || [];
            const buttons = pad.buttons || [];
            const ax0 = axes[0] ?? 0, ax1 = axes[1] ?? 0, ax6 = axes[6] ?? 0, ax7 = axes[7] ?? 0, ax9 = axes[9];
            const hat9 = decodeHatAxis9(ax9);
            const dxAxis = Math.abs(ax0) > PAD_DEADZONE ? Math.sign(ax0) : 0;
            const dyAxis = Math.abs(ax1) > PAD_DEADZONE ? Math.sign(ax1) : 0;
            const hatX = Math.abs(ax6) > PAD_DEADZONE ? Math.sign(ax6) : 0; // some pads expose D-pad on axes[6]/[7]
            const hatY = Math.abs(ax7) > PAD_DEADZONE ? Math.sign(ax7) : 0;
            const dpadX = (buttons[15]?.pressed ? 1 : 0) - (buttons[14]?.pressed ? 1 : 0);
            const dpadY = (buttons[13]?.pressed ? 1 : 0) - (buttons[12]?.pressed ? 1 : 0);
            const moveX = dpadX || hatX || hat9.x || dxAxis;
            const moveY = dpadY || hatY || hat9.y || dyAxis;

            if (gpDebug) {
                debugEl.textContent = `h:${moveX} v:${moveY} ax0:${ax0.toFixed(2)} ax1:${ax1.toFixed(2)} ax6:${ax6.toFixed(2)} ax7:${ax7.toFixed(2)} ax9:${ax9 !== undefined ? ax9.toFixed(2) : "--"} btn14:${buttons[14]?.pressed ? 1 : 0} btn15:${buttons[15]?.pressed ? 1 : 0}`;
            }

            const edge = idx => buttons[idx]?.pressed && !prevButtons[idx];

            if (rulesOverlay.classList.contains("show")) {
                if (edge(0) || edge(1) || edge(3) || edge(9)) toggleRules(false);
                prevButtons = buttons.map(b => b?.pressed);
                return requestAnimationFrame(pollGamepad);
            }

            if (state.menuActive) {
                if ((moveX || moveY) && now - lastPadMove > padRepeatMs) {
                    if (moveX) { selectedMode = selectedMode === "1p" ? "2p" : "1p"; applyModeUI(); }
                    if (moveY) { cycleDiff(moveY > 0 ? 1 : -1); }
                    lastPadMove = now;
                }
                if (edge(14) || edge(15)) { selectedMode = selectedMode === "1p" ? "2p" : "1p"; applyModeUI(); }
                if (edge(12)) { cycleDiff(-1); }
                if (edge(13)) { cycleDiff(1); }
                if (edge(0) || edge(9)) startSelected();
            } else {
                if ((moveX || moveY) && now - lastPadMove > padRepeatMs) {
                    moveCursor(moveX, moveY);
                    lastPadMove = now;
                }
                if (edge(0)) { clickCell(state.cursor.x, state.cursor.y); render(); maybeRunAI(); }
                if (edge(1)) { state.selected = null; state.legal = []; state.message = ""; render(); updateHud(); }
                if (edge(3)) { toggleRules(); render(); }
                if (edge(4)) { undo(); render(); updateHud(); }
                if (edge(2)) { resetBoard(); render(); updateHud(); }
                if (edge(8)) { gpDebug = !gpDebug; debugEl.style.display = gpDebug ? "block" : "none"; }
            }


            prevButtons = buttons.map(b => b?.pressed);
        }
        requestAnimationFrame(pollGamepad);
    }
    requestAnimationFrame(pollGamepad);

    // Keyboard fallback to toggle debug overlay if controller button mapping differs
    window.addEventListener("keydown", ev => {
        if (ev.key.toLowerCase() === "g") { gpDebug = !gpDebug; debugEl.style.display = gpDebug ? "block" : "none"; }
    });

})();
</script>
</body>
</html>
