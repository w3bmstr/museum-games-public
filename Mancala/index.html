<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Mancala</title>
	<style>
		:root {
			--bg: #0c0f16;
			--panel: #141a26;
			--accent: #c4a04a;
			--accent-2: #5aa9e6;
			--pit: #1c2334;
			--pit-2: #111827;
			--text: #f5f7fb;
			--muted: #9aa7bd;
		}
		* { box-sizing: border-box; }
		body {
			margin: 0;
			background: radial-gradient(circle at 20% 20%, #121828, #0c0f16 40%);
			font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
			color: var(--text);
			display: flex;
			align-items: center;
			justify-content: center;
			min-height: 100vh;
			height: 100vh;
			padding: 0;
			overflow: hidden;
		}
		#app {
			width: 100%;
			height: 100vh;
			max-width: 1400px;
			background: var(--panel);
			border: 1px solid rgba(255,255,255,0.06);
			border-radius: 16px;
			overflow: hidden;
			box-shadow: 0 20px 60px rgba(0,0,0,0.35);
			display: flex;
			flex-direction: column;
		}
		header {
			padding: 18px 22px 12px;
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			background: linear-gradient(90deg, rgba(196,160,74,0.15), transparent);
			border-bottom: 1px solid rgba(255,255,255,0.06);
		}
		header h1 { margin: 0; font-size: 20px; letter-spacing: 0.4px; }
		header .subtitle { margin: 0; color: var(--muted); font-size: 13px; }
		main {
			display: grid;
			grid-template-columns: minmax(0,1fr) 320px;
			gap: 0;
			flex: 1;
			min-height: 0;
			overflow: hidden;
		}
		#board-wrapper {
			padding: 18px;
			background: #0d121d;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			min-height: 0;
			overflow: hidden;
		}
		canvas {
			display: block;
			margin: auto;
			background: #0e1523;
			border-radius: 12px;
			box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06), 0 14px 30px rgba(0,0,0,0.35);
			width: 100%;
			height: auto;
			max-height: 100%;
			max-width: 100%;
		}
		#ui-panel {
			padding: 18px 18px 24px;
			border-left: 1px solid rgba(255,255,255,0.06);
			background: rgba(10,14,24,0.78);
			height: 100%;
			overflow-y: auto;
			min-height: 0;
		}
		.section { margin-bottom: 16px; padding: 12px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06); border-radius: 10px; }
		.section h3 { margin: 0 0 8px; font-size: 14px; letter-spacing: 0.6px; color: var(--muted); text-transform: uppercase; }
		.row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
		.pill { padding: 8px 12px; border-radius: 999px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); font-size: 13px; }
		button { border: none; border-radius: 8px; padding: 10px 12px; font-size: 14px; cursor: pointer; background: var(--accent); color: #0c0f16; transition: transform 0.1s ease, box-shadow 0.2s ease; }
		button.secondary { background: rgba(255,255,255,0.12); color: var(--text); }
		button:disabled { opacity: 0.5; cursor: not-allowed; }
		button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 10px 22px rgba(0,0,0,0.25); }
		.status { padding: 10px 12px; border-radius: 10px; background: rgba(90,169,230,0.1); border: 1px solid rgba(90,169,230,0.2); font-size: 14px; }
		.move-line { display: flex; gap: 8px; padding: 4px 6px; border-radius: 6px; }
		.move-line:nth-child(odd) { background: rgba(255,255,255,0.06); }
		.overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(8,10,16,0.82); backdrop-filter: blur(4px); z-index: 20; }
		.dialog { background: #0f1623; border: 1px solid rgba(255,255,255,0.08); padding: 20px; border-radius: 12px; width: min(520px, 92%); box-shadow: 0 16px 50px rgba(0,0,0,0.35); }
		.dialog h2 { margin: 0 0 8px; }
		.dialog p { margin: 4px 0; color: var(--muted); line-height: 1.6; font-size: 14px; }
		.options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 12px 0; }
		.option-active { outline: 2px solid var(--accent-2); outline-offset: 1px; }
		select { width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.06); color: var(--text); }
		label { font-size: 13px; color: var(--muted); display: block; margin-top: 6px; }
		@media (max-width: 980px) { main { grid-template-columns: 1fr; } #ui-panel { border-left: none; border-top: 1px solid rgba(255,255,255,0.06); } }
		@media (max-width: 640px) { #board-wrapper { padding: 10px; } header { flex-direction: column; align-items: flex-start; } body { padding: 0; } }
	</style>
</head>
<body>
	<div id="app">
		<header>
			<div>
				<h1>Mancala</h1>
				<p class="subtitle">Sow stones, capture, and race to the big pits</p>
			</div>
			<div class="row">
				<button class="secondary" id="open-start">Start</button>
				<button class="secondary" onclick="showRules()">Rules</button>
				<button class="secondary" onclick="restartGame()">Restart</button>
			</div>
		</header>
		<main>
			<div id="board-wrapper">
				<canvas id="board" width="900" height="340"></canvas>
			</div>
			<div id="ui-panel">
				<div class="section">
					<h3>Turn</h3>
					<div id="turn" class="pill">Player A to move</div>
				</div>
				<div class="section">
					<h3>Mode</h3>
					<div class="row" style="gap:12px;">
						<button id="mode-human" class="secondary" onclick="setMode('human')">2 Players</button>
						<button id="mode-ai" onclick="setMode('ai')">Vs AI</button>
					</div>
					<label for="difficulty">AI Difficulty</label>
					<select id="difficulty" onchange="changeDifficulty(event)">
						<option value="easy">Easy</option>
						<option value="medium" selected>Medium</option>
						<option value="hard">Hard</option>
					</select>
				</div>
				<div class="section">
					<h3>Actions</h3>
					<div class="row" style="gap:8px;">
						<button onclick="undoMove()" class="secondary">Undo</button>
						<button onclick="restartGame()" class="secondary">Restart</button>
						<button onclick="showHistoryOverlay()" class="secondary">History</button>
					</div>
				</div>
				<div class="section">
					<h3>Status</h3>
					<div id="status" class="status">Ready</div>
				</div>
			</div>
		</main>
	</div>

	<div id="start-overlay" class="overlay">
		<div class="dialog">
			<h2>Start Game</h2>
			<p>Choose how to play, set difficulty, then start.</p>
			<div class="options">
				<button id="start-human" onclick="selectStartMode('human')">2 Players</button>
				<button id="start-ai" onclick="selectStartMode('ai')">Player vs AI</button>
			</div>
			<label for="start-difficulty">AI Difficulty</label>
			<select id="start-difficulty">
				<option value="easy">Easy</option>
				<option value="medium" selected>Medium</option>
				<option value="hard">Hard</option>
			</select>
			<div class="row" style="margin-top:12px; justify-content:flex-end;">
				<button id="btn-start-game" style="min-width:140px;">Start Game</button>
			</div>
		</div>
	</div>

	<div id="rules-overlay" class="overlay" style="display:none;">
		<div class="dialog">
			<h2>Rules: Mancala (Kalah)</h2>
			<p><strong>Board:</strong> 2 rows of 6 pits plus a store (Mancala) at each end.</p>
			<p><strong>Setup:</strong> 4 stones in each small pit.</p>
			<p><strong>Play:</strong> On your turn, pick a pit on your side, sow stones counterclockwise. Skip the opponent's store. If your last stone lands in your store, you move again.</p>
			<p><strong>Capture:</strong> If your last stone lands in an empty pit on your side, capture that stone and the stones in the opposite pit and place them in your store.</p>
			<p><strong>End:</strong> When one side is empty, the other side's stones move to its store. High score wins.</p>
			<div class="row" style="justify-content:flex-end; margin-top:10px;">
				<button class="secondary" onclick="hideRules()">Close</button>
			</div>
		</div>
	</div>

	<div id="history-overlay" class="overlay" style="display:none;">
		<div class="dialog">
			<h2>Move History</h2>
			<div id="history-list" style="max-height:320px; overflow-y:auto; margin:10px 0;"></div>
			<div class="row" style="justify-content:flex-end;">
				<button class="secondary" onclick="hideHistoryOverlay()">Close</button>
			</div>
		</div>
	</div>

	<script>
		const canvas = document.getElementById('board');
		const ctx = canvas.getContext('2d');

		const PITS_PER_SIDE = 6;
		const START_STONES = 4;
		const PLAYER_A = 0; // bottom / right store index 6
		const PLAYER_B = 1; // top / left store index 13

		const state = {
			pits: Array(14).fill(START_STONES),
			turn: PLAYER_A,
			log: [],
			stack: [],
			mode: 'human',
			aiLevel: 'medium',
			aiColor: PLAYER_B,
			gameOver: false,
			message: 'Ready'
		};

		// store indices
		const STORE_A = 6;
		const STORE_B = 13;

		function resetBoard() {
			state.pits = Array(14).fill(START_STONES);
			state.pits[STORE_A] = 0;
			state.pits[STORE_B] = 0;
			state.turn = PLAYER_A;
			state.log = [];
			state.stack = [];
			state.gameOver = false;
			state.message = 'Ready';
			updateUI();
			draw();
			maybeAIMove();
		}

		function setMode(mode) {
			state.mode = mode;
			state.aiColor = PLAYER_B;
			document.getElementById('mode-human').classList.toggle('secondary', mode === 'ai');
			document.getElementById('mode-ai').classList.toggle('secondary', mode === 'human');
			updateStatus(mode === 'ai' ? 'Player vs AI' : 'Two player mode');
			maybeAIMove();
		}

		function updateStatus(text) {
			document.getElementById('status').textContent = text;
		}

		function updateTurnText() {
			const turnEl = document.getElementById('turn');
			const name = state.turn === PLAYER_A ? 'Player A' : 'Player B';
			turnEl.textContent = `${name} to move`;
		}

		function changeDifficulty(e) {
			state.aiLevel = e.target.value;
			updateStatus('AI set to ' + state.aiLevel);
			maybeAIMove();
		}

		function rulesSideIndices(player) {
			return player === PLAYER_A ? { pits: [0,1,2,3,4,5], store: STORE_A } : { pits: [7,8,9,10,11,12], store: STORE_B };
		}

		function isOwnPit(idx, player) {
			const { pits } = rulesSideIndices(player);
			return pits.includes(idx);
		}

		function oppositePit(idx) {
			if (idx === STORE_A || idx === STORE_B) return -1;
			return 12 - idx;
		}

		function legalMoves(player) {
			const { pits } = rulesSideIndices(player);
			return pits.filter(i => state.pits[i] > 0);
		}

		function isGameOver() {
			const aEmpty = legalMoves(PLAYER_A).length === 0;
			const bEmpty = legalMoves(PLAYER_B).length === 0;
			return aEmpty || bEmpty;
		}

		function finalizeGameIfNeeded() {
			if (!isGameOver()) return false;
			const { pits: aPits } = rulesSideIndices(PLAYER_A);
			const { pits: bPits } = rulesSideIndices(PLAYER_B);
			let aRem = 0, bRem = 0;
			aPits.forEach(i => { aRem += state.pits[i]; state.pits[i] = 0; });
			bPits.forEach(i => { bRem += state.pits[i]; state.pits[i] = 0; });
			state.pits[STORE_A] += aRem;
			state.pits[STORE_B] += bRem;
			state.gameOver = true;
			const aScore = state.pits[STORE_A];
			const bScore = state.pits[STORE_B];
			if (aScore > bScore) state.message = 'Player A wins';
			else if (bScore > aScore) state.message = 'Player B wins';
			else state.message = 'Draw';
			updateUI();
			draw();
			return true;
		}

		function move(player, pitIdx, record = true) {
			if (state.gameOver) return false;
			if (!isOwnPit(pitIdx, player)) return false;
			const stones = state.pits[pitIdx];
			if (stones === 0) return false;

			if (record) {
				state.stack.push({
					pits: [...state.pits],
					turn: state.turn,
					logLen: state.log.length,
					message: state.message,
					gameOver: state.gameOver
				});
			}

			state.pits[pitIdx] = 0;
			let idx = pitIdx;
			let remaining = stones;
			while (remaining > 0) {
				idx = (idx + 1) % 14;
				if (player === PLAYER_A && idx === STORE_B) continue;
				if (player === PLAYER_B && idx === STORE_A) continue;
				state.pits[idx] += 1;
				remaining--;
			}

			const landedInStore = (player === PLAYER_A && idx === STORE_A) || (player === PLAYER_B && idx === STORE_B);
			const landedOwnEmpty = isOwnPit(idx, player) && state.pits[idx] === 1;
			if (!landedInStore && landedOwnEmpty) {
				const opp = oppositePit(idx);
				if (opp >= 0 && state.pits[opp] > 0) {
					const captured = state.pits[opp];
					state.pits[opp] = 0;
					state.pits[idx] = 0;
					const store = player === PLAYER_A ? STORE_A : STORE_B;
					state.pits[store] += captured + 1;
				}
			}

			state.log.push(formatMove(player, pitIdx, landedInStore));

			if (!landedInStore) {
				state.turn = player === PLAYER_A ? PLAYER_B : PLAYER_A;
			}

			finalizeGameIfNeeded();
			updateUI();
			draw();
			maybeAIMove();
			return true;
		}

		function formatMove(player, pitIdx, extra) {
			const sideLabel = player === PLAYER_A ? 'A' : 'B';
			const pos = player === PLAYER_A ? pitIdx + 1 : (12 - pitIdx) + 1;
			return `${sideLabel}${pos}${extra ? '*' : ''}`;
		}

		function undoMove() {
			const prev = state.stack.pop();
			if (!prev) return;
			state.pits = [...prev.pits];
			state.turn = prev.turn;
			state.log = state.log.slice(0, prev.logLen);
			state.message = prev.message;
			state.gameOver = prev.gameOver;
			updateUI();
			draw();
		}

		function updateUI() {
			updateTurnText();
			const aScore = state.pits[STORE_A];
			const bScore = state.pits[STORE_B];
			const status = state.gameOver ? state.message : state.message;
			document.getElementById('status').textContent = `${status} | A: ${aScore}  B: ${bScore}`;
		}

		function showRules() { document.getElementById('rules-overlay').style.display = 'flex'; }
		function hideRules() { document.getElementById('rules-overlay').style.display = 'none'; }
		function showHistoryOverlay() {
			const list = document.getElementById('history-list');
			list.innerHTML = '';
			state.log.forEach((text, idx) => {
				const div = document.createElement('div');
				div.className = 'move-line';
				div.textContent = `${idx + 1}. ${text}`;
				list.appendChild(div);
			});
			document.getElementById('history-overlay').style.display = 'flex';
		}
		function hideHistoryOverlay() { document.getElementById('history-overlay').style.display = 'none'; }

		// Start overlay handling
		let startSelectedMode = 'ai';
		function updateStartModeButtons() {
			document.getElementById('start-human').classList.toggle('option-active', startSelectedMode === 'human');
			document.getElementById('start-ai').classList.toggle('option-active', startSelectedMode === 'ai');
		}
		function selectStartMode(mode) { startSelectedMode = mode; updateStartModeButtons(); }
		function startGame(mode) {
			const chosen = mode || startSelectedMode;
			state.aiLevel = document.getElementById('start-difficulty').value;
			document.getElementById('difficulty').value = state.aiLevel;
			setMode(chosen);
			resetBoard();
			document.getElementById('start-overlay').style.display = 'none';
		}
		function openStartOverlay() {
			document.getElementById('start-overlay').style.display = 'flex';
		}

		document.getElementById('open-start').addEventListener('click', openStartOverlay);
		document.getElementById('btn-start-game').addEventListener('click', () => startGame());
		updateStartModeButtons();

		// Drawing
		function draw() {
			const w = canvas.width;
			const h = canvas.height;
			ctx.clearRect(0, 0, w, h);
			ctx.fillStyle = '#0e1523';
			ctx.fillRect(0, 0, w, h);

			const pad = 24;
			const pitW = (w - pad * 2 - 140) / 6;
			const pitH = (h - pad * 2 - 20) / 2;
			const storeW = 120;

			ctx.lineWidth = 2;
			ctx.strokeStyle = 'rgba(255,255,255,0.08)';

			// Draw stores
			drawPit(pad, pad, storeW, pitH * 2 + 20, STORE_B, true);
			drawPit(w - pad - storeW, pad, storeW, pitH * 2 + 20, STORE_A, true);

			// Top row (Player B pits 12..7)
			for (let i = 0; i < 6; i++) {
				const pitIdx = 12 - i;
				const x = pad + storeW + i * pitW;
				const y = pad;
				drawPit(x, y, pitW, pitH, pitIdx, false);
			}

			// Bottom row (Player A pits 0..5)
			for (let i = 0; i < 6; i++) {
				const pitIdx = i;
				const x = pad + storeW + i * pitW;
				const y = pad + pitH + 20;
				drawPit(x, y, pitW, pitH, pitIdx, false);
			}
		}

		function drawPit(x, y, w, h, idx, isStore) {
			ctx.fillStyle = isStore ? '#111827' : '#1a2234';
			ctx.strokeStyle = 'rgba(255,255,255,0.08)';
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.roundRect(x, y, w, h, 10);
			ctx.fill();
			ctx.stroke();

			const stones = state.pits[idx];
			ctx.fillStyle = '#e6e2d3';
			ctx.font = '18px "Segoe UI", sans-serif';
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';
			ctx.fillText(stones, x + w / 2, y + h / 2);

			ctx.fillStyle = '#9aa7bd';
			const label = pitLabel(idx);
			ctx.font = '12px "Segoe UI", sans-serif';
			ctx.fillText(label, x + w / 2, y + h - 14);

			// Highlight current player's pits
			if (!isStore && isOwnPit(idx, state.turn)) {
				ctx.strokeStyle = 'rgba(90,169,230,0.65)';
				ctx.lineWidth = 2;
				ctx.strokeRect(x + 2, y + 2, w - 4, h - 4);
			}
		}

		function pitLabel(idx) {
			if (idx === STORE_A) return 'Store A';
			if (idx === STORE_B) return 'Store B';
			if (idx < 6) return 'A' + (idx + 1);
			return 'B' + (12 - idx + 1);
		}

		canvas.addEventListener('click', evt => {
			if (state.gameOver) return;
			if (state.mode === 'ai' && state.turn === state.aiColor) return;
			const rect = canvas.getBoundingClientRect();
			const mx = (evt.clientX - rect.left) * (canvas.width / rect.width);
			const my = (evt.clientY - rect.top) * (canvas.height / rect.height);
			const pitIdx = hitTestPit(mx, my);
			if (pitIdx === null) return;
			if (!isOwnPit(pitIdx, state.turn)) return;
			move(state.turn, pitIdx);
		});

		function hitTestPit(mx, my) {
			const w = canvas.width;
			const h = canvas.height;
			const pad = 24;
			const pitW = (w - pad * 2 - 140) / 6;
			const pitH = (h - pad * 2 - 20) / 2;
			const storeW = 120;

			// stores
			if (pointInRect(mx, my, pad, pad, storeW, pitH * 2 + 20)) return STORE_B;
			if (pointInRect(mx, my, w - pad - storeW, pad, storeW, pitH * 2 + 20)) return STORE_A;

			// top row (Player B pits)
			for (let i = 0; i < 6; i++) {
				const x = pad + storeW + i * pitW;
				const y = pad;
				if (pointInRect(mx, my, x, y, pitW, pitH)) return 12 - i;
			}
			// bottom row (Player A pits)
			for (let i = 0; i < 6; i++) {
				const x = pad + storeW + i * pitW;
				const y = pad + pitH + 20;
				if (pointInRect(mx, my, x, y, pitW, pitH)) return i;
			}
			return null;
		}

		function pointInRect(px, py, x, y, w, h) {
			return px >= x && px <= x + w && py >= y && py <= y + h;
		}

		function maybeAIMove() {
			if (state.mode !== 'ai') return;
			if (state.gameOver) return;
			if (state.turn !== state.aiColor) return;
			setTimeout(() => {
				const mv = chooseAIMove(state.aiColor, state.aiLevel);
				if (mv !== null) move(state.aiColor, mv, true);
			}, 200);
		}

		function chooseAIMove(player, level) {
			const moves = legalMoves(player);
			if (!moves.length) return null;
			if (level === 'easy') return moves[Math.floor(Math.random() * moves.length)];
			let best = -Infinity;
			const scored = [];
			for (const m of moves) {
				const score = simulateMoveScore(player, m, level === 'hard');
				best = Math.max(best, score);
				scored.push({ m, score });
			}
			const bestMoves = scored.filter(s => s.score >= best - 1e-6).map(s => s.m);
			return bestMoves[Math.floor(Math.random() * bestMoves.length)];
		}

		function simulateMoveScore(player, pitIdx, deeper) {
			const snapshot = [...state.pits];
			let turn = player;
			const result = simulateSow(snapshot, turn, pitIdx);
			let score = snapshot[turn === PLAYER_A ? STORE_A : STORE_B] - snapshot[turn === PLAYER_A ? STORE_B : STORE_A];
			if (result.extraTurn && deeper) {
				const nextMoves = (turn === PLAYER_A ? [0,1,2,3,4,5] : [7,8,9,10,11,12]).filter(i => snapshot[i] > 0);
				if (nextMoves.length) {
					const extraScores = nextMoves.map(m => simulateMoveScore(turn, m, false));
					score += Math.max(...extraScores) * 0.5;
				}
			}
			return score;
		}

		function simulateSow(pits, player, pitIdx) {
			let stones = pits[pitIdx];
			pits[pitIdx] = 0;
			let idx = pitIdx;
			while (stones > 0) {
				idx = (idx + 1) % 14;
				if (player === PLAYER_A && idx === STORE_B) continue;
				if (player === PLAYER_B && idx === STORE_A) continue;
				pits[idx] += 1;
				stones--;
			}
			const landedInStore = (player === PLAYER_A && idx === STORE_A) || (player === PLAYER_B && idx === STORE_B);
			const landedOwnEmpty = isOwnPit(idx, player) && pits[idx] === 1;
			if (!landedInStore && landedOwnEmpty) {
				const opp = oppositePit(idx);
				if (opp >= 0 && pits[opp] > 0) {
					const captured = pits[opp];
					pits[opp] = 0;
					pits[idx] = 0;
					const store = player === PLAYER_A ? STORE_A : STORE_B;
					pits[store] += captured + 1;
				}
			}
			return { extraTurn: landedInStore };
		}

		function restartGame() { resetBoard(); }

		function changeSize() {
			const rect = document.getElementById('board-wrapper').getBoundingClientRect();
			canvas.width = Math.min(1100, rect.width * devicePixelRatio);
			canvas.height = Math.min(400, rect.height * devicePixelRatio);
			canvas.style.width = rect.width + 'px';
			canvas.style.height = Math.min(400, rect.height) + 'px';
			ctx.setTransform(1,0,0,1,0,0);
			ctx.scale(devicePixelRatio, devicePixelRatio);
			draw();
		}

		window.addEventListener('resize', changeSize);

		// Init
		changeSize();
		resetBoard();
		updateStartModeButtons();
	</script>
</body>
</html>
