<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Petty Chess</title>
	<style>
		html, body { margin:0; padding:0; width:100%; height:100%; background:#0b0d12; color:#e8ebf2; font-family:"Segoe UI", system-ui, sans-serif; overflow:hidden; }
		#game-container { position:relative; width:100vw; height:100vh; overflow:hidden; background: radial-gradient(circle at 20% 20%, rgba(88,198,255,0.08), transparent 45%), radial-gradient(circle at 80% 70%, rgba(255,160,80,0.08), transparent 45%), #0b0d12; }
		canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }
		.layer-board { z-index:0; pointer-events:none; }
		.layer-pieces { z-index:1; pointer-events:none; }
		.layer-ui { z-index:2; }
		#hud { position:absolute; top:10px; left:10px; z-index:5; display:flex; flex-direction:column; gap:8px; }
		.panel { background:rgba(0,0,0,0.58); border:1px solid #1f2430; border-radius:10px; padding:10px 12px; min-width:230px; box-shadow:0 10px 28px rgba(0,0,0,0.35); }
		.panel h4 { margin:0 0 6px 0; font-size:13px; letter-spacing:0.5px; color:#ffc857; }
		.panel p { margin:4px 0; font-size:13px; }
		#controls { display:flex; gap:8px; flex-wrap:wrap; }
		#controls button { padding:8px 10px; border:none; border-radius:8px; background:#252a38; color:#e8e8ec; cursor:pointer; font-size:13px; }
		#controls button.primary { background:linear-gradient(135deg, #58c6ff, #2f81ff); color:#fff; }
		#controls button:disabled { opacity:0.55; cursor:not-allowed; }
		.history-panel { position:relative; max-height:260px; overflow-y:auto; font-family:monospace; font-size:12px; }
		.history-panel .move-line { margin:2px 0; }
		.history-close { position:absolute; top:6px; right:6px; padding:4px 8px; border:none; border-radius:6px; background:#252a38; color:#e8e8ec; cursor:pointer; font-size:11px; }
		#btn-history { display:none; }
		@media (max-width:720px) {
			#hud { position:fixed; top:auto; bottom:0; left:0; right:0; flex-direction:row; gap:6px; padding:6px; background:linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.45) 40%); backdrop-filter:blur(8px); }
			#hud .panel { min-width:0; flex:1; }
			#history { display:none; position:fixed; right:8px; bottom:78px; width:82vw; max-width:380px; max-height:55vh; z-index:12; background:rgba(0,0,0,0.85); border-radius:10px; }
			#history.show { display:block; }
			#btn-history { display:inline-block; }
		}
		#start-overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.72); z-index:10; }
		#start-card { background:#161820; border:1px solid #262c3a; border-radius:12px; padding:18px 22px; color:#f5f5f5; min-width:280px; box-shadow:0 12px 30px rgba(0,0,0,0.35); }
		#start-card h2 { margin:0 0 10px 0; font-size:20px; }
		#start-card p { margin:0 0 12px 0; font-size:14px; color:#cfd3dd; }
		#start-card .btn-row { display:flex; gap:10px; margin-top:10px; }
		#start-card button { flex:1; padding:10px 12px; border:none; border-radius:8px; background:linear-gradient(135deg, #58c6ff, #2f81ff); color:#fff; font-weight:700; cursor:pointer; }
		#start-card button.secondary { background:#3a3f4f; }
		#start-card button.active { outline:2px solid #fff; }
		#rules-overlay { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.7); z-index:11; }
		#rules-overlay.show { display:flex; }
		#rules-card { background:#161820; border:1px solid #262c3a; border-radius:12px; padding:18px 22px; color:#f5f5f5; max-width:760px; width:90%; box-shadow:0 12px 30px rgba(0,0,0,0.35); line-height:1.45; }
		#rules-card h3 { margin:0 0 8px 0; font-size:18px; }
		#rules-card ul { margin:8px 0 0 18px; padding:0; }
		#rules-card li { margin:4px 0; }
		#close-rules { margin-top:12px; padding:8px 12px; border:none; border-radius:8px; background:#3a3f4f; color:#fff; cursor:pointer; }
	</style>
</head>
<body>
<div id="game-container">
	<div id="hud">
		<div class="panel">
			<h4>Status</h4>
			<p id="turn-text">Turn: --</p>
			<p id="ai-text">AI: --</p>
			<p id="msg-text">Ready</p>
			<p id="cap-text">Material W:0 B:0</p>
			<p id="lastmove-text">Last: --</p>
		</div>
		<div id="controls" class="panel">
			<button id="btn-start" class="primary">New Game</button>
			<button id="btn-reset">Reset</button>
			<button id="btn-undo">Undo</button>
			<button id="btn-history">History</button>
			<button id="btn-rules">Rules</button>
		</div>
		<div id="history" class="panel history-panel">
			<h4>Moves</h4>
			<button id="btn-history-close" class="history-close">Close</button>
			<div id="move-list"></div>
		</div>
	</div>

	<div id="start-overlay">
		<div id="start-card">
			<h2>Petty Chess</h2>
			<p>Compact 6x6 chess: quick mates, no castling or en passant; pawns move one, promote to queen.</p>
			<div class="btn-row">
				<button id="btn-1p">1 Player (vs AI)</button>
				<button id="btn-2p" class="secondary">2 Players</button>
			</div>
			<p style="margin-top:12px; margin-bottom:6px;">AI Difficulty</p>
			<div class="btn-row">
				<button id="btn-easy" class="secondary">Easy</button>
				<button id="btn-med" class="active">Medium</button>
				<button id="btn-hard" class="secondary">Hard</button>
			</div>
			<p style="margin-top:12px; margin-bottom:6px;">Start</p>
			<div class="btn-row" style="margin-top:8px;">
				<button id="btn-start-overlay" class="primary">Start Game</button>
			</div>
		</div>
	</div>

	<div id="rules-overlay">
		<div id="rules-card">
			<h3>Rules</h3>
			<ul>
				<li>Board: 6x6. White at bottom, black at top.</li>
				<li>Setup: back rank per side R N B Q K R; full pawn rank in front.</li>
				<li>Moves: standard chess moves, but pawns only single-step forward; no double advance, no en passant, no castling.</li>
				<li>Promotion: any pawn reaching final rank becomes a queen.</li>
				<li>Win: checkmate or capturing the king. Stalemate is a draw.</li>
				<li>Controls: click squares; arrows + Enter/Space; U undo; R reset; H rules.</li>
			</ul>
			<button id="close-rules">Close</button>
		</div>
	</div>
</div>

<script>
(function() {
	const LIGHT = 1;
	const DARK = 2;
	const ROWS = 6;
	const COLS = 6;
	const dpr = window.devicePixelRatio || 1;

	const PIECE_VALUES = { K: 1000, Q: 9, R: 5, B: 3, N: 3, P: 1 };

	const container = document.getElementById("game-container");
	const startOverlay = document.getElementById("start-overlay");
	const btn1p = document.getElementById("btn-1p");
	const btn2p = document.getElementById("btn-2p");
	const btnEasy = document.getElementById("btn-easy");
	const btnMed = document.getElementById("btn-med");
	const btnHard = document.getElementById("btn-hard");
	const btnStartOverlay = document.getElementById("btn-start-overlay");
	const btnRules = document.getElementById("btn-rules");
	const rulesOverlay = document.getElementById("rules-overlay");
	const closeRules = document.getElementById("close-rules");
	const hudBtnStart = document.getElementById("btn-start");
	const hudBtnReset = document.getElementById("btn-reset");
	const hudBtnUndo = document.getElementById("btn-undo");
	const hudBtnHistory = document.getElementById("btn-history");
	const btnHistoryClose = document.getElementById("btn-history-close");
	const historyPanel = document.getElementById("history");
	const turnText = document.getElementById("turn-text");
	const aiText = document.getElementById("ai-text");
	const msgText = document.getElementById("msg-text");
	const capText = document.getElementById("cap-text");
	const lastMoveText = document.getElementById("lastmove-text");
	const moveList = document.getElementById("move-list");

	const boardLayer = document.createElement("canvas");
	const piecesLayer = document.createElement("canvas");
	const uiLayer = document.createElement("canvas");
	boardLayer.className = "layer-board";
	piecesLayer.className = "layer-pieces";
	uiLayer.className = "layer-ui";
	container.appendChild(boardLayer);
	container.appendChild(piecesLayer);
	container.appendChild(uiLayer);

	const layout = { width:0, height:0, cell:0, offsetX:0, offsetY:0 };

	const state = {
		board: createEmpty(),
		turn: LIGHT,
		moveHistory: [],
		lastMove: null,
		material: { [LIGHT]: 0, [DARK]: 0 },
		gameOver: false,
		winner: null,
		draw: false,
		message: "",
		cursor: { x: 2, y: 5 },
		selected: null,
		legal: [],
		aiEnabled: true,
		aiColor: DARK,
		aiLevel: "medium",
		thinking: false,
		menuActive: true
	};

	let selectedMode = "1p";
	let selectedDiff = "medium";

	function createEmpty() { return Array.from({ length: ROWS }, () => Array(COLS).fill(null)); }
	function p(type, color) { return { type, color }; }
	function onBoard(x, y) { return x >= 0 && x < COLS && y >= 0 && y < ROWS; }
	function oppColor(c) { return c === LIGHT ? DARK : LIGHT; }

	function resetBoard() {
		state.board = createEmpty();
		const back = ["R","N","B","Q","K","R"];
		for (let x = 0; x < COLS; x++) {
			state.board[ROWS-1][x] = p(back[x], LIGHT);
			state.board[ROWS-2][x] = p("P", LIGHT);
			state.board[0][x] = p(back[x], DARK);
			state.board[1][x] = p("P", DARK);
		}
		state.turn = LIGHT;
		state.moveHistory = [];
		state.lastMove = null;
		state.material = { [LIGHT]: materialScore(state.board, LIGHT), [DARK]: materialScore(state.board, DARK) };
		state.gameOver = false;
		state.winner = null;
		state.draw = false;
		state.message = "";
		state.selected = null;
		state.legal = [];
		state.cursor = { x: 2, y: 5 };
		updateHud();
	}

	function resize() {
		layout.width = window.innerWidth;
		layout.height = window.innerHeight;
		[boardLayer, piecesLayer, uiLayer].forEach(c => {
			c.width = layout.width * dpr;
			c.height = layout.height * dpr;
			c.style.width = `${layout.width}px`;
			c.style.height = `${layout.height}px`;
			const ctx = c.getContext("2d");
			ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
		});
		const size = Math.min(layout.width, layout.height) * 0.9;
		layout.cell = size / Math.max(COLS, ROWS);
		layout.offsetX = (layout.width - layout.cell * COLS) / 2;
		layout.offsetY = (layout.height - layout.cell * ROWS) / 2;
		render();
	}

	function drawBoard(ctx) {
		ctx.clearRect(0,0,layout.width, layout.height);
		ctx.fillStyle = "#0b0d12";
		ctx.fillRect(0,0,layout.width, layout.height);
		for (let y=0; y<ROWS; y++) {
			for (let x=0; x<COLS; x++) {
				const even = (x+y)%2===0;
				ctx.fillStyle = even ? "#2c3042" : "#40465c";
				ctx.fillRect(layout.offsetX + x*layout.cell, layout.offsetY + y*layout.cell, layout.cell, layout.cell);
			}
		}
	}

	function drawPieces(ctx) {
		ctx.clearRect(0,0,layout.width, layout.height);
		ctx.font = `${layout.cell*0.5}px "Segoe UI Symbol", sans-serif`;
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		for (let y=0; y<ROWS; y++) {
			for (let x=0; x<COLS; x++) {
				const pc = state.board[y][x];
				if (!pc) continue;
				const cx = layout.offsetX + x*layout.cell + layout.cell/2;
				const cy = layout.offsetY + y*layout.cell + layout.cell/2;
				ctx.fillStyle = pc.color===LIGHT ? "#f5f5f7" : "#0f121b";
				ctx.strokeStyle = pc.color===LIGHT ? "#1d1f2a" : "#6ab0ff";
				ctx.lineWidth = 2.5;
				ctx.beginPath();
				ctx.arc(cx, cy, layout.cell*0.36, 0, Math.PI*2);
				ctx.fill();
				ctx.stroke();
				ctx.fillStyle = pc.color===LIGHT ? "#111" : "#f5f5f7";
				ctx.fillText(pieceGlyph(pc), cx, cy + layout.cell*0.02);
			}
		}

		const ui = uiLayer.getContext("2d");
		ui.clearRect(0,0,layout.width, layout.height);
		if (state.selected) {
			drawCellOutline(ui, state.selected.x, state.selected.y, "#58c6ff", 3);
			state.legal.forEach(m => drawCellOutline(ui, m.x, m.y, "#ffd166", 2));
		}
		if (state.lastMove) {
			drawCellOutline(ui, state.lastMove.from.x, state.lastMove.from.y, "#7ed0ff", 2);
			drawCellOutline(ui, state.lastMove.to.x, state.lastMove.to.y, "#7ed0ff", 2);
		}
		drawCellOutline(ui, state.cursor.x, state.cursor.y, "#58c6ff", 1.5, true);
	}

	function pieceGlyph(pc) {
		const map = { K:"♔", Q:"♕", R:"♖", B:"♗", N:"♘", P:"♙" };
		const g = map[pc.type] || pc.type;
		return pc.color === LIGHT ? g : g.toLowerCase();
	}

	function drawCellOutline(ctx, x, y, color, w, dashed=false) {
		const scrX = layout.offsetX + x*layout.cell;
		const scrY = layout.offsetY + y*layout.cell;
		ctx.save();
		if (dashed) ctx.setLineDash([6,4]);
		ctx.strokeStyle = color;
		ctx.lineWidth = w;
		ctx.strokeRect(scrX+2, scrY+2, layout.cell-4, layout.cell-4);
		ctx.restore();
	}

	function clickCell(x, y) {
		if (state.menuActive || state.gameOver) return;
		const pc = state.board[y][x];
		if (state.selected) {
			const isLegal = state.legal.some(m => m.x===x && m.y===y);
			if (isLegal) {
				makeMove(state.selected.x, state.selected.y, x, y);
				state.selected = null; state.legal = [];
				return;
			}
		}
		if (pc && pc.color === state.turn) {
			state.selected = { x, y };
			state.legal = legalMovesFor(x, y, state.board, state.turn);
			state.cursor = { x, y };
			state.message = "";
		} else {
			state.selected = null; state.legal = []; state.message = "";
		}
		updateHud();
		render();
	}

	function makeMove(fx, fy, tx, ty) {
		if (state.gameOver) return;
		const pc = state.board[fy][fx];
		if (!pc) return;
		const target = state.board[ty][tx];
		const move = { from:{x:fx,y:fy}, to:{x:tx,y:ty}, piece:{...pc}, captured: target ? [{ x:tx, y:ty, piece:{...target} }] : [] };
		state.board[fy][fx] = null;
		let moved = { ...pc };
		if (moved.type === "P" && (ty === 0 || ty === ROWS-1)) moved = p("Q", pc.color);
		state.board[ty][tx] = moved;

		if (move.captured.length) state.material[pc.color] += PIECE_VALUES[move.captured[0].piece.type];
		if (target && target.type === "K") { state.gameOver = true; state.winner = pc.color===LIGHT?"White":"Black"; state.message = "King captured"; finalizeMove(move, pc); return; }

		const opp = oppColor(pc.color);
		const oppHasMoves = hasAnyLegalMove(state.board, opp);
		const oppKingSafe = !inCheck(state.board, opp);
		if (!oppHasMoves) {
			state.gameOver = true;
			if (oppKingSafe) { state.draw = true; state.message = "Stalemate"; state.winner = null; }
			else { state.winner = pc.color===LIGHT?"White":"Black"; state.message = "Checkmate"; }
			finalizeMove(move, pc); return;
		}
		if (!oppKingSafe && isMate(state.board, opp)) { state.gameOver = true; state.winner = pc.color===LIGHT?"White":"Black"; state.message = "Checkmate"; finalizeMove(move, pc); return; }

		state.turn = opp;
		finalizeMove(move, pc);
	}

	function finalizeMove(move, mover) {
		state.moveHistory.push(move);
		state.lastMove = move;
		state.selected = null;
		state.legal = [];
		updateHud();
		render();
		maybeRunAI();
	}

	function legalMovesFor(x, y, board, color) {
		const pc = board[y][x];
		if (!pc || pc.color !== color) return [];
		const raw = pseudoMoves(x, y, board, color);
		const legal = [];
		for (const m of raw) {
			const temp = cloneBoard(board);
			applyMove(temp, {from:{x,y}, to:m}, pc);
			if (!inCheck(temp, color)) legal.push(m);
		}
		return legal;
	}

	function pseudoMoves(x, y, board, color) {
		const pc = board[y][x];
		if (!pc) return [];
		const moves = [];
		const addRay = dirs => {
			for (const [dx, dy] of dirs) {
				let nx = x+dx, ny = y+dy;
				while (onBoard(nx, ny)) {
					const t = board[ny][nx];
					if (!t) moves.push({x:nx,y:ny});
					else { if (t.color !== color) moves.push({x:nx,y:ny}); break; }
					nx += dx; ny += dy;
				}
			}
		};
		switch(pc.type) {
			case "R": addRay([[1,0],[-1,0],[0,1],[0,-1]]); break;
			case "B": addRay([[1,1],[1,-1],[-1,1],[-1,-1]]); break;
			case "Q": addRay([[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]); break;
			case "N": {
				const steps = [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]];
				for (const [dx,dy] of steps) { const nx=x+dx, ny=y+dy; if (onBoard(nx,ny) && (!board[ny][nx] || board[ny][nx].color!==color)) moves.push({x:nx,y:ny}); }
				break;
			}
			case "K": {
				const steps = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
				for (const [dx,dy] of steps) { const nx=x+dx, ny=y+dy; if (onBoard(nx,ny) && (!board[ny][nx] || board[ny][nx].color!==color)) moves.push({x:nx,y:ny}); }
				break;
			}
			case "P": {
				const dir = color===LIGHT ? -1 : 1;
				const ny = y+dir;
				if (onBoard(x, ny) && !board[ny][x]) moves.push({x:x, y:ny});
				for (const dx of [-1,1]) {
					const nx = x+dx; if (onBoard(nx, ny) && board[ny][nx] && board[ny][nx].color!==color) moves.push({x:nx,y:ny});
				}
				break;
			}
		}
		return moves;
	}

	function applyMove(board, mv, mover) {
		const { from, to } = mv;
		const pc = { ...board[from.y][from.x] };
		board[from.y][from.x] = null;
		let place = pc;
		if (pc.type === "P" && (to.y === 0 || to.y === ROWS-1)) place = p("Q", pc.color);
		board[to.y][to.x] = place;
	}

	function cloneBoard(b) { return b.map(row => row.map(pc => pc ? { ...pc } : null)); }

	function inCheck(board, color) {
		let kx=-1, ky=-1;
		for (let y=0; y<ROWS; y++) for (let x=0; x<COLS; x++) { const pc=board[y][x]; if (pc && pc.color===color && pc.type==="K") { kx=x; ky=y; } }
		if (kx===-1) return true;
		const opp = oppColor(color);
		for (let y=0; y<ROWS; y++) {
			for (let x=0; x<COLS; x++) {
				const pc = board[y][x];
				if (!pc || pc.color!==opp) continue;
				const pseudo = pseudoMoves(x, y, board, opp);
				if (pseudo.some(m => m.x===kx && m.y===ky)) return true;
			}
		}
		return false;
	}

	function hasAnyLegalMove(board, color) {
		for (let y=0; y<ROWS; y++) {
			for (let x=0; x<COLS; x++) {
				const pc = board[y][x];
				if (!pc || pc.color!==color) continue;
				const legal = legalMovesFor(x, y, board, color);
				if (legal.length) return true;
			}
		}
		return false;
	}

	function isMate(board, color) { return inCheck(board, color) && !hasAnyLegalMove(board, color); }

	function undo() {
		const mv = state.moveHistory.pop();
		if (!mv) return;
		state.board[mv.from.y][mv.from.x] = { ...mv.piece };
		state.board[mv.to.y][mv.to.x] = null;
		if (mv.captured && mv.captured.length) {
			const c = mv.captured[0];
			state.board[c.y][c.x] = { ...c.piece };
			state.material[mv.piece.color] -= PIECE_VALUES[c.piece.type];
		}
		state.turn = mv.piece.color;
		state.lastMove = state.moveHistory[state.moveHistory.length-1] || null;
		state.gameOver = false;
		state.winner = null;
		state.draw = false;
		updateHud();
		render();
	}

	function moveCursor(dx, dy) {
		state.cursor.x = Math.max(0, Math.min(COLS-1, state.cursor.x + dx));
		state.cursor.y = Math.max(0, Math.min(ROWS-1, state.cursor.y + dy));
	}

	function maybeRunAI() {
		if (!state.aiEnabled || state.menuActive || state.gameOver || state.turn !== state.aiColor || state.thinking) return;
		state.thinking = true;
		setTimeout(() => {
			const mv = aiChooseMove();
			if (mv) makeMove(mv.from.x, mv.from.y, mv.to.x, mv.to.y);
			state.thinking = false;
			updateHud();
		}, state.aiLevel === "hard" ? 120 : state.aiLevel === "medium" ? 160 : 220);
	}

	function listMoves(board, color) {
		const res = [];
		for (let y=0; y<ROWS; y++) {
			for (let x=0; x<COLS; x++) {
				const pc = board[y][x];
				if (!pc || pc.color!==color) continue;
				const legal = legalMovesFor(x, y, board, color);
				for (const m of legal) res.push({ from:{x,y}, to:m, piece:pc });
			}
		}
		return res;
	}

	function aiChooseMove() {
		const depth = state.aiLevel === "hard" ? 3 : state.aiLevel === "medium" ? 2 : 1;
		const moves = listMoves(state.board, state.aiColor);
		if (!moves.length) return null;
		let best = -Infinity;
		let bestMoves = [];
		for (const mv of moves) {
			const temp = cloneBoard(state.board);
			const score = -negamax(temp, mv, state.aiColor, depth, -Infinity, Infinity);
			if (score > best + 1e-6) { best = score; bestMoves = [mv]; }
			else if (Math.abs(score - best) < 1e-6) bestMoves.push(mv);
		}
		return bestMoves[Math.floor(Math.random()*bestMoves.length)];
	}

	function negamax(board, mv, color, depth, alpha, beta) {
		const temp = cloneBoard(board);
		applyMove(temp, mv, temp[mv.from.y][mv.from.x]);
		const opp = oppColor(color);
		const captured = board[mv.to.y][mv.to.x] ? PIECE_VALUES[board[mv.to.y][mv.to.x].type] : 0;
		let score = captured;
		if (inCheck(temp, opp) && !hasAnyLegalMove(temp, opp)) return 999; // mate
		if (depth === 1) return evaluate(temp, opp) * -1;
		const oppMoves = listMoves(temp, opp);
		if (!oppMoves.length) return inCheck(temp, opp) ? 999 : 0;
		let best = -Infinity;
		for (const om of oppMoves) {
			const val = -negamax(temp, om, opp, depth-1, -beta, -alpha);
			best = Math.max(best, val);
			alpha = Math.max(alpha, val);
			if (alpha >= beta) break;
		}
		return score + best;
	}

	function evaluate(board, toMove) {
		const white = materialScore(board, LIGHT);
		const black = materialScore(board, DARK);
		const mobility = listMoves(board, toMove).length * 0.05;
		return (toMove===LIGHT ? white-black : black-white) + mobility;
	}

	function materialScore(board, color) {
		let s = 0;
		for (let y=0; y<ROWS; y++) for (let x=0; x<COLS; x++) { const pc=board[y][x]; if (pc && pc.color===color) s += PIECE_VALUES[pc.type]; }
		return s;
	}

	function renderHistory() {
		const sq = (x,y) => `${String.fromCharCode(97+x)}${ROWS - y}`;
		moveList.innerHTML = state.moveHistory.map((mv,i) => {
			const caps = mv.captured && mv.captured.length ? "x" : "-";
			return `<div class="move-line">${i+1}. ${sq(mv.from.x, mv.from.y)}${caps}${sq(mv.to.x, mv.to.y)}</div>`;
		}).join("");
	}

	function toggleHistory(force) { const show = force!==undefined ? force : !historyPanel.classList.contains("show"); historyPanel.classList.toggle("show", show); }
	function toggleRules(force) { const show = force!==undefined ? force : !rulesOverlay.classList.contains("show"); rulesOverlay.classList.toggle("show", show); }
	function showStartOverlay() { startOverlay.style.display = "flex"; state.menuActive = true; setBoardInput(false); }
	function setBoardInput(enabled) { uiLayer.style.pointerEvents = enabled ? "auto" : "none"; }

	function handlePointer(e) {
		if (state.menuActive) return;
		const rect = uiLayer.getBoundingClientRect();
		const mx = e.clientX - rect.left;
		const my = e.clientY - rect.top;
		const x = Math.floor((mx - layout.offsetX)/layout.cell);
		const y = Math.floor((my - layout.offsetY)/layout.cell);
		if (!onBoard(x,y)) return;
		state.cursor = { x, y };
		clickCell(x, y);
	}

	function handleKey(e) {
		const key = e.key.toLowerCase();
		if (rulesOverlay.classList.contains("show")) { if (["h","escape","enter"," "].includes(key)) toggleRules(false); return; }
		if (state.menuActive) {
			if (key === "1") { selectedMode = "1p"; applyModeUI(); }
			else if (key === "2") { selectedMode = "2p"; applyModeUI(); }
			else if (key === "arrowup" || key === "w") { cycleDiff(-1); }
			else if (key === "arrowdown" || key === "s") { cycleDiff(1); }
			else if (key === "enter" || key === " ") { startSelected(); }
			return;
		}
		if (key === "arrowup") moveCursor(0,-1);
		else if (key === "arrowdown") moveCursor(0,1);
		else if (key === "arrowleft") moveCursor(-1,0);
		else if (key === "arrowright") moveCursor(1,0);
		else if (key === "enter" || key === " ") clickCell(state.cursor.x, state.cursor.y);
		else if (key === "escape") { state.selected=null; state.legal=[]; state.message=""; }
		else if (key === "u") { undo(); }
		else if (key === "r") { resetBoard(); render(); updateHud(); }
		else if (key === "h") { toggleRules(); }
		updateHud();
		render();
		maybeRunAI();
	}

	function updateHud() {
		turnText.textContent = `Turn: ${state.turn===LIGHT?"WHITE":"BLACK"}`;
		aiText.textContent = state.aiEnabled ? `AI: ${state.aiLevel.toUpperCase()} (${state.aiColor===LIGHT?"WHITE":"BLACK"})` : "AI: OFF";
		msgText.textContent = state.gameOver ? (state.draw ? "Draw" : state.winner ? `${state.winner} wins` : "Game over") : (state.message || "Ready");
		capText.textContent = `Material W:${state.material[LIGHT]} B:${state.material[DARK]}`;
		if (state.lastMove) {
			const { from, to } = state.lastMove;
			lastMoveText.textContent = `Last: ${String.fromCharCode(97+from.x)}${ROWS-from.y}${String.fromCharCode(97+to.x)}${ROWS-to.y}`;
		} else lastMoveText.textContent = "Last: --";
		renderHistory();
		if (!state.menuActive && state.aiEnabled && !state.gameOver && state.turn === state.aiColor && !state.thinking) maybeRunAI();
	}

	function applyModeUI() { [btn1p, btn2p].forEach(b => b.classList.remove("active")); (selectedMode==="1p"?btn1p:btn2p).classList.add("active"); }
	function setDifficulty(level) { state.aiLevel = level; selectedDiff = level; applyDifficultyUI(); updateHud(); }
	function applyDifficultyUI() { [btnEasy, btnMed, btnHard].forEach(b => b.classList.remove("active")); ({easy:btnEasy, medium:btnMed, hard:btnHard})[state.aiLevel].classList.add("active"); selectedDiff = state.aiLevel; }
	function cycleDiff(delta) { const diffs=["easy","medium","hard"]; const idx=diffs.indexOf(selectedDiff); selectedDiff=diffs[(idx+delta+diffs.length)%diffs.length]; state.aiLevel=selectedDiff; applyDifficultyUI(); }

	function start1P() { state.aiEnabled=true; state.aiColor=DARK; state.menuActive=false; startOverlay.style.display="none"; setBoardInput(true); resetBoard(); applyDifficultyUI(); render(); updateHud(); maybeRunAI(); }
	function start2P() { state.aiEnabled=false; state.menuActive=false; startOverlay.style.display="none"; setBoardInput(true); resetBoard(); applyDifficultyUI(); render(); updateHud(); }
	function startSelected() { state.aiLevel = selectedDiff; if (selectedMode==="1p") start1P(); else start2P(); }

	function render() { drawBoard(boardLayer.getContext("2d")); drawPieces(piecesLayer.getContext("2d")); }

	// Init
	resetBoard();
	resize();
	applyDifficultyUI();
	applyModeUI();
	setBoardInput(false);
	render();
	updateHud();

	// Events
	uiLayer.addEventListener("mousedown", handlePointer);
	window.addEventListener("resize", () => { resize(); render(); });
	window.addEventListener("keydown", handleKey);
	btn1p.addEventListener("click", () => { selectedMode="1p"; applyModeUI(); });
	btn2p.addEventListener("click", () => { selectedMode="2p"; applyModeUI(); });
	btnEasy.addEventListener("click", () => setDifficulty("easy"));
	btnMed.addEventListener("click", () => setDifficulty("medium"));
	btnHard.addEventListener("click", () => setDifficulty("hard"));
	btnStartOverlay.addEventListener("click", startSelected);
	btnRules.addEventListener("click", () => toggleRules(true));
	closeRules.addEventListener("click", () => toggleRules(false));
	hudBtnStart.addEventListener("click", showStartOverlay);
	hudBtnReset.addEventListener("click", () => { resetBoard(); render(); updateHud(); });
	hudBtnUndo.addEventListener("click", () => { undo(); render(); updateHud(); });
	hudBtnHistory.addEventListener("click", () => toggleHistory());
	btnHistoryClose.addEventListener("click", () => toggleHistory(false));

})();
</script>
</body>
</html>
